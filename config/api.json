{
  "metadata": {
    "toolPackage": "@microsoft/api-extractor",
    "toolVersion": "7.52.13",
    "schemaVersion": 1011,
    "oldestForwardsCompatibleVersion": 1001,
    "tsdocConfig": {
      "$schema": "https://developer.microsoft.com/json-schemas/tsdoc/v0/tsdoc.schema.json",
      "noStandardTags": true,
      "tagDefinitions": [
        {
          "tagName": "@alpha",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@beta",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@defaultValue",
          "syntaxKind": "block"
        },
        {
          "tagName": "@decorator",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@deprecated",
          "syntaxKind": "block"
        },
        {
          "tagName": "@eventProperty",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@example",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@experimental",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@inheritDoc",
          "syntaxKind": "inline"
        },
        {
          "tagName": "@internal",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@label",
          "syntaxKind": "inline"
        },
        {
          "tagName": "@link",
          "syntaxKind": "inline",
          "allowMultiple": true
        },
        {
          "tagName": "@override",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@packageDocumentation",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@param",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@privateRemarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@public",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@readonly",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@remarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@returns",
          "syntaxKind": "block"
        },
        {
          "tagName": "@sealed",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@see",
          "syntaxKind": "block"
        },
        {
          "tagName": "@throws",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@typeParam",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@virtual",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@betaDocumentation",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@internalRemarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@preapproved",
          "syntaxKind": "modifier"
        }
      ],
      "supportForTags": {
        "@alpha": true,
        "@beta": true,
        "@defaultValue": true,
        "@decorator": true,
        "@deprecated": true,
        "@eventProperty": true,
        "@example": true,
        "@experimental": true,
        "@inheritDoc": true,
        "@internal": true,
        "@label": true,
        "@link": true,
        "@override": true,
        "@packageDocumentation": true,
        "@param": true,
        "@privateRemarks": true,
        "@public": true,
        "@readonly": true,
        "@remarks": true,
        "@returns": true,
        "@sealed": true,
        "@see": true,
        "@throws": true,
        "@typeParam": true,
        "@virtual": true,
        "@betaDocumentation": true,
        "@internalRemarks": true,
        "@preapproved": true
      },
      "reportUnsupportedHtmlElements": false
    }
  },
  "projectFolderUrl": "https://github.com/middle-ages/effect-tree/main",
  "kind": "Package",
  "canonicalReference": "effect-tree!",
  "docComment": "",
  "name": "effect-tree",
  "preserveMemberOrder": false,
  "members": [
    {
      "kind": "EntryPoint",
      "canonicalReference": "effect-tree!",
      "name": "",
      "preserveMemberOrder": false,
      "members": [
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!addLevelLabels:function(1)",
          "docComment": "/**\n * Annotate a string tree with label that indicate the node depth and index in their parent node.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "addLevelLabels: (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<string>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<string>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "addLevelLabels"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!allLeaves:var",
          "docComment": "/**\n * Get all tree leaves.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "allLeaves: "
            },
            {
              "kind": "Reference",
              "text": "GetNodes",
              "canonicalReference": "effect-tree!GetNodes:type"
            }
          ],
          "fileUrlPath": "src/ops/traverse.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "allLeaves",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!allLeavesFold:var",
          "docComment": "/**\n * Collect all _leaves_ from a single tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "allLeavesFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolderK",
              "canonicalReference": "effect-tree!TreeFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArrayTypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/ops/traverse.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "allLeavesFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!annotateDepth:function(1)",
          "docComment": "/**\n * Returns tree nodes paired with their hop count from root.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "annotateDepth: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<readonly [A, number]>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "annotateDepth"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!annotateDepthUnfold:function(1)",
          "docComment": "/**\n * Annotate nodes at a tree level with their depth.  @category unfold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "annotateDepthUnfold: <A>([tree, previousDepth]: "
            },
            {
              "kind": "Content",
              "text": "["
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, number]"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<readonly [A, number], ["
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, number]>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "[tree, previousDepth]",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "annotateDepthUnfold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!annotateEffectFolder:function(1)",
          "docComment": "/**\n * Like {@link annotateFolder} but for _effect folders_.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "annotateEffectFolder: <A, B, E = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ">(φ: "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectFolder",
              "canonicalReference": "effect-tree!TreeEffectFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, B, E, R>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(self: "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<[A, B]>>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<[A, B]>, E, R>"
            }
          ],
          "fileUrlPath": "src/schemes/fold/annotate.ts",
          "returnTypeTokenRange": {
            "startIndex": 8,
            "endIndex": 17
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "φ",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 7
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "name": "annotateEffectFolder"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!annotateEffectUnfolder:function(1)",
          "docComment": "/**\n * @category unfold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "annotateEffectUnfolder: <A, B, E = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ">(ψ: "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectUnfolder",
              "canonicalReference": "effect-tree!TreeEffectUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectUnfolder",
              "canonicalReference": "effect-tree!TreeEffectUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<[B, A], ["
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, A], E, R>"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/annotate.ts",
          "returnTypeTokenRange": {
            "startIndex": 10,
            "endIndex": 14
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "ψ",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 9
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "name": "annotateEffectUnfolder"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!annotateFolder:function(1)",
          "docComment": "/**\n * Converts a fold `φ` into one that _annotates_ tree values: every tree node will be annotated with the intermediate value of the fold at the node.\n *\n * For example, to convert the `descendantCount` fold, that folds a tree into a _tree total descendant count_ to one that annotates each node with its _node total descendant count_:\n * ```ts\n * const annotated = pipe(\n *   tree(42, [leaf(43)]),\n *   self, treeCata(annotateFolder(folds.descendantCount))),\n * )\n * ```\n *\n * @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "annotateFolder: <A, B>(φ: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<[A, B]>>"
            }
          ],
          "fileUrlPath": "src/schemes/fold/annotate.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "φ",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "annotateFolder"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!annotateLevelLabelsUnfold:var",
          "docComment": "/**\n * Label a string tree with a level index. A level index is a string that looks like: `1.3.11.2`. The last number is the index of the node in its parent, the number before that is the index of the parent in its parent, and so on, so that they form the unique path between the node and the tree root.\n *\n * {@link drill} will _get_ a child from a tree at a path.  @category unfold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "annotateLevelLabelsUnfold: "
            },
            {
              "kind": "Reference",
              "text": "TreeUnfolder",
              "canonicalReference": "effect-tree!TreeUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<string, [\n    string,\n    "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<string>\n]>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "annotateLevelLabelsUnfold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!annotateOrdinalUnfold:function(1)",
          "docComment": "/**\n * Unfold a tree level and annotate the nodes with their ordinal.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "annotateOrdinalUnfold: (counter: "
            },
            {
              "kind": "Reference",
              "text": "Ref.Ref",
              "canonicalReference": "effect!Ref:interface"
            },
            {
              "kind": "Content",
              "text": "<number>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "<A, E = never, R = never>(pair: ["
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, number]) => "
            },
            {
              "kind": "Reference",
              "text": "Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<[A, number], ["
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, number]>, E, R>"
            }
          ],
          "fileUrlPath": "src/ops/ordinal.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 13
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "counter",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "annotateOrdinalUnfold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!append:var",
          "docComment": "/**\n * Append a tree to the children of the root node. If `self` is a _leaf_, it is converted into a branch.\n *\n * @param self - The tree to modify.\n *\n * @param child - Child to append.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns A new updated tree with the new node appended.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "append: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, child: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(child: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/add.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "append",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 14
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!appendAll:var",
          "docComment": "/**\n * Append a list of trees to the children of the root node. If `self` is a _leaf_, it is converted into a branch.\n *\n * @param self - The tree to modify.\n *\n * @param children - A non-empty list of trees to append to the tree.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns A new updated tree with the new nodes appended.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "appendAll: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, children: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(children: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/add.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "appendAll",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 14
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!Applicative:var",
          "docComment": "/**\n * Applicative instance for {@link Tree}.  @category instances\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "Applicative: "
            },
            {
              "kind": "Reference",
              "text": "AP.Applicative",
              "canonicalReference": "@effect/typeclass!Applicative:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/instances/Applicative.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "Applicative",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Namespace",
          "canonicalReference": "effect-tree!Arbitrary:namespace",
          "docComment": "",
          "excerptTokens": [],
          "fileUrlPath": "index.ts",
          "releaseTag": "None",
          "name": "Arbitrary",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Arbitrary.codePointArbitrary:function(1)",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "codePointArbitrary: (min: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ", max: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "min",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "max",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "name": "codePointArbitrary"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Arbitrary.letterArbitrary:var",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "letterArbitrary: "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "letterArbitrary",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Arbitrary.lowerCaseArbitrary:var",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "lowerCaseArbitrary: "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "lowerCaseArbitrary",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Arbitrary.nonEmptyArrayArbitrary:function(1)",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "nonEmptyArrayArbitrary: <T>(arb: "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<T>"
                },
                {
                  "kind": "Content",
                  "text": ", options?: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<{\n    minLength: number;\n    maxLength: number;\n}>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<T>>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "returnTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 11
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "arb",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "options",
                  "parameterTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "isOptional": true
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "T",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "nonEmptyArrayArbitrary"
            },
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Arbitrary.Part:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/arbitrary.ts",
              "releaseTag": "None",
              "name": "Part",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.Part.Arbitrary:function(1)",
                  "docComment": "/**\n * An arbitrary for a recursive {@link Part} that describes how to render a rectangular block.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "Arbitrary: (options?: "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    maxDepth?: number;\n}"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Part",
                      "canonicalReference": "effect-tree!Draw.Part_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Part.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 7
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "options",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": true
                    }
                  ],
                  "name": "Arbitrary"
                }
              ]
            },
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Arbitrary.PartF:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/arbitrary.ts",
              "releaseTag": "None",
              "name": "PartF",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.PartF.AlignedArbitrary:var",
                  "docComment": "/**\n * @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "AlignedArbitrary: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Aligned",
                      "canonicalReference": "effect-tree!Draw.Aligned:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/PartF.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "AlignedArbitrary",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.PartF.EmptyPartFArbitrary:var",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "EmptyPartFArbitrary: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "EmptyF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.EmptyF:type"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/PartF.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "EmptyPartFArbitrary",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.PartF.getArbitrary:function(1)",
                  "docComment": "/**\n * An arbitrary for a filled rectangular block of text used for drawing trees.  @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getArbitrary: <A>(a: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF.PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/PartF.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "a",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getArbitrary"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.PartF.getColumnFArbitrary:function(1)",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getColumnFArbitrary: <A>(a: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "ColumnF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.ColumnF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/PartF.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "a",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getColumnFArbitrary"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.PartF.getRowFArbitrary:function(1)",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getRowFArbitrary: <A>(a: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "RowF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.RowF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/PartF.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "a",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getRowFArbitrary"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.PartF.HorizontalArbitrary:var",
                  "docComment": "/**\n * @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "HorizontalArbitrary: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontallyAligned",
                      "canonicalReference": "effect-tree!Draw.HorizontallyAligned:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/PartF.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "HorizontalArbitrary",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.PartF.TextFPArtArbitrary:var",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "TextFPArtArbitrary: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "TextF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.TextF:type"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/PartF.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "TextFPArtArbitrary",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.PartF.VerticalArbitrary:var",
                  "docComment": "/**\n * @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "VerticalArbitrary: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticallyAligned",
                      "canonicalReference": "effect-tree!Draw.VerticallyAligned:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/PartF.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "VerticalArbitrary",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Arbitrary.tinyLettersArbitrary:var",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tinyLettersArbitrary: "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<string[]>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tinyLettersArbitrary",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Arbitrary.tinyLetterStringArbitrary:var",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tinyLetterStringArbitrary: "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tinyLetterStringArbitrary",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Arbitrary.tinyNonEmptyLettersArbitrary:var",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tinyNonEmptyLettersArbitrary: "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tinyNonEmptyLettersArbitrary",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Arbitrary.tinyNonEmptyLetterStringArbitrary:var",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tinyNonEmptyLetterStringArbitrary: "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tinyNonEmptyLetterStringArbitrary",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Arbitrary.Tree:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/arbitrary.ts",
              "releaseTag": "None",
              "name": "Tree",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.ArbitraryOptions:interface",
                  "docComment": "/**\n * Tree arbitrary generation options.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface ArbitraryOptions "
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "releaseTag": "Public",
                  "name": "ArbitraryOptions",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Arbitrary.Tree.ArbitraryOptions#branchBias:member",
                      "docComment": "/**\n * Ratio of trees generated that will be branches and not leaves. Expects a ratio in the inclusive range of 0…1. Default is `¼`.\n */\n",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "branchBias: "
                        },
                        {
                          "kind": "Content",
                          "text": "number"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "branchBias",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      }
                    },
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Arbitrary.Tree.ArbitraryOptions#maxChildren:member",
                      "docComment": "/**\n * Max child count per branch. Default is `5`.\n */\n",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "maxChildren: "
                        },
                        {
                          "kind": "Content",
                          "text": "number"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "maxChildren",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      }
                    },
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Arbitrary.Tree.ArbitraryOptions#maxDepth:member",
                      "docComment": "/**\n * Maximum depth of trees generated. An error is thrown if `onlyBranches` is true but `maxDepth` is `0`.\n */\n",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "maxDepth: "
                        },
                        {
                          "kind": "Content",
                          "text": "number"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "maxDepth",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      }
                    },
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Arbitrary.Tree.ArbitraryOptions#onlyBranches:member",
                      "docComment": "/**\n * If true no leaves will be generated so that all trees will always have at least a height of `1`. Default is `false`.\n */\n",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "onlyBranches: "
                        },
                        {
                          "kind": "Content",
                          "text": "boolean"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "onlyBranches",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      }
                    }
                  ],
                  "extendsTokenRanges": []
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.biasedOneOf:function(1)",
                  "docComment": "/**\n * Choose one of the given leaf or branch arbitraries according to the branch bias.  @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "biasedOneOf: <A>(a: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ", branch: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "({ branchBias }: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.ArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 9,
                    "endIndex": 16
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "a",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "branch",
                      "parameterTypeTokenRange": {
                        "startIndex": 4,
                        "endIndex": 8
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "biasedOneOf"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.defaultNumberedOptions:var",
                  "docComment": "/**\n * @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "defaultNumberedOptions: "
                    },
                    {
                      "kind": "Reference",
                      "text": "NumberedArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.NumberedArbitraryOptions:interface"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "defaultNumberedOptions",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.defaultOptions:var",
                  "docComment": "/**\n * @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "defaultOptions: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.ArbitraryOptions:interface"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "defaultOptions",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.getArbitrary:function(1)",
                  "docComment": "/**\n * Get an arbitrary for a tree from an arbitrary of its underlying type and partial {@link ArbitraryOptions}.\n *\n * @param a - Arbitrary for the underlying type.\n *\n * @param rawOptions - partial arbitrary options.\n *\n * @returns A tree arbitrary.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getArbitrary: <A>(a: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ", rawOptions?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Partial",
                      "canonicalReference": "!Partial:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "ArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.ArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree.Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/index.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 9,
                    "endIndex": 13
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "a",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "rawOptions",
                      "parameterTypeTokenRange": {
                        "startIndex": 4,
                        "endIndex": 8
                      },
                      "isOptional": true
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getArbitrary"
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.GetArbitrary:interface",
                  "docComment": "/**\n * Type of functions that build a tree arbitrary from the arbitrary runtime options.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface GetArbitrary<A> "
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "releaseTag": "Public",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "GetArbitrary",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "CallSignature",
                      "canonicalReference": "effect-tree!Arbitrary.Tree.GetArbitrary:call(1)",
                      "docComment": "",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "(options: "
                        },
                        {
                          "kind": "Reference",
                          "text": "RuntimeOptions",
                          "canonicalReference": "effect-tree!Arbitrary.Tree_2.RuntimeOptions:interface"
                        },
                        {
                          "kind": "Content",
                          "text": "): "
                        },
                        {
                          "kind": "Reference",
                          "text": "fc.Arbitrary",
                          "canonicalReference": "fast-check!Arbitrary:class"
                        },
                        {
                          "kind": "Content",
                          "text": "<"
                        },
                        {
                          "kind": "Reference",
                          "text": "Tree",
                          "canonicalReference": "effect-tree!Tree:type"
                        },
                        {
                          "kind": "Content",
                          "text": "<A>>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "returnTypeTokenRange": {
                        "startIndex": 3,
                        "endIndex": 7
                      },
                      "releaseTag": "Public",
                      "overloadIndex": 1,
                      "parameters": [
                        {
                          "parameterName": "options",
                          "parameterTypeTokenRange": {
                            "startIndex": 1,
                            "endIndex": 2
                          },
                          "isOptional": false
                        }
                      ]
                    }
                  ],
                  "extendsTokenRanges": []
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.getNumberedArbitrary:function(1)",
                  "docComment": "/**\n * Just like {@link getArbitrary} except the tree is numeric and the the node values will be the unique ordinal of the node in depth-first order.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getNumberedArbitrary: (options?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Partial",
                      "canonicalReference": "!Partial:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "NumberedArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.NumberedArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/variants.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 6,
                    "endIndex": 10
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "options",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 5
                      },
                      "isOptional": true
                    }
                  ],
                  "name": "getNumberedArbitrary"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.getNumberedBranchArbitrary:function(1)",
                  "docComment": "/**\n * @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getNumberedBranchArbitrary: (options?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Partial",
                      "canonicalReference": "!Partial:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "NumberedArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.NumberedArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/variants.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 6,
                    "endIndex": 10
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "options",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 5
                      },
                      "isOptional": true
                    }
                  ],
                  "name": "getNumberedBranchArbitrary"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.getStringArbitrary:function(1)",
                  "docComment": "/**\n * Just like {@link getNumberedArbitrary} except the numeric nodes have been stringified.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getStringArbitrary: (options?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Partial",
                      "canonicalReference": "!Partial:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "NumberedArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.NumberedArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<string>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/variants.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 6,
                    "endIndex": 10
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "options",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 5
                      },
                      "isOptional": true
                    }
                  ],
                  "name": "getStringArbitrary"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.isAtMaxDepth:var",
                  "docComment": "/**\n * If true, this level will be all leaves.  @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "isAtMaxDepth: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Predicate.Predicate",
                      "canonicalReference": "effect!Predicate:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "RuntimeOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.RuntimeOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "isAtMaxDepth",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.nextDepth:var",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "nextDepth: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Function.EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "RuntimeOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.RuntimeOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "nextDepth",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.normalizeOptions:function(1)",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "normalizeOptions: ({ onlyBranches, ...options }?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Partial",
                      "canonicalReference": "!Partial:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "ArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.ArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "ArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.ArbitraryOptions:interface"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 6,
                    "endIndex": 7
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "{ onlyBranches, ...options }",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 5
                      },
                      "isOptional": true
                    }
                  ],
                  "name": "normalizeOptions"
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.NumberedArbitraryOptions:interface",
                  "docComment": "/**\n * Numbered arbitrary tree generation options. A numbered arbitrary tree has unique node values, one per each number in the inclusive range `initialize`…`initialize + nodeCount - 1` where the root node value is `initialize`.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface NumberedArbitraryOptions extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "ArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.ArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "releaseTag": "Public",
                  "name": "NumberedArbitraryOptions",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Arbitrary.Tree.NumberedArbitraryOptions#initialize:member",
                      "docComment": "/**\n * Start numbering of nodes at this number. Default is `1`.\n */\n",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "initialize: "
                        },
                        {
                          "kind": "Content",
                          "text": "number"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "initialize",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      }
                    }
                  ],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 2
                    }
                  ]
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.pruferEncodableArbitrary:var",
                  "docComment": "/**\n * A tree that can be encoded to a prüfer code has several requirements:\n *\n * 1. Root node value = `1`. 2. For each number in the inclusive range 2…nodeCount there exists a single non-root node with that value. 3. If you want round-trip encode/decode, make sure the branches are sorted. These six trees, for example, have the same prüfer code of `1, 1`:\n * ```txt\n *   •─┬─1  •─┬─1   •─┬─1   •─┬─1   •─┬─1   •─┬─1\n *     ├──2   ├──2    ├──3    ├──3    ├──4    ├──4\n *     ├──3   ├──4    ├──2    ├──4    ├──2    ├──3\n *     └──4   └──3    └──4    └──2    └──3    └──2\n *   ┈┈┈┈┈┈ ┈┈┈┈┈┈  ┈┈┈┈┈┈  ┈┈┈┈┈┈  ┈┈┈┈┈┈  ┈┈┈┈┈┈\n *     I      II     III      IV       V      VI\n * ```\n *\n * @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "pruferEncodableArbitrary: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/variants.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "pruferEncodableArbitrary",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.RuntimeOptions:interface",
                  "docComment": "/**\n * props threaded through the recursive arbitrary for Tree<A>.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface RuntimeOptions extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "ArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.ArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/options.ts",
                  "releaseTag": "Public",
                  "name": "RuntimeOptions",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Arbitrary.Tree.RuntimeOptions#currentDepth:member",
                      "docComment": "/**\n * Current depth from top. The value will be `0` for the root note, `1` for the 1st level nodes, and so on.\n */\n",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "currentDepth: "
                        },
                        {
                          "kind": "Content",
                          "text": "number"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "currentDepth",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      }
                    }
                  ],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 2
                    }
                  ]
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.voidBranchArbitrary:function(1)",
                  "docComment": "/**\n * A branch with nothing but structure.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "voidBranchArbitrary: (options?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Partial",
                      "canonicalReference": "!Partial:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Omit",
                      "canonicalReference": "!Omit:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "ArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.ArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ", \"onlyBranches\">>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<void>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/variants.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 8,
                    "endIndex": 12
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "options",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 7
                      },
                      "isOptional": true
                    }
                  ],
                  "name": "voidBranchArbitrary"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.Tree.voidTreeArbitrary:function(1)",
                  "docComment": "/**\n * A tree with nothing but structure.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "voidTreeArbitrary: (options?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Partial",
                      "canonicalReference": "!Partial:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "ArbitraryOptions",
                      "canonicalReference": "effect-tree!Arbitrary.Tree_2.ArbitraryOptions:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<void>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/Tree/variants.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 6,
                    "endIndex": 10
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "options",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 5
                      },
                      "isOptional": true
                    }
                  ],
                  "name": "voidTreeArbitrary"
                }
              ]
            },
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Arbitrary.TreeF:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/arbitrary.ts",
              "releaseTag": "None",
              "name": "TreeF",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Arbitrary.TreeF.getArbitrary:function(1)",
                  "docComment": "/**\n * An arbitrary {@link TreeF} built from the node and children arbitraries given.  @category arbitrary\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getArbitrary: <A>(a: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "<C>(c: "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<C>) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "fc.Arbitrary",
                      "canonicalReference": "fast-check!Arbitrary:class"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeF",
                      "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A, C>>"
                    }
                  ],
                  "fileUrlPath": "src/arbitrary/TreeF.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 11
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "a",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getArbitrary"
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Arbitrary.upperCaseArbitrary:var",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "upperCaseArbitrary: "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "upperCaseArbitrary",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Arbitrary.voidArbitrary:var",
              "docComment": "/**\n * @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "voidArbitrary: "
                },
                {
                  "kind": "Reference",
                  "text": "fc.Arbitrary",
                  "canonicalReference": "fast-check!Arbitrary:class"
                },
                {
                  "kind": "Content",
                  "text": "<void>"
                }
              ],
              "fileUrlPath": "src/arbitrary/util.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "voidArbitrary",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ]
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!asOrdinal:var",
          "docComment": "/**\n * Replaces all tree nodes with their unique ordinal. The order is depth-first post-order, so that the root node value is the maximum. For example a tree shaped so:\n * ```\n *  ┬?\n *  ├─?\n *  └┬?\n *   ├─?\n *   └─?\n * ```\n *\n * Will become this tree:\n * ```\n *  ┬5\n *  ├─1\n *  └┬4\n *   ├─2\n *   └─3\n * ```\n *\n * @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "asOrdinal: "
            },
            {
              "kind": "Content",
              "text": "{\n    (initialize: number): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<any>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<number>;\n    pre(initialize: number): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<any>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<number>;\n}"
            }
          ],
          "fileUrlPath": "src/ops/ordinal.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "asOrdinal",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 10
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!asOrdinalBranch:var",
          "docComment": "/**\n * A version of {@link asOrdinal} specialized for _branches_.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "asOrdinalBranch: "
            },
            {
              "kind": "Content",
              "text": "{\n    (initialize: number): (self: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<any>) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<number>;\n    pre(initialize: number): <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<number>;\n}"
            }
          ],
          "fileUrlPath": "src/ops/ordinal.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "asOrdinalBranch",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 10
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!average:function(1)",
          "docComment": "/**\n * Compute the arithmetic mean of all node values in a numeric tree.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "average: (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<number>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "number"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "average"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!averageFold:var",
          "docComment": "/**\n * Compute a running average for a single level in a numeric tree.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "averageFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "RunningAverage",
              "canonicalReference": "effect-tree!RunningAverage:interface"
            },
            {
              "kind": "Content",
              "text": ", "
            },
            {
              "kind": "Reference",
              "text": "RunningAverage",
              "canonicalReference": "effect-tree!RunningAverage:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "averageFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!binaryTree:var",
          "docComment": "/**\n * Create a binary level tree at the given depth. In a _level tree_, the value of each node is set to its depth.\n *\n * At the key `string` you will find a version that returns the tree where nodes have been formatted as strings instead of number.\n * ```ts\n * import {binaryTree, drawTree, type Tree} from 'effect-tree'\n *\n * const tree: Tree<number> = binaryTree(3)\n *\n * console.log(drawTree(tree).join('\\n'))\n *\n * // prints:\n * //  ┬1\n * //  ├┬2\n * //  │├─3\n * //  │└─3\n * //  └┬2\n * //   ├─3\n * //   └─3\n * ```\n *\n * @param depth - Tree depth requested. Tree returned is perfectly balanced. When depth is zero returns a leaf.\n *\n * @returns A binary level tree of the given depth..  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "binaryTree: "
            },
            {
              "kind": "Content",
              "text": "{\n    (depth: number): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<number>;\n    string: (depth: number) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<string>;\n}"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "binaryTree",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!BooleanFold:type",
          "docComment": "/**\n * The type of function the builds a tree fold from a predicate.  @category instances\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type BooleanFold = "
            },
            {
              "kind": "Content",
              "text": "<A>(predicate: "
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "TreeFold",
              "canonicalReference": "effect-tree!TreeFold:type"
            },
            {
              "kind": "Content",
              "text": "<A, boolean>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "releaseTag": "Public",
          "name": "BooleanFold",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!BooleanFolder:type",
          "docComment": "/**\n * The type of function the builds a tree folder from a predicate.  @category instances\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type BooleanFolder = "
            },
            {
              "kind": "Content",
              "text": "<A>(predicate: "
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, boolean>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "releaseTag": "Public",
          "name": "BooleanFolder",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!bottomSubtrees:function(1)",
          "docComment": "/**\n * The set of all bottom-grounded subtrees of a tree. This is the set of every subtree of the tree `T` that:\n *\n * 1. The subtree root is a node of `T`. Every node in `T` appears exactly once in its subtrees list as root node. 2. The leaves of the subtree are exactly the leaves reachable from its root node in the tree `T`. This makes it _bottom-grounded_.\n *\n * The number of such subtrees of a tree is the number of nodes in the tree.\n *\n * For example consider the tree:\n * ```txt\n * ┬root\n * ├┬a\n * │├─b\n * │└─c\n * └┬d\n *  ├─e\n *  └─f\n * ```\n *\n * `bottomSubtrees` will return for this tree _seven_ trees, one per node:\n * ```txt\n *   1. ─b       4. ─e     7. ┬root\n *                            ├┬a\n *   2. ─c       5. ─f        │├─b\n *                            │└─c\n *   3. ┬a       6. ┬d        └┬d\n *      ├─b         ├─e        ├─e\n *      └─c         └─f        └─f\n * ```\n *\n * @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "bottomSubtrees: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray",
              "canonicalReference": "effect!NonEmptyArray:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/ops/subtrees.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "bottomSubtrees"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!bottomSubtreesFold:var",
          "docComment": "/**\n * Collect all bottom-grounded subtrees of a single tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "bottomSubtreesFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeProductFolderK",
              "canonicalReference": "effect-tree!TreeProductFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "ForestTypeLambda",
              "canonicalReference": "effect-tree!ForestTypeLambda:type"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/ops/subtrees.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "bottomSubtreesFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!Branch:type",
          "docComment": "/**\n * The branch type of {@link Tree}. Branches are simple wrappers over {@link BranchF} values.\n *\n * @typeParam A - Underlying tree type.  @category basic\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Branch<A> = "
            },
            {
              "kind": "Reference",
              "text": "Record",
              "canonicalReference": "!Record:type"
            },
            {
              "kind": "Content",
              "text": "<'unfixed', "
            },
            {
              "kind": "Reference",
              "text": "BranchF",
              "canonicalReference": "effect-tree!TreeF.BranchF:interface"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/tree/types.ts",
          "releaseTag": "Public",
          "name": "Branch",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!branch:var",
          "docComment": "/**\n * Create a new branch from its value and a non-empty list of child nodes. child nodes.\n *\n * At the `flipped` key you will find a flipped curried version that accepts two argument lists: the first with the value and the second with the forest.\n *\n * At the `tupled` key you will find a tupled version that accepts as its single argument a tuple of value and forest.\n *\n * @param value - The tree root value.\n *\n * @param forest - A non-empty list of child nodes, all of the same type as this parent node.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns A new branch with the given value and forest.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "branch: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(value: A, forest: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>): "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(forest: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (value: A) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    flipped: <A>(value: A) => (forest: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    tupled: <A>(valueAndForest: [value: A, forest: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>]) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "branch",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 18
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!breadthOrderValues:var",
          "docComment": "/**\n * Return tree nodes in breadth-first order.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "breadthOrderValues: "
            },
            {
              "kind": "Reference",
              "text": "GetNodes",
              "canonicalReference": "effect-tree!GetNodes:type"
            }
          ],
          "fileUrlPath": "src/ops/traverse.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "breadthOrderValues",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!byParentUnfold:function(1)",
          "docComment": "/**\n * Unfold a level of a tree defined by its unfolding function which must decide, given the current node, who are its children?  @category unfold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "byParentUnfold: <A>(unfolder: "
            },
            {
              "kind": "Content",
              "text": "(parent: A) => A[]"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeUnfolder",
              "canonicalReference": "effect-tree!TreeUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "unfolder",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "byParentUnfold"
        },
        {
          "kind": "Namespace",
          "canonicalReference": "effect-tree!Codec:namespace",
          "docComment": "",
          "excerptTokens": [],
          "fileUrlPath": "index.ts",
          "releaseTag": "None",
          "name": "Codec",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Codec.Arrays:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/codec.ts",
              "releaseTag": "None",
              "name": "Arrays",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Arrays.decode:function(1)",
                  "docComment": "/**\n * Decode nested arrays into a tree.\n * ```ts\n * import {Codec, drawTree} from 'effect-tree'\n *\n * const tree = Codec.Arrays.decode([\n *   1, [\n *     2, [3, 4, 5],\n *     [6, [\n *       7,\n *       8,\n *       [11, [9]],\n *     ]],\n *     10,\n *   ],\n * ])\n *\n * console.log(drawTree(tree).join('\\n'))\n * // prints:\n * // ┬1\n * // ├┬2\n * // │├─3\n * // │├─4\n * // │└─5\n * // ├┬6\n * // │├─7\n * // │├─8\n * // │└┬11\n * // │ └─9\n * // └─10\n * ```\n *\n * ts  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "decode: <A>(ta: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeArray",
                      "canonicalReference": "effect-tree!Codec.Arrays.TreeArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/arrays/decode.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "ta",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "decode"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Arrays.decodeUnfold:function(1)",
                  "docComment": "/**\n * Decode a single level of the encoding.  @category unfold  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "decodeUnfold: <A>(a: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeArray",
                      "canonicalReference": "effect-tree!Codec.Arrays.TreeArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeF.TreeF",
                      "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/arrays/decode.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "a",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "decodeUnfold"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Arrays.encode:function(1)",
                  "docComment": "/**\n * Encode a tree as nested arrays.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "encode: <A>(tree: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ValidArrayTree",
                      "canonicalReference": "effect-tree!Codec.Arrays.ValidArrayTree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeArray",
                      "canonicalReference": "effect-tree!Codec.Arrays.TreeArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/arrays/encode.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "tree",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "encode"
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Codec.Arrays.EncodeFolder:type",
                  "docComment": "/**\n * Encode a single level of `Tree<A> ⇒ TreeArray<A>`  @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type EncodeFolder<A> = "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeFolder",
                      "canonicalReference": "effect-tree!TreeFolder:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A, "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeArray",
                      "canonicalReference": "effect-tree!Codec.Arrays.TreeArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/codec/arrays/types.ts",
                  "releaseTag": "Public",
                  "name": "EncodeFolder",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Codec.Arrays.NonArrayType:type",
                  "docComment": "/**\n * You cannot encode a tree of arrays as nested arrays because we use `Array.isArray` to discriminate between leaves and branches.  @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type NonArrayType<A> = "
                    },
                    {
                      "kind": "Content",
                      "text": "A extends unknown[] ? [never, 'Cannot encode a tree of arrays as an array tree'] : A extends readonly unknown[] ? [never, 'Cannot encode a tree of readonly arrays as an array tree'] : A"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/codec/arrays/types.ts",
                  "releaseTag": "Public",
                  "name": "NonArrayType",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Codec.Arrays.TreeArray:type",
                  "docComment": "/**\n * The type of trees encoded as nested arrays. In this encoding a leaf is encoded as a single value:\n * ```ts\n * const leaf: TreeArray<number> = 1 // A tree with a single node\n * ```\n *\n * While a branch node is encoded as a pair of `[A, TreeArray<A>[]]`, with the first element being the root node value and the second element being its child nodes encoded as a `TreeArray`. So if we add two children to our leaf it would encode as:\n * ```ts\n * const branch: TreeArray<number> = [1, [2, 3]] // A tree with a 3 nodes\n * ```\n *\n * Adding children to a leaf in this encoding converts it into a pair of `[values, nodes]`. Here is a larger tree encoded as nested arrays:\n * ```ts\n * // ┬1\n * // ├┬2\n * // │├─3\n * // │└─4\n * // ├┬5\n * // │└─6\n * // └─7\n * const tree = make(1, [\n *   make(2, [of(3), of(4)]),\n *   make(5, [of(6)]),\n *   of(7),\n * ])\n *\n * const encoded = codec.array.encode(tree)\n * // [1, [[2, [3, 4]], [5, [6]], 7]]\n * ```\n *\n * @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type TreeArray<A> = "
                    },
                    {
                      "kind": "Content",
                      "text": "A | [A, "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeArray",
                      "canonicalReference": "effect-tree!Codec.Arrays.TreeArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>[]]"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/codec/arrays/types.ts",
                  "releaseTag": "Public",
                  "name": "TreeArray",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 4
                  }
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Codec.Arrays.TreeArrayLambda:interface",
                  "docComment": "/**\n * @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface TreeArrayLambda extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "HKT.TypeLambda",
                      "canonicalReference": "effect!TypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/codec/arrays/types.ts",
                  "releaseTag": "Public",
                  "name": "TreeArrayLambda",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Codec.Arrays.TreeArrayLambda#type:member",
                      "docComment": "",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "readonly type: "
                        },
                        {
                          "kind": "Reference",
                          "text": "TreeArray",
                          "canonicalReference": "effect-tree!Codec.Arrays.TreeArray:type"
                        },
                        {
                          "kind": "Content",
                          "text": "<this['Target']>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": true,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "type",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      }
                    }
                  ],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 2
                    }
                  ]
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Arrays.unsafeEncodeFold:var",
                  "docComment": "/**\n * Flatten a tree level into an `ArrayTree<A>`.\n *\n * This is unsafe in that any type can be substituted for `A`, yet at runtime, if an array is found in some node value an exception will be thrown, because we use `Array.isArray` to discriminate between leaves and branches.\n *\n * The function is perfectly safe if the type `A` is _not_ an array.  @category fold  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "unsafeEncodeFold: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeFolderK",
                      "canonicalReference": "effect-tree!TreeFolderK:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeArrayLambda",
                      "canonicalReference": "effect-tree!Codec.Arrays.TreeArrayLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/codec/arrays/encode.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "unsafeEncodeFold",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Codec.Arrays.ValidArrayTree:type",
                  "docComment": "/**\n * An array tree with a non-array type.  @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type ValidArrayTree<A> = "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "NonArrayType",
                      "canonicalReference": "effect-tree!Codec.Arrays.NonArrayType:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>> & "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/codec/arrays/types.ts",
                  "releaseTag": "Public",
                  "name": "ValidArrayTree",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 7
                  }
                }
              ]
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Codec.ArraysIsomorphism:function(1)",
              "docComment": "/**\n * Encode/decode losslessly tree ↔ nested arrays.  @category codec  @category instances\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "ArraysIsomorphism: <A>(order: "
                },
                {
                  "kind": "Reference",
                  "text": "Order.Order",
                  "canonicalReference": "effect!Order:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeIsomorphism",
                  "canonicalReference": "effect-tree!Codec.TreeIsomorphism:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, "
                },
                {
                  "kind": "Reference",
                  "text": "Array.NonEmptyArray2",
                  "canonicalReference": "effect-tree!NonEmptyArray2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>>"
                }
              ],
              "fileUrlPath": "src/codec/Isomorphism.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "order",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "ArraysIsomorphism"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Codec.BranchIsomorphism:type",
              "docComment": "/**\n * Encode/decode losslessly tree ↔ edge list.  @category codec  @category instances\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type BranchIsomorphism<A, B> = "
                },
                {
                  "kind": "Reference",
                  "text": "Isomorphism.Isomorphism",
                  "canonicalReference": "effect-ts-laws!Isomorphism:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Branch",
                  "canonicalReference": "effect-tree!Branch:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>, B>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/codec/Isomorphism.ts",
              "releaseTag": "Public",
              "name": "BranchIsomorphism",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "B",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Codec.EdgeListIsomorphism:function(1)",
              "docComment": "/**\n * Encode/decode losslessly tree ↔ edge list.  @category codec  @category instances\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "EdgeListIsomorphism: <A>() => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeIsomorphism",
                  "canonicalReference": "effect-tree!Codec.TreeIsomorphism:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, "
                },
                {
                  "kind": "Reference",
                  "text": "EdgeList",
                  "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>>"
                }
              ],
              "fileUrlPath": "src/codec/Isomorphism.ts",
              "returnTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "EdgeListIsomorphism"
            },
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Codec.Edges:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/codec.ts",
              "releaseTag": "None",
              "name": "Edges",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Codec.Edges.ChildToParent:type",
                  "docComment": "/**\n * @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type ChildToParent<A> = "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMap",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>['toParent']"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/types.ts",
                  "releaseTag": "Public",
                  "name": "ChildToParent",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.decode:function(1)",
                  "docComment": "/**\n * Decode an edge list into a tree.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "decode: <A>(edges: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeList",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/decode.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "edges",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "decode"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.decodeMap:function(1)",
                  "docComment": "/**\n * Decode an edge map into a tree.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "decodeMap: <A>(map: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMap",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/decode.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "map",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "decodeMap"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Edges.decodeUnfold:var",
                  "docComment": "/**\n * Decode a level of a tree encoded as an edge list.  @category codec  @category unfold  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "decodeUnfold: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeUnfolderK",
                      "canonicalReference": "effect-tree!TreeUnfolderK:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMapTypeLambda",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMapTypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/decode.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "decodeUnfold",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type",
                  "docComment": "/**\n * A non-empty list of tree edges from a tree of the given type `A`.  @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type EdgeList<A> = "
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeEdge",
                      "canonicalReference": "effect-tree!Codec.Edges.TreeEdge:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/types.ts",
                  "releaseTag": "Public",
                  "name": "EdgeList",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Codec.Edges.EdgeListTypeLambda:interface",
                  "docComment": "/**\n * @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface EdgeListTypeLambda extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "HKT.TypeLambda",
                      "canonicalReference": "effect!TypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/types.ts",
                  "releaseTag": "Public",
                  "name": "EdgeListTypeLambda",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeListTypeLambda#type:member",
                      "docComment": "",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "readonly type: "
                        },
                        {
                          "kind": "Reference",
                          "text": "EdgeList",
                          "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type"
                        },
                        {
                          "kind": "Content",
                          "text": "<this['Target']>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": true,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "type",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      }
                    }
                  ],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 2
                    }
                  ]
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface",
                  "docComment": "/**\n * An indexed edge list. We index:\n *\n * 1. Child node ⇒ parent node 2. Parent node ⇒ list of child nodes 3. Set of nodes with no parent node  @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface EdgeMap<A> "
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/types.ts",
                  "releaseTag": "Public",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "EdgeMap",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap#roots:member",
                      "docComment": "/**\n * Index of all tree nodes with no parent.\n */\n",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "roots: "
                        },
                        {
                          "kind": "Reference",
                          "text": "HashSet.HashSet",
                          "canonicalReference": "effect!HashSet:interface"
                        },
                        {
                          "kind": "Content",
                          "text": "<A>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "roots",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      }
                    },
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap#toChildren:member",
                      "docComment": "/**\n * Index of all parent tree nodes ⇒ their child tree nodes.\n */\n",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "toChildren: "
                        },
                        {
                          "kind": "Reference",
                          "text": "HashMap.HashMap",
                          "canonicalReference": "effect!HashMap:interface"
                        },
                        {
                          "kind": "Content",
                          "text": "<A, A[]>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "toChildren",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      }
                    },
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap#toParent:member",
                      "docComment": "/**\n * Index of all tree nodes with parent ⇒ their parent.\n */\n",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "toParent: "
                        },
                        {
                          "kind": "Reference",
                          "text": "HashMap.HashMap",
                          "canonicalReference": "effect!HashMap:interface"
                        },
                        {
                          "kind": "Content",
                          "text": "<A, A>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "toParent",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      }
                    }
                  ],
                  "extendsTokenRanges": []
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Codec.Edges.EdgeMapTypeLambda:interface",
                  "docComment": "/**\n * @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface EdgeMapTypeLambda extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "HKT.TypeLambda",
                      "canonicalReference": "effect!TypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/types.ts",
                  "releaseTag": "Public",
                  "name": "EdgeMapTypeLambda",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMapTypeLambda#type:member",
                      "docComment": "",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "readonly type: "
                        },
                        {
                          "kind": "Reference",
                          "text": "EdgeMap",
                          "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                        },
                        {
                          "kind": "Content",
                          "text": "<this['Target']>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": true,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "type",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      }
                    }
                  ],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 2
                    }
                  ]
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.encode:function(1)",
                  "docComment": "/**\n * Encode the given tree as its edge list.\n * ```ts\n * import {Codec, from, of} from 'effect-tree'\n *\n * // •──┬─1\n * //    ├─┬─2\n * //    │ ├───3    Will be encoded as the list of pairs. Each pair encodes\n * //    │ ├───4    a single edge from child to parent. All parents will\n * //    │ └───5    be wrapped in an Option.some(). A single element will\n * //    ├─┬─6      appear in the list where the parent (target of the edge)\n * //    │ ├───7    will be Option.none(). The head element of this pair\n * //    │ ├───8    is the tree root node.\n * //    │ └─┬─11\n * //    │   └───9\n * //    └───10\n * const tree: Tree<number> = from(1,\n *   from(2, of(3), of(4), of(5)),\n *   from(6, of(7), of(8), from(11, of(9))),\n *   of(10),\n * )\n *\n * const edges = Codec.Edges.encode(tree)\n * // edges = [\n * //   [ 1,  none()  ],\n * //   [ 2,  some(1) ],\n * //   [ 3,  some(2) ],\n * //   [ 4,  some(2) ],\n * //   [ 5,  some(2) ],\n * //   [ 6,  some(1) ],\n * //   [ 7,  some(6) ],\n * //   [ 8,  some(6) ],\n * //   [ 11, some(6) ],\n * //   [ 9,  some(11)],\n * //   [ 10, some(1) ],\n * // ]\n * ```\n *\n * ts\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "encode: <A>(tree: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeList",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/encode.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "tree",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "encode"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Edges.encodeFold:var",
                  "docComment": "/**\n * Encode a level of the tree as an edge list.  @category codec  @category fold  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "encodeFold: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeFolderK",
                      "canonicalReference": "effect-tree!TreeFolderK:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeListTypeLambda",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeListTypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/encode.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "encodeFold",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.getEdgeEquivalence:function(1)",
                  "docComment": "/**\n * Given an equivalence of `A`, return an equivalence of `TreeEdge<A>`.  @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getEdgeEquivalence: <A>(equalsA: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Equivalence.Equivalence",
                      "canonicalReference": "effect!Equivalence:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Equivalence.Equivalence",
                      "canonicalReference": "effect!Equivalence:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeEdge",
                      "canonicalReference": "effect-tree!Codec.Edges.TreeEdge:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "equalsA",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getEdgeEquivalence"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.getEdgeListEquivalence:function(1)",
                  "docComment": "/**\n * Given an equivalence of `A`, return an equivalence of `EdgeList<A>`.  @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getEdgeListEquivalence: <A>(equalsA: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Equivalence.Equivalence",
                      "canonicalReference": "effect!Equivalence:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Equivalence.Equivalence",
                      "canonicalReference": "effect!Equivalence:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeList",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "equalsA",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getEdgeListEquivalence"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.getMapChildren:function(1)",
                  "docComment": "/**\n * Assert the edge map has a single root and return a pair of the root and its possibly empty list of children.  @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getMapChildren: <A>({ roots, toChildren, }: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMap",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "[A, A[]]"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 5
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "{ roots, toChildren, }",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getMapChildren"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.index:function(1)",
                  "docComment": "/**\n * Encodes and indexes the edge list of the the given tree.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "index: <A>(self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMap",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/encode.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "self",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "index"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.indexParents:function(1)",
                  "docComment": "/**\n * Build a `EdgeMap` index from a non-empty list of tree edges.  @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "indexParents: <A>(edges: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeList",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMap",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/map.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "edges",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "indexParents"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.numeric:function(1)",
                  "docComment": "/**\n * Convert a numeric edge list into a list of numeric pairs. Root node edge will appear as `[1, 0]`.  @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "numeric: (edges: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeList",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<[number, number]>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "edges",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "numeric"
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Codec.Edges.ParentToChildren:type",
                  "docComment": "/**\n * @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type ParentToChildren<A> = "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMap",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>['toChildren']"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/types.ts",
                  "releaseTag": "Public",
                  "name": "ParentToChildren",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Codec.Edges.RootsMap:type",
                  "docComment": "/**\n * @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type RootsMap<A> = "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMap",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>['roots']"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/types.ts",
                  "releaseTag": "Public",
                  "name": "RootsMap",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.rootTreeEdge:function(1)",
                  "docComment": "/**\n * A tree edge for the root node: parent is `None`.  @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "rootTreeEdge: <A>(child: "
                    },
                    {
                      "kind": "Content",
                      "text": "A"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "[A, "
                    },
                    {
                      "kind": "Reference",
                      "text": "Option.Option",
                      "canonicalReference": "effect!Option:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>]"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "child",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "rootTreeEdge"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.setMapRoot:function(1)",
                  "docComment": "/**\n * Sets the roots of the edge map to a single root.  @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "setMapRoot: <A>(map: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMap",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "(root: A) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeMap",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeMap:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 7
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "map",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "setMapRoot"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.setParent:function(1)",
                  "docComment": "/**\n * Set a parent on a non-root tree edge.  @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "setParent: <A>(a: "
                    },
                    {
                      "kind": "Content",
                      "text": "A"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "(edge: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeEdge",
                      "canonicalReference": "effect-tree!Codec.Edges.TreeEdge:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeEdge",
                      "canonicalReference": "effect-tree!Codec.Edges.TreeEdge:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "a",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "setParent"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Edges.sortEdgeList:function(1)",
                  "docComment": "/**\n * Sort the edge list by the given order.  @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "sortEdgeList: <A>(o: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Order.Order",
                      "canonicalReference": "effect!Order:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "(edges: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeList",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>) => typeof "
                    },
                    {
                      "kind": "Reference",
                      "text": "edges",
                      "canonicalReference": "effect-tree!~edges:var"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "o",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "sortEdgeList"
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Codec.Edges.TreeEdge:type",
                  "docComment": "/**\n * A tree edge is a pair of child and optional parent.  @category codec\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type TreeEdge<A> = "
                    },
                    {
                      "kind": "Content",
                      "text": "[child: A, parent: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Option.Option",
                      "canonicalReference": "effect!Option:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>]"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/types.ts",
                  "releaseTag": "Public",
                  "name": "TreeEdge",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 4
                  }
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Codec.Edges.TreeEdgeTypeLambda:interface",
                  "docComment": "/**\n * `TreeEdge<?₁> = [?₁, Option<?₁>]`\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface TreeEdgeTypeLambda extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "HKT.TypeLambda",
                      "canonicalReference": "effect!TypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/codec/edges/types.ts",
                  "releaseTag": "Public",
                  "name": "TreeEdgeTypeLambda",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Codec.Edges.TreeEdgeTypeLambda#type:member",
                      "docComment": "",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "readonly type: "
                        },
                        {
                          "kind": "Reference",
                          "text": "TreeEdge",
                          "canonicalReference": "effect-tree!Codec.Edges.TreeEdge:type"
                        },
                        {
                          "kind": "Content",
                          "text": "<this['Target']>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": true,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "type",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      }
                    }
                  ],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 2
                    }
                  ]
                }
              ]
            },
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Codec.Indented:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/codec.ts",
              "releaseTag": "None",
              "name": "Indented",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Indented.decode:function(1)",
                  "docComment": "/**\n * Decode a list of indented lines into a string tree.\n *\n * @param lines - non-empty array of non-empty strings, each encoding a tree node with indent set as a multiple of node depth.\n *\n * @returns A decoded string tree.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "decode: (lines: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Array.NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<string>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<string>"
                    }
                  ],
                  "fileUrlPath": "src/codec/indented/index.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "lines",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "decode"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Indented.decodeIndentedUnfold:function(1)",
                  "docComment": "/**\n * Decode a single level of a tree from a list of indented lines where indentation represents node depth.  @category codec  @category unfold  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "decodeIndentedUnfold: ([[value, depth], second, ...tail]: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Array.NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<[string, number]>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeF.TreeF",
                      "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<string, "
                    },
                    {
                      "kind": "Reference",
                      "text": "Array.NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<[string, number]>>"
                    }
                  ],
                  "fileUrlPath": "src/codec/indented/index.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "[[value, depth], second, ...tail]",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "decodeIndentedUnfold"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Indented.encode:var",
                  "docComment": "/**\n * Encode a string tree into a `YAML`-like indented format where indentation, be default set at `2` spaces, indicates node depth.\n *\n * You will find a curried version under the key `curried`.\n *\n * @param self - The tree to be encoded.\n *\n * @param indent - Optional number of space characters that separate adjacent tree levels. Default is `2`.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "encode: "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    (self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<string>, indent?: number): "
                    },
                    {
                      "kind": "Reference",
                      "text": "Array.NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<string>;\n    curried: (indent?: number) => (self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<string>) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Array.NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<string>;\n}"
                    }
                  ],
                  "fileUrlPath": "src/codec/indented/index.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "encode",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 10
                  }
                }
              ]
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Codec.IndentedIsomorphism:function(1)",
              "docComment": "/**\n * Encode/decode losslessly a string tree ↔ indented tree.  @category codec  @category instances\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "IndentedIsomorphism: (indent: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeIsomorphism",
                  "canonicalReference": "effect-tree!Codec.TreeIsomorphism:type"
                },
                {
                  "kind": "Content",
                  "text": "<string, "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>>"
                }
              ],
              "fileUrlPath": "src/codec/Isomorphism.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "indent",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "IndentedIsomorphism"
            },
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Codec.Paths:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/codec.ts",
              "releaseTag": "None",
              "name": "Paths",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Paths.decode:function(1)",
                  "docComment": "/**\n * Decode a list of leaf paths into a tree where. Every leaf given will appear in the tree at the given path.\n *\n * An [Order](https://effect.website/docs/behaviour/order/) for your type is required as the first argument.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "decode: <A>(order: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Order.Order",
                      "canonicalReference": "effect!Order:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "(pathList: "
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray2",
                      "canonicalReference": "effect-tree!NonEmptyArray2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/paths/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 9
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "order",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "decode"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Paths.encode:function(1)",
                  "docComment": "/**\n * Encode a tree of type `A` into a non-empty list of paths to every leaf in the encoded tree.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "encode: <A>(tree: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray2",
                      "canonicalReference": "effect-tree!NonEmptyArray2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/codec/paths/ops.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "tree",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "encode"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Paths.isValidPathList:function(1)",
                  "docComment": "/**\n * Check that a path list is valid:\n *\n * 1. Every leaf, I.e.: a node that appears last in its path, is mentioned in only one path. 2. All paths share the same root 3. For any pair of appearances of any node the parent node is equal.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "isValidPathList: <A>(equals: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Equivalence.Equivalence",
                      "canonicalReference": "effect!Equivalence:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Predicate.Predicate",
                      "canonicalReference": "effect!Predicate:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray2",
                      "canonicalReference": "effect-tree!NonEmptyArray2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/codec/paths/guard.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "equals",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "isValidPathList"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Paths.pathListFold:var",
                  "docComment": "/**\n * Collect all leaf paths from a tree at a level. For example:\n * ```ts\n * const tree = make('A', [of('B'), make('C', [of('D', 'E')])])\n *\n * const paths = treeCata(pathFolder)(tree)\n * // [['A', 'B'], ['A', 'C', 'D'], ['A', 'C', 'E']]\n *\n * ```\n *\n * @category fold  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "pathListFold: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeFolderK",
                      "canonicalReference": "effect-tree!TreeFolderK:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray2TypeLambda",
                      "canonicalReference": "effect-tree!NonEmptyArray2TypeLambda:type"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/codec/paths/fold.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "pathListFold",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Paths.pathListUnfold:function(1)",
                  "docComment": "/**\n * Build a tree from a list of paths and an order. For example:\n * ```ts\n * const paths = [['A', 'B'], ['A', 'C', 'D'], ['A', 'C', 'E']]\n *\n * const tree = treeAna(pathListUnfold(STR.Order))(paths)\n * // A(B, C(D, E))\n * ```\n *\n * @category unfold  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "pathListUnfold: <A>(order: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Order.Order",
                      "canonicalReference": "effect!Order:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeUnfolder",
                      "canonicalReference": "effect-tree!TreeUnfolder:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A, "
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray2",
                      "canonicalReference": "effect-tree!NonEmptyArray2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/codec/paths/unfold.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "order",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "pathListUnfold"
                }
              ]
            },
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Codec.Prufer:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/codec.ts",
              "releaseTag": "None",
              "name": "Prufer",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.allCodesAt:function(1)",
                  "docComment": "/**\n * A list of all codes for the given node count.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "allCodesAt: (nodeCount: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number[]>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/enumerate.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 5
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "nodeCount",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "allCodesAt"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.allTreesAt:function(1)",
                  "docComment": "/**\n * A list of all possible trees for the given node count.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "allTreesAt: (nodeCount: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>[]"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/enumerate.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 5
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "nodeCount",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "allTreesAt"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.codeCount:function(1)",
                  "docComment": "/**\n * What is element count of the prüfer code for the given node count?\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "codeCount: (nodeCount: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/enumerate.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "nodeCount",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "codeCount"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.computeNodeCount:function(1)",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "computeNodeCount: (code: "
                    },
                    {
                      "kind": "Content",
                      "text": "number[]"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/enumerate.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "code",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "computeNodeCount"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.decode:function(1)",
                  "docComment": "/**\n * Convert the prüfer code of a tree into the tree.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "decode: (code: "
                    },
                    {
                      "kind": "Content",
                      "text": "number[]"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/decoder.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 5
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "code",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "decode"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.encode:function(1)",
                  "docComment": "/**\n * Convert a tree with an order to its prüfer code.\n *\n * Tree requirements:\n *\n * 1. It is a branch and not a leaf. I.E: at least _two_ nodes. 2. Root node value is minimum of all tree values. For example a tree of naturals should have the number `1` as its root node.\n *\n * We call `filterMinLeaf` and get back:\n *\n * 1. Our tree with its minimal leaf removed 2. The parent of this removed leaf, or `none` if root\n *\n * If the node has a parent, we add it to the left of the accumulated prüfer code array and recurse again on the now smaller tree.\n *\n * When a node has no parent, we stop the recursion.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "encode: <A>(order: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Order.Order",
                      "canonicalReference": "effect!Order:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "((self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>) => A[])"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/encoder.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 7
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "order",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "encode"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.fromOrdinal:function(1)",
                  "docComment": "/**\n * returns the prüfer sequence for the `nₜₕ` labeled tree with a node count of `nodeCount`. Note the `n` is an ordinal that starts at `1`.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "fromOrdinal: (n: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ", nodeCount: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "number[]"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/enumerate.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "n",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "nodeCount",
                      "parameterTypeTokenRange": {
                        "startIndex": 3,
                        "endIndex": 4
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "fromOrdinal"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.getFirstCodeFor:function(1)",
                  "docComment": "/**\n * What is the 1st prüfer code for the given node count?  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getFirstCodeFor: (nodeCount: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "number[]"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "nodeCount",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "getFirstCodeFor"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.getLastCodeFor:function(1)",
                  "docComment": "/**\n * What is the last prüfer code for the given node count?  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getLastCodeFor: (n: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "number[]"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "n",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "getLastCodeFor"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.getNthTree:function(1)",
                  "docComment": "/**\n * Get the `nₜₕ` labeled numeric tree for the given node count.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getNthTree: (ordinal: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ", nodeCount: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/enumerate.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 7
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "ordinal",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "nodeCount",
                      "parameterTypeTokenRange": {
                        "startIndex": 3,
                        "endIndex": 4
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "getNthTree"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.isFirstCode:var",
                  "docComment": "/**\n * Is this the first prüfer code for its node count?  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "isFirstCode: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Predicate.Predicate",
                      "canonicalReference": "effect!Predicate:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<number[]>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "isFirstCode",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.isLastCode:var",
                  "docComment": "/**\n * Is this the final prüfer code for its node count?  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "isLastCode: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Predicate.Predicate",
                      "canonicalReference": "effect!Predicate:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<number[]>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "isLastCode",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.labeledTreeCount:function(1)",
                  "docComment": "/**\n * How many labeled trees of `n` nodes are there?\n *\n * https://en.wikipedia.org/wiki/Cayley%27s_formula  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "labeledTreeCount: (n: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/enumerate.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "n",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "labeledTreeCount"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.nextCode:var",
                  "docComment": "/**\n * Get the _next_ prüfer code for the given code. If the given code is the final code for its node count, the first code of the _next_ node count is returned.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "nextCode: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<number[]>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "nextCode",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.nextCodeWrap:var",
                  "docComment": "/**\n * Compute the next Prüfer code from the given code with wrap-around.\n *\n * For example, the next code of `1,4` will be `2,1` and the next code of `4,4` will be `1,1`.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "nextCodeWrap: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<number[]>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "nextCodeWrap",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.nextTree:var",
                  "docComment": "/**\n * Get the _next_ numeric tree in the ordered set of numeric trees with the same node count as the given tree. If the tree is the last in its ordered set, we increment node count and return the first tree in this ordered set.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "nextTree: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "nextTree",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.nextTreeWrap:var",
                  "docComment": "/**\n * Just like `nextTree` but when last tree is reached we wrap around to the first tree with the same node count.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "nextTreeWrap: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "nextTreeWrap",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.previousCode:var",
                  "docComment": "/**\n * Get the _previous_ prüfer code for the given code. If the given code is the first code for its node count, the last code of the _previous_ node count is returned. When node count reaches 2, I.e.: code count is 0, we stop and return the input unchanged.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "previousCode: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<number[]>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "previousCode",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.previousCodeWrap:var",
                  "docComment": "/**\n * Compute the previous Prüfer code from the given code with wrap-around.\n *\n * For example, the previous code of `1,1,1` (first code for 5 nodes) will be `4,4` (last code for 4 nodes), and the previous code of `4,4` will be `4,3`.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "previousCodeWrap: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<number[]>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "previousCodeWrap",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.previousTree:var",
                  "docComment": "/**\n * Get the _previous_ numeric tree in the ordered set of numeric trees with the same node count as the given tree. If the tree is the 1st in its ordered set, we decrement node count and return the last tree in this ordered set. The process stops when node count reaches 3, after which the given tree is returned unchanged.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "previousTree: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "previousTree",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Codec.Prufer.previousTreeWrap:var",
                  "docComment": "/**\n * Just like `previousTree` but when first tree is reached we wrap around to the last tree with the same node count.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "previousTreeWrap: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/step.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "previousTreeWrap",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.toEdges:function(1)",
                  "docComment": "/**\n * Convert the prüfer code of a tree into a list of directed edges in `O(n×log₂n)` compute time where `n` is node count.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "toEdges: (code: "
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "EdgeList",
                      "canonicalReference": "effect-tree!Codec.Edges.EdgeList:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/decoder.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "code",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "toEdges"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.toOrdinal:function(1)",
                  "docComment": "/**\n * Get the node count and index of the given prüfer code. This is the opposite of `ordinalToPrüfer` in that composing one of each in any order is identity. Returns a pair of node count and ordinal, where the ordinal is always smaller than the node count.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "toOrdinal: (code: "
                    },
                    {
                      "kind": "Content",
                      "text": "number[]"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "[ordinal: number, nodeCount: number]"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/enumerate.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "code",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "toOrdinal"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Codec.Prufer.treeToOrdinal:function(1)",
                  "docComment": "/**\n * In the ordered set of trees with N labeled nodes, a set where the given tree is very much a member of, what is the ordinal number of the given tree in the set? Returns a numeric pair of ordinal and node tree count.  @category codec  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "treeToOrdinal: (self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Branch",
                      "canonicalReference": "effect-tree!Branch:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "[ordinal: number, nodeCount: number]"
                    }
                  ],
                  "fileUrlPath": "src/codec/prufer/enumerate.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 5
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "self",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "treeToOrdinal"
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Codec.PruferIsomorphism:var",
              "docComment": "/**\n * Encode/decode losslessly a numeric tree ↔ prüfer code.  @category codec  @category instances\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "PruferIsomorphism: "
                },
                {
                  "kind": "Reference",
                  "text": "BranchIsomorphism",
                  "canonicalReference": "effect-tree!Codec.BranchIsomorphism:type"
                },
                {
                  "kind": "Content",
                  "text": "<number, number[]>"
                }
              ],
              "fileUrlPath": "src/codec/Isomorphism.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "PruferIsomorphism",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Codec.TreeIsomorphism:type",
              "docComment": "/**\n * An isomorphism between a tree of underlying type `A` and the type `B`.  @category codec  @category instances\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type TreeIsomorphism<A, B> = "
                },
                {
                  "kind": "Reference",
                  "text": "Isomorphism.Isomorphism",
                  "canonicalReference": "effect-ts-laws!Isomorphism:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>, B>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/codec/Isomorphism.ts",
              "releaseTag": "Public",
              "name": "TreeIsomorphism",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "B",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            }
          ]
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!computeRunningAverage:function(1)",
          "docComment": "/**\n * Collapse the sum and count of a running average into the average value.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "computeRunningAverage: ({ numerator, denominator, }: "
            },
            {
              "kind": "Reference",
              "text": "RunningAverage",
              "canonicalReference": "effect-tree!RunningAverage:interface"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "number"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 4
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "{ numerator, denominator, }",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "computeRunningAverage"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!countOf:function(1)",
          "docComment": "/**\n * Compute how many nodes in a tree satisfy the given `predicate`.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "countOf: <A>(predicate: "
            },
            {
              "kind": "Reference",
              "text": "Predicate.Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFold",
              "canonicalReference": "effect-tree!TreeFold:type"
            },
            {
              "kind": "Content",
              "text": "<A, number>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "predicate",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "countOf"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!countOfFold:function(1)",
          "docComment": "/**\n * Count tree nodes of a tree level that satisfy the given predicate.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "countOfFold: <A>(predicate: "
            },
            {
              "kind": "Reference",
              "text": "Predicate.Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, number>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "predicate",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "countOfFold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!Covariant:var",
          "docComment": "/**\n * Covariant instance for {@link Tree}.  @category instances\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "Covariant: "
            },
            {
              "kind": "Reference",
              "text": "CO.Covariant",
              "canonicalReference": "@effect/typeclass!Covariant:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/instances/Covariant.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "Covariant",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!cropDepth:function(1)",
          "docComment": "/**\n * Crop all nodes from a tree that are deeper than the given depth. For example:\n * ```ts\n * import {leaf, branch, cropDepth} from 'effect-tree'\n *\n * //  ┬1        A tree of depth=4\n * //  └┬2       with 3 branches and\n * //   └┬3      a single leaf.\n * //    └─4\n * //\n * const depth4: Tree<string> = branch(1, [branch(2, [branch(3, [leaf(4)])])]])\n *\n * const depth2: Tree<string> = pipe(depth4, cropDepth(2))\n * //\n * //  ┬1        Has been cropped to a tree of depth=2\n * //  └─2       depth2 = branch(1, [leaf(2)])\n * ```\n *\n * @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "cropDepth: (depth: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "<A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "depth",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "cropDepth"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!cropDepthUnfold:function(1)",
          "docComment": "/**\n * Crop all nodes from a tree that are below the given depth, for a single level of the tree.  @category unfold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "cropDepthUnfold: <A>([depth, self]: "
            },
            {
              "kind": "Content",
              "text": "readonly [number, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>]"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, readonly [number, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>]>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "[depth, self]",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "cropDepthUnfold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!degreeFold:var",
          "docComment": "/**\n * Measure node degree at a tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "degreeFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolderOf",
              "canonicalReference": "effect-tree!TreeFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "degreeFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!descendantCountFold:var",
          "docComment": "/**\n * Count total node count at level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "descendantCountFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolderOf",
              "canonicalReference": "effect-tree!TreeFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "descendantCountFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!destruct:function(1)",
          "docComment": "/**\n * Deconstruct the node and possibly empty forest of a tree. Useful in pipelines.\n *\n * @param self - The tree being deconstructed.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns A pair of the tree node value and a possibly empty list of child trees.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "destruct: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "readonly [A, readonly "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]]"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "destruct"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!destructBranch:function(1)",
          "docComment": "/**\n * Same as {@link destruct} but only for _branches_, so you are guaranteed a non-empty forest.\n *\n * @param self - The branch being deconstructed.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns A pair of the tree node value and a non-empty list of child trees.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "destructBranch: <A>({ "
            },
            {
              "kind": "Reference",
              "text": "unfixed",
              "canonicalReference": "!unfixed"
            },
            {
              "kind": "Content",
              "text": ": { node, forest }, }: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "[A, "
            },
            {
              "kind": "Reference",
              "text": "Array.NonEmptyReadonlyArray",
              "canonicalReference": "effect!NonEmptyReadonlyArray:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>]"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "{ unfixed: { node, forest }, }",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "destructBranch"
        },
        {
          "kind": "Namespace",
          "canonicalReference": "effect-tree!Draw:namespace",
          "docComment": "",
          "excerptTokens": [],
          "fileUrlPath": "index.ts",
          "releaseTag": "None",
          "name": "Draw",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.above:var",
              "docComment": "/**\n * Add the `below` part below the `above` part. See {@link below} for a flipped version.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "above: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (hAlign?: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "ColumnOp",
                  "canonicalReference": "effect-tree!Draw.ColumnOp:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n} & "
                },
                {
                  "kind": "Reference",
                  "text": "ColumnOps",
                  "canonicalReference": "effect-tree!Draw.ColumnOps:type"
                }
              ],
              "fileUrlPath": "src/draw/part/column.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "above",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.addBorder:var",
              "docComment": "/**\n * Add a border around the given shape. The line and elbow glyphs are taken from the given set.\n *\n * At the key `curried` you will find a curried version that takes the border set as its first argument.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "addBorder: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ", set: "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    curried: (set: "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "addBorder",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.addBorders:var",
              "docComment": "/**\n * Add a non-empty list of borders iteratively, wrapping each border _around_ the previous one so that the end result is a nesting of borders with the 1st border being the innermost border and the last the outermost.\n *\n * At the `rest` key you will find version that accepts the borders as arguments.\n *\n * @param sets - A non-empty list of border sets that will be nested around the given part.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "addBorders: "
                },
                {
                  "kind": "Content",
                  "text": "(([head, ...tail]: "
                },
                {
                  "kind": "Reference",
                  "text": "Array.NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ">) => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">) & {\n    rest: (sets_0: "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ", ...sets: "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": "[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "addBorders",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 18
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.addPadHeight:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "addPadHeight: ({ "
                },
                {
                  "kind": "Reference",
                  "text": "pad",
                  "canonicalReference": "effect-tree!Draw.Padded#pad"
                },
                {
                  "kind": "Content",
                  "text": ": { top, bottom } }: "
                },
                {
                  "kind": "Reference",
                  "text": "Padded",
                  "canonicalReference": "effect-tree!Draw.Padded:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(height: number) => number"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ pad: { top, bottom } }",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "name": "addPadHeight"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.addPadSize:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "addPadSize: (padded: "
                },
                {
                  "kind": "Reference",
                  "text": "Padded",
                  "canonicalReference": "effect-tree!Draw.Padded:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(width: number, height: number) => [width: number, height: number]"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "padded",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "addPadSize"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.addPadWidth:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "addPadWidth: ({ "
                },
                {
                  "kind": "Reference",
                  "text": "pad",
                  "canonicalReference": "effect-tree!Draw.Padded#pad"
                },
                {
                  "kind": "Content",
                  "text": ": { left, right } }: "
                },
                {
                  "kind": "Reference",
                  "text": "Padded",
                  "canonicalReference": "effect-tree!Draw.Padded:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(width: number) => number"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ pad: { left, right } }",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "name": "addPadWidth"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.addSpacingAfter:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export declare function addSpacingAfter(label: "
                },
                {
                  "kind": "Content",
                  "text": "string"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Content",
                  "text": "(theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Array.NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "label",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "addSpacingAfter"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.after:var",
              "docComment": "/**\n * Add the prefix part to the left of the suffix part. A flipped version of {@link before}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "after: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (vAlign?: "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": "): (hAlign?: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "BuildPart",
                  "canonicalReference": "effect-tree!Draw.BuildPart:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n} & "
                },
                {
                  "kind": "Reference",
                  "text": "BuildAlignedPart",
                  "canonicalReference": "effect-tree!Draw.BuildAlignedPart:type"
                }
              ],
              "fileUrlPath": "src/draw/part/row.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "after",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 9
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.Aligned:interface",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface Aligned extends "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontallyAligned",
                  "canonicalReference": "effect-tree!Draw.HorizontallyAligned:interface"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "VerticallyAligned",
                  "canonicalReference": "effect-tree!Draw.VerticallyAligned:interface"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "releaseTag": "Public",
              "name": "Aligned",
              "preserveMemberOrder": false,
              "members": [],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 2
                },
                {
                  "startIndex": 3,
                  "endIndex": 4
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.AlignedEquivalence:var",
              "docComment": "/**\n * Equivalence for {@link Aligned}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "AlignedEquivalence: "
                },
                {
                  "kind": "Reference",
                  "text": "EQ.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Aligned",
                  "canonicalReference": "effect-tree!Draw.Aligned:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "AlignedEquivalence",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.alignHorizontally:function(1)",
              "docComment": "/**\n * Align an array of single line strings according to the given alignment. All strings in the returned array will be as wide as the widest among them.\n *\n * The given horizontal struts will be used to fill the available space created by aligning the given parts.\n *\n * @param hStruts - Left and right horizontal struts will be used to fill available space.\n *\n * @param hAlign - A horizontal alignment will be used when not all shapes are of the same width.\n *\n * @param useLeftRound - Optional flag determining if remainder is added to the left or to the right the shape. By default it is `false` and the remainder is added to the _right_ of the shape.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "alignHorizontally: (hStruts: "
                },
                {
                  "kind": "Reference",
                  "text": "HStruts",
                  "canonicalReference": "effect-tree!Draw.HStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ", hAlign: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", useLeftRound?: "
                },
                {
                  "kind": "Content",
                  "text": "boolean"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string[]>"
                }
              ],
              "fileUrlPath": "src/draw/align/horizontally.ts",
              "returnTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 9
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "hStruts",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "hAlign",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "useLeftRound",
                  "parameterTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 6
                  },
                  "isOptional": true
                }
              ],
              "name": "alignHorizontally"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Alignment:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Alignment = "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": " | "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "releaseTag": "Public",
              "name": "Alignment",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.alignVertically:var",
              "docComment": "/**\n * Vertically and horizontally align an array of arrays of single line strings according to the given alignments.\n *\n * All columns in the returned array will be as tall as the tallest among them. The given vertical struts will be used to fill the available vertical space: the top and the bottom struts filling each direction respectively.\n *\n * The struts will add zero or one strings, from their `prefix`/`body`/`suffix` fields to each line they create for the purpose of alignment. The rest of the line will remain empty, to be filled by the horizontal alignment given in `alignOrthogonal`.\n *\n * For each column we run the given `alignOrthogonal` function, where you can set horizontal alignment and padding to make sure every row, per column is of the same width.\n *\n * If the vertical alignment is `center`, you can configure the handling of the remainder using the optional `useTopRound` argument, by default `false`.\n *\n * Remainders pop up when the height of the available space left for padding around the aligned item is _odd_. By default we add the remainder to the _bottom_ of what we are aligning, so that it will appear _above_ where it should be.\n *\n * For example, when aligning a single row part with a a taller part that renders to an _even_ number of rows, we need to decide if we add the remaining space, which is an _odd_ number, above or below what is being aligned.\n *\n * The default rounding it to the _bottom_, meaning the remainder is added to the bottom pushing the aligned text up so it will appear _above_ the center:\n * ```ts\n * Default useTopRound=false   1 ┌─────────┐\n * remainder ┌───────────────┐-2 │Tall part│\n * is added  │single row part│ 3 │with an  │\n * to shape  └───────────────┘-4 │even     │\n * bottom                      5 │height   │\n *                             6 └─────────┘\n * ```\n *\n * If you set `useTopRound` to true, or call the variant of this function `alignVertically.useTopRound`, the remainder will be added _above_ the shape pushing the shape down so it appears _below_ the center:\n * ```ts\n * When useTopRound=true       1 ┌─────────┐\n * remainder is added          2 │Tall part│\n * to shape  ┌───────────────┐-3 │with an  │\n * top       │single row part│ 4 │even     │\n *           └───────────────┘-5 │height   │\n *                             6 └─────────┘\n * ```\n *\n * @param vStruts - Top and bottom vertical struts will be used to fill available space.\n *\n * @param vAlign - A vertical alignment will be used when not all shapes are of the same height.\n *\n * @param alignOrthogonal - A function that accepts a list of strings at different widths and returns them at the width of the widest, respecting alignments and struts.\n *\n * @param useTopRound - Optional flag determining if remainder is added above or below the shape. By default it is `false` and the remainder is added below the shape.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "alignVertically: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (vStruts: "
                },
                {
                  "kind": "Reference",
                  "text": "VStruts",
                  "canonicalReference": "effect-tree!Draw.VStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ", vAlign: "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", alignOrthogonal: "
                },
                {
                  "kind": "Reference",
                  "text": "Function.EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string[]>, useTopRound?: boolean): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Array.NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string[]>>;\n    useTopRound(vStruts: "
                },
                {
                  "kind": "Reference",
                  "text": "VStruts",
                  "canonicalReference": "effect-tree!Draw.VStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ", vAlign: "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", alignOrthogonal: "
                },
                {
                  "kind": "Reference",
                  "text": "Function.EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string[]>): "
                },
                {
                  "kind": "Reference",
                  "text": "Function.EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<[string[], ...string[][]]>;\n}"
                }
              ],
              "fileUrlPath": "src/draw/align/vertically.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "alignVertically",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 20
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Axis:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Axis = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "axis",
                  "canonicalReference": "effect-tree!Draw.axis:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "releaseTag": "Public",
              "name": "Axis",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.axis:var",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "axis: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"horizontal\", \"vertical\"]"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "axis",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.AxisDirected:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type AxisDirected<H, V> = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalDirection",
                  "canonicalReference": "effect-tree!Draw.HorizontalDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", H> & "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "VerticalDirection",
                  "canonicalReference": "effect-tree!Draw.VerticalDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", V>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "releaseTag": "Public",
              "name": "AxisDirected",
              "typeParameters": [
                {
                  "typeParameterName": "H",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "V",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 9
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.axisDirections:var",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "axisDirections: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    readonly horizontal: readonly [\"left\", \"right\"];\n    readonly vertical: readonly [\"top\", \"bottom\"];\n}"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "axisDirections",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.AxisString:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type AxisString<A extends "
                },
                {
                  "kind": "Reference",
                  "text": "Axis",
                  "canonicalReference": "effect-tree!Draw.Axis:type"
                },
                {
                  "kind": "Content",
                  "text": "> = "
                },
                {
                  "kind": "Content",
                  "text": "A extends 'horizontal' ? string : string[]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "releaseTag": "Public",
              "name": "AxisString",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.BaseDraw:interface",
              "docComment": "/**\n * Type of the base draw function: draw a tree into some output format.\n *\n * A function of the type:\n * ```ts\n * { (self: Tree<A>): Out }\n * ```\n *\n * @typeParam A - Underlying type of the tree being printed.\n *\n * @typeParam Out - Output type of drawing function. Usually multiline string or * array of string lines for terminal output.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface BaseDraw<A, Out> "
                }
              ],
              "fileUrlPath": "src/draw/tree/draw.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "Out",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "BaseDraw",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "CallSignature",
                  "canonicalReference": "effect-tree!Draw.BaseDraw:call(1)",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "(self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": "): "
                    },
                    {
                      "kind": "Content",
                      "text": "Out"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 5
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "self",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ]
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.BaseStrut:interface",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface BaseStrut<A extends "
                },
                {
                  "kind": "Reference",
                  "text": "Axis",
                  "canonicalReference": "effect-tree!Draw.Axis:type"
                },
                {
                  "kind": "Content",
                  "text": "> "
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "BaseStrut",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.BaseStrut#axis:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "axis: "
                    },
                    {
                      "kind": "Content",
                      "text": "A"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "axis",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.BaseStrut#body:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "body: "
                    },
                    {
                      "kind": "Reference",
                      "text": "NonEmptyArray",
                      "canonicalReference": "effect!NonEmptyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<string>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "body",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.BaseStrut#prefix:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "prefix: "
                    },
                    {
                      "kind": "Reference",
                      "text": "AxisString",
                      "canonicalReference": "effect-tree!Draw.AxisString:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "prefix",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.BaseStrut#suffix:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "suffix: "
                    },
                    {
                      "kind": "Reference",
                      "text": "AxisString",
                      "canonicalReference": "effect-tree!Draw.AxisString:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "suffix",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.before:var",
              "docComment": "/**\n * Add the prefix part to the left of the suffix part. See {@link after} for a flipped version.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "before: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (vAlign?: "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": "): (hAlign?: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "BuildPart",
                  "canonicalReference": "effect-tree!Draw.BuildPart:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n} & "
                },
                {
                  "kind": "Reference",
                  "text": "BuildAlignedPart",
                  "canonicalReference": "effect-tree!Draw.BuildAlignedPart:type"
                }
              ],
              "fileUrlPath": "src/draw/part/row.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "before",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 9
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.below:var",
              "docComment": "/**\n * Add the `below` part below the `above` part. See {@link above} for a flipped version.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "below: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (hAlign?: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "ColumnOp",
                  "canonicalReference": "effect-tree!Draw.ColumnOp:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n} & "
                },
                {
                  "kind": "Reference",
                  "text": "ColumnOps",
                  "canonicalReference": "effect-tree!Draw.ColumnOps:type"
                }
              ],
              "fileUrlPath": "src/draw/part/column.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "below",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.borderBottom:var",
              "docComment": "/**\n * Add a border to the top of the given shape with no corners. The glyph is taken from the given {@link BorderSet}.\n *\n * At the key `corners` you will find a version that has the same signature but _does_ add the required bottom left and bottom right corners.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "borderBottom: "
                },
                {
                  "kind": "Reference",
                  "text": "Bordered",
                  "canonicalReference": "effect-tree!Draw.Bordered:interface"
                },
                {
                  "kind": "Content",
                  "text": " & {\n    corners: "
                },
                {
                  "kind": "Reference",
                  "text": "Bordered",
                  "canonicalReference": "effect-tree!Draw.Bordered:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "borderBottom",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.Bordered:interface",
              "docComment": "/**\n * Type of functions that modify a part with the help of some {@link BorderSet}.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface Bordered "
                }
              ],
              "fileUrlPath": "src/draw/parts/borders.ts",
              "releaseTag": "Public",
              "name": "Bordered",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "CallSignature",
                  "canonicalReference": "effect-tree!Draw.Bordered:call(1)",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "(set: "
                    },
                    {
                      "kind": "Reference",
                      "text": "BorderSet",
                      "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "): "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Part",
                      "canonicalReference": "effect-tree!Draw.Part_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 7
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "set",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ]
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.borderLeft:var",
              "docComment": "/**\n * Add a border to the left of the given shape with no corners. The glyph is taken from the given {@link BorderSet}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "borderLeft: "
                },
                {
                  "kind": "Reference",
                  "text": "Bordered",
                  "canonicalReference": "effect-tree!Draw.Bordered:interface"
                }
              ],
              "fileUrlPath": "src/draw/parts/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "borderLeft",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.borderRight:var",
              "docComment": "/**\n * Add a border to the right of the given shape with no corners. The glyph is taken from the given {@link BorderSet}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "borderRight: "
                },
                {
                  "kind": "Reference",
                  "text": "Bordered",
                  "canonicalReference": "effect-tree!Draw.Bordered:interface"
                }
              ],
              "fileUrlPath": "src/draw/parts/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "borderRight",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.borderSet:function(1)",
              "docComment": "/**\n * Get a line set by name.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "borderSet: (name: "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSetName",
                  "canonicalReference": "effect-tree!Draw.BorderSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                }
              ],
              "fileUrlPath": "src/draw/glyph/borders.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "name",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "borderSet"
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.BorderSet:interface",
              "docComment": "/**\n * A line set and corner set that can form a box border.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface BorderSet "
                }
              ],
              "fileUrlPath": "src/draw/glyph/types.ts",
              "releaseTag": "Public",
              "name": "BorderSet",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.BorderSet#elbows:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "elbows: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ElbowSet",
                      "canonicalReference": "effect-tree!Draw.ElbowSet:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "elbows",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.BorderSet#lines:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "lines: "
                    },
                    {
                      "kind": "Reference",
                      "text": "LineSet",
                      "canonicalReference": "effect-tree!Draw.LineSet:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "lines",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.BorderSetName:type",
              "docComment": "/**\n * The type of a border set name.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type BorderSetName = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "borderSetNames",
                  "canonicalReference": "effect-tree!Draw.borderSetNames:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/borders.ts",
              "releaseTag": "Public",
              "name": "BorderSetName",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.borderSetNames:var",
              "docComment": "/**\n * Names of all border sets.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "borderSetNames: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"ascii\", \"beveled\", \"dashed\", \"dashedWide\", \"dotted\", \"double\", \"halfSolid\", \"halfSolidFar\", \"halfSolidNear\", \"hDouble\", \"hThick\", \"near\", \"solid\", \"space\", \"thick\", \"thickDashed\", \"thickDashedWide\", \"thickDotted\", \"thin\", \"vDouble\", \"vThick\"]"
                }
              ],
              "fileUrlPath": "src/draw/glyph/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "borderSetNames",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.BorderSets:type",
              "docComment": "/**\n * A record of all border sets.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type BorderSets = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "BorderSetName",
                  "canonicalReference": "effect-tree!Draw.BorderSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/borders.ts",
              "releaseTag": "Public",
              "name": "BorderSets",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.borderTop:var",
              "docComment": "/**\n * Add a border to the top of the given shape with no corners. The glyph is taken from the given {@link BorderSet}.\n *\n * At the key `corners` you will find a version that has the same signature but _does_ add the required top left and top right right corners.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "borderTop: "
                },
                {
                  "kind": "Reference",
                  "text": "Bordered",
                  "canonicalReference": "effect-tree!Draw.Bordered:interface"
                },
                {
                  "kind": "Content",
                  "text": " & {\n    corners: "
                },
                {
                  "kind": "Reference",
                  "text": "Bordered",
                  "canonicalReference": "effect-tree!Draw.Bordered:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "borderTop",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.bottomElbowsDirections:var",
              "docComment": "/**\n * Corners for the bottom of a box.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "bottomElbowsDirections: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"bottomRight\", \"bottomLeft\"]"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "bottomElbowsDirections",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.box:var",
              "docComment": "/**\n * Wrap a part in a configurable bordered box.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "box: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (part: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ", settings?: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "BoxSettings",
                  "canonicalReference": "effect-tree!Draw.BoxSettings:interface"
                },
                {
                  "kind": "Content",
                  "text": ">): "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (settings?: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "BoxSettings",
                  "canonicalReference": "effect-tree!Draw.BoxSettings:interface"
                },
                {
                  "kind": "Content",
                  "text": ">): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/box.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "box",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 18
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.BoxSettings:interface",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface BoxSettings "
                }
              ],
              "fileUrlPath": "src/draw/parts/box.ts",
              "releaseTag": "Public",
              "name": "BoxSettings",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.BoxSettings#border:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "border: "
                    },
                    {
                      "kind": "Reference",
                      "text": "BorderSet",
                      "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "border",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.BoxSettings#margin:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "margin: "
                    },
                    {
                      "kind": "Reference",
                      "text": "DirectedPad",
                      "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "margin",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.BoxSettings#padding:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "padding: "
                    },
                    {
                      "kind": "Reference",
                      "text": "DirectedPad",
                      "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "padding",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.branchLabel:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "branchLabel: (label: "
                },
                {
                  "kind": "Content",
                  "text": "string"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "ThemedPart",
                  "canonicalReference": "effect-tree!Draw.ThemedPart:type"
                }
              ],
              "fileUrlPath": "src/draw/tree/atoms.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "label",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "branchLabel"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.BuildAlignedPart:type",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type BuildAlignedPart = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "BuildPart",
                  "canonicalReference": "effect-tree!Draw.BuildPart:interface"
                },
                {
                  "kind": "Content",
                  "text": ">>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/part/row.ts",
              "releaseTag": "Public",
              "name": "BuildAlignedPart",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 11
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.BuildAlignedRow:type",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type BuildAlignedRow = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "BuildRow",
                  "canonicalReference": "effect-tree!Draw.BuildRow:interface"
                },
                {
                  "kind": "Content",
                  "text": ">>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/part/row.ts",
              "releaseTag": "Public",
              "name": "BuildAlignedRow",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 11
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.BuildPart:interface",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface BuildPart "
                }
              ],
              "fileUrlPath": "src/draw/part/row.ts",
              "releaseTag": "Public",
              "name": "BuildPart",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "CallSignature",
                  "canonicalReference": "effect-tree!Draw.BuildPart:call(1)",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "(part: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Part",
                      "canonicalReference": "effect-tree!Draw.Part_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": ", struts?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Partial",
                      "canonicalReference": "!Partial:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Struts",
                      "canonicalReference": "effect-tree!Draw.Struts:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": "): "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Part",
                      "canonicalReference": "effect-tree!Draw.Part_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "returnTypeTokenRange": {
                    "startIndex": 8,
                    "endIndex": 12
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "part",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "struts",
                      "parameterTypeTokenRange": {
                        "startIndex": 3,
                        "endIndex": 7
                      },
                      "isOptional": true
                    }
                  ]
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.BuildRow:interface",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface BuildRow "
                }
              ],
              "fileUrlPath": "src/draw/part/row.ts",
              "releaseTag": "Public",
              "name": "BuildRow",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "CallSignature",
                  "canonicalReference": "effect-tree!Draw.BuildRow:call(1)",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "(cells: "
                    },
                    {
                      "kind": "Content",
                      "text": "readonly "
                    },
                    {
                      "kind": "Reference",
                      "text": "Part",
                      "canonicalReference": "effect-tree!Draw.Part_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "[]"
                    },
                    {
                      "kind": "Content",
                      "text": ", struts?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Partial",
                      "canonicalReference": "!Partial:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Struts",
                      "canonicalReference": "effect-tree!Draw.Struts:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": "): "
                    },
                    {
                      "kind": "Reference",
                      "text": "Part",
                      "canonicalReference": "effect-tree!Draw.Part_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "returnTypeTokenRange": {
                    "startIndex": 10,
                    "endIndex": 11
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "cells",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 4
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "struts",
                      "parameterTypeTokenRange": {
                        "startIndex": 5,
                        "endIndex": 9
                      },
                      "isOptional": true
                    }
                  ]
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.bulletRoles:var",
              "docComment": "/**\n * Bullet role names.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "bulletRoles: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"rootBullet\", \"branchBullet\", \"leafBullet\"]"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/glyph.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "bulletRoles",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.Column:function(1)",
              "docComment": "/**\n * Combine parts vertically.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Column: (hAlign: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontallyAligned",
                  "canonicalReference": "effect-tree!Draw.HorizontallyAligned:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "((cells: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": "[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "Column",
                  "canonicalReference": "effect-tree!Draw.Column:type"
                },
                {
                  "kind": "Content",
                  "text": ")"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "hAlign",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "Column"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Column:type",
              "docComment": "/**\n * A rectangular column of parts that is horizontally aligned and possibly has a horizontal strut to fill in empty space on alignment. The non-recursive type is {@link ColumnF}.\n *\n * The expanded type:\n * ```ts\n * {\n *   unfixed: {\n *     cells:  A[]\n *     hAlign: HorizontalAlignment\n *     right:  HStrut\n *     left:   HStrut\n *   }\n * }\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Column = "
                },
                {
                  "kind": "Content",
                  "text": "{\n    unfixed: "
                },
                {
                  "kind": "Reference",
                  "text": "ColumnF",
                  "canonicalReference": "effect-tree!Draw.PartF_2.ColumnF:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n} & "
                },
                {
                  "kind": "Reference",
                  "text": "Fix",
                  "canonicalReference": "effect-ts-folds!Fix:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "PartFTypeLambda",
                  "canonicalReference": "effect-tree!Draw.PartF_2.PartFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "releaseTag": "Public",
              "name": "Column",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.column:var",
              "docComment": "/**\n * Combine parts vertically.\n *\n * The first cell will be drawn at the top of the column, the final at the bottom.\n *\n * The alignment is given in the first argument list. If none is given, nodes are aligned to the _center_.\n *\n * The horizontal struts are given in the second argument list, as optional arguments following the `cells` argument. If only a single strut is given, it is used for both the left and right side of the aligned part.\n *\n * If two struts are given, the first is used for the left side and the second for the right side.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "column: "
                },
                {
                  "kind": "Content",
                  "text": "((hAlign?: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ") => (cells: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": "[], left?: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ", right?: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") & "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", (cells: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": "[], left?: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ", right?: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/part/column.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "column",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 24
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.ColumnOp:interface",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface ColumnOp "
                }
              ],
              "fileUrlPath": "src/draw/part/column.ts",
              "releaseTag": "Public",
              "name": "ColumnOp",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "CallSignature",
                  "canonicalReference": "effect-tree!Draw.ColumnOp:call(1)",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "(that: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Part",
                      "canonicalReference": "effect-tree!Draw.Part_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": ", left?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ", right?: "
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": "): "
                    },
                    {
                      "kind": "Reference",
                      "text": "EndoOf",
                      "canonicalReference": "effect-tree!EndoOf:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Part",
                      "canonicalReference": "effect-tree!Draw.Part_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "returnTypeTokenRange": {
                    "startIndex": 7,
                    "endIndex": 11
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "that",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "left",
                      "parameterTypeTokenRange": {
                        "startIndex": 3,
                        "endIndex": 4
                      },
                      "isOptional": true
                    },
                    {
                      "parameterName": "right",
                      "parameterTypeTokenRange": {
                        "startIndex": 5,
                        "endIndex": 6
                      },
                      "isOptional": true
                    }
                  ]
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.ColumnOps:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type ColumnOps = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "ColumnOp",
                  "canonicalReference": "effect-tree!Draw.ColumnOp:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/part/column.ts",
              "releaseTag": "Public",
              "name": "ColumnOps",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.computePadHeight:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "computePadHeight: ({ "
                },
                {
                  "kind": "Reference",
                  "text": "pad",
                  "canonicalReference": "effect-tree!Draw.Padded#pad"
                },
                {
                  "kind": "Content",
                  "text": ": { top, bottom } }: "
                },
                {
                  "kind": "Reference",
                  "text": "Padded",
                  "canonicalReference": "effect-tree!Draw.Padded:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "number"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ pad: { top, bottom } }",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "name": "computePadHeight"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.computePadSize:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "computePadSize: (padded: "
                },
                {
                  "kind": "Reference",
                  "text": "Padded",
                  "canonicalReference": "effect-tree!Draw.Padded:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "[width: number, height: number]"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "padded",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "computePadSize"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.computePadWidth:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "computePadWidth: ({ "
                },
                {
                  "kind": "Reference",
                  "text": "pad",
                  "canonicalReference": "effect-tree!Draw.Padded#pad"
                },
                {
                  "kind": "Content",
                  "text": ": { left, right } }: "
                },
                {
                  "kind": "Reference",
                  "text": "Padded",
                  "canonicalReference": "effect-tree!Draw.Padded:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "number"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ pad: { left, right } }",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "name": "computePadWidth"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.CornerDirection:type",
              "docComment": "/**\n * Union of the four directions where corner glyphs are placed: `topLeft`, `topRight`, `bottomRight`, and `bottomLeft`.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type CornerDirection = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "elbowDirections",
                  "canonicalReference": "effect-tree!Draw.elbowDirections:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/types.ts",
              "releaseTag": "Public",
              "name": "CornerDirection",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Cornered:type",
              "docComment": "/**\n * A record of values of type `A`, one per corner direction.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Cornered<A> = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "CornerDirection",
                  "canonicalReference": "effect-tree!Draw.CornerDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", A>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/types.ts",
              "releaseTag": "Public",
              "name": "Cornered",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.cross:function(1)",
              "docComment": "/**\n * Get a tee set by name.  @function  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "cross: (name: "
                },
                {
                  "kind": "Reference",
                  "text": "CrossName",
                  "canonicalReference": "effect-tree!Draw.CrossName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/glyph/crosses.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "name",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "cross"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Crosses:type",
              "docComment": "/**\n * A record of all cross glyphs by name.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Crosses = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "CrossName",
                  "canonicalReference": "effect-tree!Draw.CrossName:type"
                },
                {
                  "kind": "Content",
                  "text": ", string>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/crosses.ts",
              "releaseTag": "Public",
              "name": "Crosses",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.CrossName:type",
              "docComment": "/**\n * The type of a cross name.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type CrossName = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "crossNames",
                  "canonicalReference": "effect-tree!Draw.crossNames:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/crosses.ts",
              "releaseTag": "Public",
              "name": "CrossName",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.crossNames:var",
              "docComment": "/**\n * Names of all cross glyphs.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "crossNames: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"ascii\", \"double\", \"hDouble\", \"hThick\", \"solid\", \"space\", \"thick\", \"thin\", \"vDouble\", \"vThick\", \"vThickBottom\", \"vThickLeft\", \"vThickRight\", \"vThickTop\", \"vThinBottom\", \"vThinLeft\", \"vThinRight\", \"vThinTop\"]"
                }
              ],
              "fileUrlPath": "src/draw/glyph/crosses.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "crossNames",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.decrementIndents:function(1)",
              "docComment": "/**\n * Decrement tree theme indents by the given count, by default `1`. If the indent count is zero the theme is return unchanged.\n *\n * @param decrement - Number of characters to remove from the theme indent count.\n *\n * @returns Theme with updated vertical spacing.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "decrementIndents: (decrement?: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "decrement",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": true
                }
              ],
              "name": "decrementIndents"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.decrementSpacing:function(1)",
              "docComment": "/**\n * Decrement tree theme spacing by the given count, by default `1`. If the spacing is at zero the theme is returned unchanged.\n *\n * @param decrement - Number of vertical lines to remove from the theme spacing.\n *\n * @returns Theme with updated vertical spacing.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "decrementSpacing: (decrement?: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "decrement",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": true
                }
              ],
              "name": "decrementSpacing"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.defaultHStrut:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "defaultHStrut: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "defaultHStrut",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.defaultTheme:var",
              "docComment": "/**\n * Default {@link Theme} will draw trees with thin lines and minimal spacing and indent.\n * ```txt\n * ┬1  // default\n * ├─2 // theme\n * └─3 // example\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "defaultTheme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "defaultTheme",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.defaultVStrut:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "defaultVStrut: "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "defaultVStrut",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Directed:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Directed<A> = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", A>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "releaseTag": "Public",
              "name": "Directed",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.DirectedPad:type",
              "docComment": "/**\n * An object with a possibly zero padding at every direction.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type DirectedPad = "
                },
                {
                  "kind": "Reference",
                  "text": "Directed",
                  "canonicalReference": "effect-tree!Draw.Directed:type"
                },
                {
                  "kind": "Content",
                  "text": "<number>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "releaseTag": "Public",
              "name": "DirectedPad",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Direction:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Direction = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "directions",
                  "canonicalReference": "effect-tree!Draw.directions:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "releaseTag": "Public",
              "name": "Direction",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.directions:var",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "directions: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"top\", \"right\", \"bottom\", \"left\"]"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "directions",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.drawPart:var",
              "docComment": "/**\n * Render a part into a list of strings rows.\n *\n * @param part - Part to be drawn.\n *\n * @returns Possibly empty array of lines.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "drawPart: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (part: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": "): string[];\n    unlines: (part: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") => string;\n}"
                }
              ],
              "fileUrlPath": "src/draw/part/draw.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "drawPart",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.DrawTree:interface",
              "docComment": "/**\n * Type of the {@link drawTree} function: exactly like {@link EnrichedDraw} but adds a key per theme name with another {@link EnrichedDraw} as the value.\n *\n * A function of the type:\n * ```ts\n * {\n *     (self: Tree<string>): NonEmptyArray<string>\n *     unlines: (self: Tree<string>) ⇒ string\n *     number: {\n *       (self: Tree<number>) ⇒ NonEmptyArray<string>\n *       unlines: (self: Tree<number>) ⇒ string\n *     }\n * } & Record<ThemeName, EnrichedDraw>\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface DrawTree extends "
                },
                {
                  "kind": "Reference",
                  "text": "EnrichedDraw",
                  "canonicalReference": "effect-tree!Draw.EnrichedDraw:interface"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ThemeName",
                  "canonicalReference": "effect-tree!Draw.ThemeName:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "EnrichedDraw",
                  "canonicalReference": "effect-tree!Draw.EnrichedDraw:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/draw/tree/draw.ts",
              "releaseTag": "Public",
              "name": "DrawTree",
              "preserveMemberOrder": false,
              "members": [],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 2
                },
                {
                  "startIndex": 3,
                  "endIndex": 9
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.drawTree:var",
              "docComment": "/**\n * Draw a string or numeric tree into a non-empty array of string rows.\n *\n * At the key `unlines` you will find a version the returns a string of the joined rows.\n *\n * At the key `numeric` you will find a version that draws _numeric_ trees, and it too has a key `unlines` with a version that draws to strings rather than an array of rows.\n *\n * At each key named after a {@link themeNames | theme name}, you will find a version of the function with its `numeric` and `unlines` variants, that draws the tree at the given theme.\n *\n * @example\n *\n * import {Array} from 'effect' import {drawTree} from 'effect-tree'\n *\n * const stringTree = of('foo') const numericTree = of(42)\n *\n * // Draw a string tree into arrays of rows using default theme. const stringRows : Array.NonEmptyArray<string> = drawTree(stringTree)\n *\n * // Draw a numeric tree into arrays of rows using default theme. const numericRows: Array.NonEmptyArray<string> = drawTree.number(numericTree)\n *\n * // Draw string trees to a string using default theme for `console.log`, for // example. console.log(drawTree.unlines(stringTree))\n *\n * // Draw numeric trees to a string using default theme. console.log(drawTree.numeric.unlines(numericTree))\n *\n * // Draw string trees using a specific theme into rows. const stringAsciiRows = drawTree.ascii(stringTree))\n *\n * // Draw string trees using a specific theme into a string. console.log(drawTree.ascii.unlines(stringTree))\n *\n * // Draw numeric trees using a specific theme into rows. const numericAsciiRows = drawTree.ascii.numeric(numericTree))\n *\n * // Draw numeric trees using a specific theme into a string. console.log(drawTree.ascii.numeric.unlines(numericTree))  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "drawTree: "
                },
                {
                  "kind": "Reference",
                  "text": "DrawTree",
                  "canonicalReference": "effect-tree!Draw.DrawTree:interface"
                }
              ],
              "fileUrlPath": "src/draw/tree/draw.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "drawTree",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.elbowDirections:var",
              "docComment": "/**\n * Elbows are named after the corner they appear at in a box border, which is also the elbow direction is you view it as an arrow with a point.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "elbowDirections: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"topLeft\", \"topRight\", \"bottomRight\", \"bottomLeft\"]"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "elbowDirections",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.elbowSet:function(1)",
              "docComment": "/**\n * Get an elbow set by name.\n *\n * You can mix and match sets. For example if you need a set of elbows for a box where all borders are thin lines except the bottom which is a thick line, you could:\n * ```ts\n * import {Draw} from 'effect-tree'\n *\n * const myElbowSet: Draw.ElbowSet = {\n *   ...Struct.pick(Draw.elbowSet('thin'), ...Draw.topElbows),\n *   ...Struct.pick(Draw.elbowSet('hThick'), ...Draw.bottomElbows),\n * }\n * ```\n *\n * And your elbows will be thin, except for the bottom:\n * ```txt\n *    topLeft ┌ ┐ topRight\n *\n * bottomLeft ┕ ┙ bottomRight\n * ```\n *\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "elbowSet: (name: "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSetName",
                  "canonicalReference": "effect-tree!Draw.ElbowSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSet",
                  "canonicalReference": "effect-tree!Draw.ElbowSet:type"
                }
              ],
              "fileUrlPath": "src/draw/glyph/elbows.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "name",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "elbowSet"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.ElbowSet:type",
              "docComment": "/**\n * A record of elbow glyph per corner direction describing some corner style for boxes and elbows.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type ElbowSet = "
                },
                {
                  "kind": "Reference",
                  "text": "Cornered",
                  "canonicalReference": "effect-tree!Draw.Cornered:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/types.ts",
              "releaseTag": "Public",
              "name": "ElbowSet",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.ElbowSetName:type",
              "docComment": "/**\n * The type of a elbow set name.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type ElbowSetName = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "elbowSetNames",
                  "canonicalReference": "effect-tree!Draw.elbowSetNames:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/elbows.ts",
              "releaseTag": "Public",
              "name": "ElbowSetName",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.elbowSetNames:var",
              "docComment": "/**\n * Names of all elbow sets.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "elbowSetNames: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"ascii\", \"diagonal\", \"double\", \"halfSolid\", \"halfSolidNear\", \"halfSolidFar\", \"hDouble\", \"hThick\", \"round\", \"solid\", \"space\", \"thick\", \"thin\", \"vDouble\", \"vThick\"]"
                }
              ],
              "fileUrlPath": "src/draw/glyph/elbows.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "elbowSetNames",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.ElbowSets:type",
              "docComment": "/**\n * A record of all elbow sets. An elbow set has an elbow defined for each elbow direction. The elbows are grouped into sets by style.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type ElbowSets = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSetName",
                  "canonicalReference": "effect-tree!Draw.ElbowSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSet",
                  "canonicalReference": "effect-tree!Draw.ElbowSet:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/elbows.ts",
              "releaseTag": "Public",
              "name": "ElbowSets",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Empty:type",
              "docComment": "/**\n * The empty part takes up zero horizontal and vertical space. The non-recursive version is {@link EmptyF}.\n *\n * The expanded type:\n * ```ts\n * {unfixed: {}}\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Empty = "
                },
                {
                  "kind": "Content",
                  "text": "{\n    unfixed: "
                },
                {
                  "kind": "Reference",
                  "text": "EmptyF",
                  "canonicalReference": "effect-tree!Draw.PartF_2.EmptyF:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n} & "
                },
                {
                  "kind": "Reference",
                  "text": "Fix",
                  "canonicalReference": "effect-ts-folds!Fix:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "PartFTypeLambda",
                  "canonicalReference": "effect-tree!Draw.PartF_2.PartFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "releaseTag": "Public",
              "name": "Empty",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 8
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.empty:var",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "empty: "
                },
                {
                  "kind": "Reference",
                  "text": "Empty",
                  "canonicalReference": "effect-tree!Draw.Empty:type"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "empty",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.emptyTextPart:var",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "emptyTextPart: "
                },
                {
                  "kind": "Content",
                  "text": "import(\"../part.js\")."
                },
                {
                  "kind": "Reference",
                  "text": "Text",
                  "canonicalReference": "effect-tree!Draw.Text:type"
                }
              ],
              "fileUrlPath": "src/draw/parts/atoms.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "emptyTextPart",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.enrichedDraw:function(1)",
              "docComment": "/**\n * @category internal  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export declare function enrichedDraw(themeName: "
                },
                {
                  "kind": "Reference",
                  "text": "ThemeName",
                  "canonicalReference": "effect-tree!Draw.ThemeName:type"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "EnrichedDraw",
                  "canonicalReference": "effect-tree!Draw.EnrichedDraw:interface"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/draw.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "themeName",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "enrichedDraw"
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.EnrichedDraw:interface",
              "docComment": "/**\n * Type of the enriched draw function: an {@link UnlinesDraw} for strings, with another version of the very same {@link UnlinesDraw} at the key `number` specialized for numeric trees.\n *\n * A function of the type:\n * ```ts\n * {\n *   (self: Tree<string>): NonEmptyArray<string>\n *   unlines: (self: Tree<string>) ⇒ string\n *   number: {\n *     (self: Tree<number>) ⇒ NonEmptyArray<string>\n *     unlines: (self: Tree<number>) ⇒ string\n *   }\n * }\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface EnrichedDraw extends "
                },
                {
                  "kind": "Reference",
                  "text": "UnlinesDraw",
                  "canonicalReference": "effect-tree!Draw.UnlinesDraw:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/draw/tree/draw.ts",
              "releaseTag": "Public",
              "name": "EnrichedDraw",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.EnrichedDraw#number:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "number: "
                    },
                    {
                      "kind": "Reference",
                      "text": "UnlinesDraw",
                      "canonicalReference": "effect-tree!Draw.UnlinesDraw:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<number>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "number",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 3
                }
              ]
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.fillSpacing:function(1)",
              "docComment": "/**\n * Returns a list of newlines that is the size of the tree theme vertical spacing setting minus one.\n *\n * @param theme - Tree theme to query for spacing.\n *\n * @returns An array of single newlines. Newline count will be equal to theme spacing.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "fillSpacing: ({ spacing }: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string[]"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ spacing }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "fillSpacing"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.fixPart:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "fixPart: <Type extends "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">(unfixed: "
                },
                {
                  "kind": "Reference",
                  "text": "PartF",
                  "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "Type"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "returnTypeTokenRange": {
                "startIndex": 8,
                "endIndex": 9
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "unfixed",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 7
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "Type",
                  "constraintTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "fixPart"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.forHorizontalAlignments:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "forHorizontalAlignments: <R>(f: "
                },
                {
                  "kind": "Content",
                  "text": "(align: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", n: number) => R"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", R>"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 9
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "f",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "forHorizontalAlignments"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.formatNodes:function(1)",
              "docComment": "/**\n * Format tree nodes using the tree theme formatter.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "formatNodes: ({ formatter }: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>>"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ formatter }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "formatNodes"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.forVerticalAlignments:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "forVerticalAlignments: <R>(f: "
                },
                {
                  "kind": "Content",
                  "text": "(align: "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", n: number) => R"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", R>"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 9
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "f",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "forVerticalAlignments"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.getFormatter:function(1)",
              "docComment": "/**\n * Get the string formatter of the tree theme.\n *\n * @param theme - Theme to query.\n *\n * @returns Theme formatter.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getFormatter: ({ formatter }: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ formatter }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "getFormatter"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.getGlyph:var",
              "docComment": "/**\n * Get a glyph by role from a tree theme.\n *\n * @param role - Glyph role to get.\n *\n * @param theme - Theme to query.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getGlyph: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (role: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ", theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": "): string;\n    (theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": "): (role: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ") => string;\n}"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "getGlyph",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.getGlyphPart:var",
              "docComment": "/**\n * Get a glyph by role from a tree theme.\n *\n * @param theme - Theme to query.\n *\n * @returns Theme indents.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getGlyphPart: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (role: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ", theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": "): (role: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "getGlyphPart",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.getIndents:function(1)",
              "docComment": "/**\n * Get the indent count of a tree theme.\n *\n * @param theme - Theme to query.\n *\n * @returns Theme indents.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getIndents: ({ indents }: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "number"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ indents }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "getIndents"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.getSpacing:function(1)",
              "docComment": "/**\n * Get the vertical spacing of a tree theme.\n *\n * @param theme - Theme to query.\n *\n * @returns Theme vertical spacing.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getSpacing: ({ spacing }: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "number"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ spacing }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "getSpacing"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.getText:function(1)",
              "docComment": "/**\n * Get the text content of a {@link Text} part.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getText: (text: "
                },
                {
                  "kind": "Reference",
                  "text": "Text",
                  "canonicalReference": "effect-tree!Draw.Text:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "text",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "getText"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.getTheme:function(1)",
              "docComment": "/**\n * Get tree theme by name.\n *\n * @param name - the theme name requested.\n *\n * @returns The requested theme.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getTheme: (name: "
                },
                {
                  "kind": "Reference",
                  "text": "ThemeName",
                  "canonicalReference": "effect-tree!Draw.ThemeName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/themes.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "name",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "getTheme"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.glyphGroups:function(1)",
              "docComment": "/**\n * Get all glyph groups by common style name.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "glyphGroups: (name: "
                },
                {
                  "kind": "Reference",
                  "text": "TeeSetName",
                  "canonicalReference": "effect-tree!Draw.TeeSetName:type"
                },
                {
                  "kind": "Content",
                  "text": " & "
                },
                {
                  "kind": "Reference",
                  "text": "LineSetName",
                  "canonicalReference": "effect-tree!Draw.LineSetName:type"
                },
                {
                  "kind": "Content",
                  "text": " & "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSetName",
                  "canonicalReference": "effect-tree!Draw.ElbowSetName:type"
                },
                {
                  "kind": "Content",
                  "text": " & "
                },
                {
                  "kind": "Reference",
                  "text": "CrossName",
                  "canonicalReference": "effect-tree!Draw.CrossName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "{\n    tees: "
                },
                {
                  "kind": "Reference",
                  "text": "TeeSet",
                  "canonicalReference": "effect-tree!Draw.TeeSet:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    lines: "
                },
                {
                  "kind": "Reference",
                  "text": "LineSet",
                  "canonicalReference": "effect-tree!Draw.LineSet:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    elbows: "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSet",
                  "canonicalReference": "effect-tree!Draw.ElbowSet:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    cross: string;\n}"
                }
              ],
              "fileUrlPath": "src/draw/glyph/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 9,
                "endIndex": 16
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "name",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 8
                  },
                  "isOptional": false
                }
              ],
              "name": "glyphGroups"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.GlyphRole:type",
              "docComment": "/**\n * A role for a glyph in a glyph role map.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type GlyphRole = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "glyphRoles",
                  "canonicalReference": "effect-tree!Draw.glyphRoles:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/glyph.ts",
              "releaseTag": "Public",
              "name": "GlyphRole",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.glyphRoles:var",
              "docComment": "/**\n * Glyph role names.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "glyphRoles: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"elbow\", \"hLine\", \"indent\", \"rightTee\", \"space\", \"tee\", \"vLine\", \"rootBullet\", \"branchBullet\", \"leafBullet\"]"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/glyph.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "glyphRoles",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.glyphSet:function(1)",
              "docComment": "/**\n * Get a glyph set by name.\n *\n * @param name - Name of glyph set to get.\n *\n * @returns Requested glyph set.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "glyphSet: (name: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphSetName",
                  "canonicalReference": "effect-tree!Draw.GlyphSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphSet",
                  "canonicalReference": "effect-tree!Draw.GlyphSet:type"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/glyph.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "name",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "glyphSet"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.GlyphSet:type",
              "docComment": "/**\n * Maps roles to glyphs.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type GlyphSet = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ", string>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/glyph.ts",
              "releaseTag": "Public",
              "name": "GlyphSet",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.GlyphSetName:type",
              "docComment": "/**\n * A named {@link GlyphSet}.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type GlyphSetName = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "glyphSetNames",
                  "canonicalReference": "effect-tree!Draw.glyphSetNames:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/glyph.ts",
              "releaseTag": "Public",
              "name": "GlyphSetName",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.glyphSetNames:var",
              "docComment": "/**\n * Glyph set names.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "glyphSetNames: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"ascii\", \"bullets\", \"double\", \"hDouble\", \"hThick\", \"round\", \"space\", \"thick\", \"thin\", \"unix\", \"unixRound\", \"vDouble\", \"vThick\"]"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/glyph.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "glyphSetNames",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.hBorders:var",
              "docComment": "/**\n * Add borders to the left and right of the given part.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "hBorders: "
                },
                {
                  "kind": "Reference",
                  "text": "Bordered",
                  "canonicalReference": "effect-tree!Draw.Bordered:interface"
                }
              ],
              "fileUrlPath": "src/draw/parts/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "hBorders",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.headBranch:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "headBranch: (theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part.Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/tree/atoms.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "theme",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "headBranch"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.hIndent:var",
              "docComment": "/**\n * Returns the empty part if the given width is zero, else a text part at the given width filled with the optionally provided _indent_ string. The default indent string is a single space character.\n *\n * @example\n *\n * import {pipe} from 'effect' import {hIndent} from 'effect-tree' const twoSpaces = hIndent(2) // ‘ ’ const singleX = pipe(1, hIndent('X')) // ‘X’ const nothing = hIndent(0, 'no space') // ‘’  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "hIndent: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (repeat: number, indent?: string): "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (indent?: string): (repeat: number) => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/atoms.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "hIndent",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type HorizontalAlignment = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "horizontalAlignments",
                  "canonicalReference": "effect-tree!Draw.horizontalAlignments:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "releaseTag": "Public",
              "name": "HorizontalAlignment",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.horizontalAlignments:var",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "horizontalAlignments: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"left\", \"center\", \"right\"]"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "horizontalAlignments",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.HorizontalDirection:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type HorizontalDirection = "
                },
                {
                  "kind": "Content",
                  "text": "'left' | 'right'"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "releaseTag": "Public",
              "name": "HorizontalDirection",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.HorizontalEquivalence:var",
              "docComment": "/**\n * Equivalence for {@link HorizontallyAligned}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "HorizontalEquivalence: "
                },
                {
                  "kind": "Reference",
                  "text": "EQ.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "HorizontallyAligned",
                  "canonicalReference": "effect-tree!Draw.HorizontallyAligned:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "HorizontalEquivalence",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.HorizontallyAligned:interface",
              "docComment": "/**\n * ```ts\n * {\n *   hAlign: HorizontalAlignment\n *   left: HStrut\n *   right: HStrut\n * }\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface HorizontallyAligned extends "
                },
                {
                  "kind": "Reference",
                  "text": "HStruts",
                  "canonicalReference": "effect-tree!Draw.HStruts:type"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "releaseTag": "Public",
              "name": "HorizontallyAligned",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.HorizontallyAligned#hAlign:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "hAlign: "
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "hAlign",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 2
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.hSpace:var",
              "docComment": "/**\n * Pad a part with left and right padding filled with the optional padding, by default the space character.\n *\n * At the keys `left` and `right` you will find versions that pad only a single side of the given part.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "hSpace: "
                },
                {
                  "kind": "Content",
                  "text": "((fillLeft?: string, fillRight?: string) => (padLeft?: number, padRight?: number) => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">) & {\n    left: (fillLeft?: string, padLeft?: number) => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n    right: (fillRight?: string, padRight?: number) => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/atoms.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "hSpace",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.HStrut:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type HStrut = "
                },
                {
                  "kind": "Reference",
                  "text": "BaseStrut",
                  "canonicalReference": "effect-tree!Draw.BaseStrut:interface"
                },
                {
                  "kind": "Content",
                  "text": "<'horizontal'>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "releaseTag": "Public",
              "name": "HStrut",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.HStrut:var",
              "docComment": "/**\n * Build a horizontal strut from a non-empty array of its glyph and an prefix/suffix strings.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "HStrut: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (body?: "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>, prefix?: string, suffix?: string): "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    space: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    fill({ prefix, body, suffix }: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": "): (available: number) => string;\n}"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "HStrut",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.HStruts:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type HStruts = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalDirection",
                  "canonicalReference": "effect-tree!Draw.HorizontalDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "releaseTag": "Public",
              "name": "HStruts",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.HStruts:var",
              "docComment": "/**\n * Build a pair of left/right horizontal struts form the given horizontal struts.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "HStruts: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (left: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ", right?: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "HStruts",
                  "canonicalReference": "effect-tree!Draw.HStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    space: "
                },
                {
                  "kind": "Reference",
                  "text": "HStruts",
                  "canonicalReference": "effect-tree!Draw.HStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    fill({ left, right }: "
                },
                {
                  "kind": "Reference",
                  "text": "HStruts",
                  "canonicalReference": "effect-tree!Draw.HStruts:type"
                },
                {
                  "kind": "Content",
                  "text": "): (availableLeft: number, availableRight: number) => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string>;\n}"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "HStruts",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.HStrutsEquivalence:var",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "HStrutsEquivalence: "
                },
                {
                  "kind": "Reference",
                  "text": "EQ.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "HStruts",
                  "canonicalReference": "effect-tree!Draw.HStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "HStrutsEquivalence",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.incrementIndents:function(1)",
              "docComment": "/**\n * Increment tree theme indents by the given count, by default `1`.\n *\n * @param increment - Number of characters to add to the theme indent count.\n *\n * @returns Theme with updated vertical spacing.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "incrementIndents: (increment?: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "increment",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": true
                }
              ],
              "name": "incrementIndents"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.incrementSpacing:function(1)",
              "docComment": "/**\n * Increment tree theme spacing by the given count, by default `1`.\n *\n * @param increment - Number of vertical lines to add to the theme spacing.\n *\n * @returns Theme with updated vertical spacing.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "incrementSpacing: (increment?: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "increment",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": true
                }
              ],
              "name": "incrementSpacing"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.indentedThemes:var",
              "docComment": "/**\n * Names of themes sets created with an indent count of one.  @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "indentedThemes: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"ascii\", \"bullets\", \"space\"]"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "indentedThemes",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.indentGlyph:function(1)",
              "docComment": "/**\n * Given a {@link GlyphRole} as a _prefix_, and another one for _indents_, returns a string that starts with the glyph from the prefix role, and fills the size of the {@link Theme} `indents` field with the given glyph role.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "indentGlyph: (theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(prefixRole: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ", indentRole: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ") => string"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "theme",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "indentGlyph"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.indentGlyphPart:function(1)",
              "docComment": "/**\n * A version of {@link indentGlyph} that returns its result in a {@link Text} part instead of a string.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "indentGlyphPart: (prefixRole: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ", indentRole: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "ThemedPart",
                  "canonicalReference": "effect-tree!Draw.ThemedPart:type"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "prefixRole",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "indentRole",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "name": "indentGlyphPart"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.isColumn:function(1)",
              "docComment": "/**\n * Type guard for the {@link Column} {@link Part}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isColumn: (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "self",
                  "canonicalReference": "effect-tree!~self"
                },
                {
                  "kind": "Content",
                  "text": " is "
                },
                {
                  "kind": "Reference",
                  "text": "Column",
                  "canonicalReference": "effect-tree!Draw.Column:type"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "isColumn"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.isEmptyPart:function(1)",
              "docComment": "/**\n * Type guard for the {@link Empty} {@link Part}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isEmptyPart: (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "self",
                  "canonicalReference": "effect-tree!~self"
                },
                {
                  "kind": "Content",
                  "text": " is "
                },
                {
                  "kind": "Reference",
                  "text": "Empty",
                  "canonicalReference": "effect-tree!Draw.Empty:type"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "isEmptyPart"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.isHStrut:function(1)",
              "docComment": "/**\n * Type guard for horizontal struts.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isHStrut: (strut: "
                },
                {
                  "kind": "Reference",
                  "text": "BaseStrut",
                  "canonicalReference": "effect-tree!Draw.BaseStrut:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Axis",
                  "canonicalReference": "effect-tree!Draw.Axis:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "strut",
                  "canonicalReference": "effect-tree!~strut"
                },
                {
                  "kind": "Content",
                  "text": " is "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 6,
                "endIndex": 9
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "strut",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  },
                  "isOptional": false
                }
              ],
              "name": "isHStrut"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.isRow:function(1)",
              "docComment": "/**\n * Type guard for the {@link Row} {@link Part}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isRow: (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "self",
                  "canonicalReference": "effect-tree!~self"
                },
                {
                  "kind": "Content",
                  "text": " is "
                },
                {
                  "kind": "Reference",
                  "text": "Row",
                  "canonicalReference": "effect-tree!Draw.Row:type"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "isRow"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.isText:function(1)",
              "docComment": "/**\n * Type guard for the {@link Text} {@link Part}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isText: (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "self",
                  "canonicalReference": "effect-tree!~self"
                },
                {
                  "kind": "Content",
                  "text": " is "
                },
                {
                  "kind": "Reference",
                  "text": "Text",
                  "canonicalReference": "effect-tree!Draw.Text:type"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "isText"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.isVStrut:function(1)",
              "docComment": "/**\n * Type guard for vertical struts.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isVStrut: (strut: "
                },
                {
                  "kind": "Reference",
                  "text": "BaseStrut",
                  "canonicalReference": "effect-tree!Draw.BaseStrut:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Axis",
                  "canonicalReference": "effect-tree!Draw.Axis:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "strut",
                  "canonicalReference": "effect-tree!~strut"
                },
                {
                  "kind": "Content",
                  "text": " is "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 6,
                "endIndex": 9
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "strut",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  },
                  "isOptional": false
                }
              ],
              "name": "isVStrut"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.joinText:var",
              "docComment": "/**\n * A text part that joins the given string list horizontally, separating items using the given separator.\n *\n * @example\n *\n * import {Draw} from 'effect-tree'\n *\n * const abcText = Draw.joinText(['A', 'B', 'C'], '.') // ‘A.B.C’  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "joinText: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (xs: string[], separator?: string): "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (separator?: string): (xs: string[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/atoms.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "joinText",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.leafLabel:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "leafLabel: (label: "
                },
                {
                  "kind": "Content",
                  "text": "string"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "ThemedPart",
                  "canonicalReference": "effect-tree!Draw.ThemedPart:type"
                }
              ],
              "fileUrlPath": "src/draw/tree/atoms.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "label",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "leafLabel"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.lineSet:function(1)",
              "docComment": "/**\n * Get a line set by name.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "lineSet: (name: "
                },
                {
                  "kind": "Reference",
                  "text": "LineSetName",
                  "canonicalReference": "effect-tree!Draw.LineSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "LineSet",
                  "canonicalReference": "effect-tree!Draw.LineSet:type"
                }
              ],
              "fileUrlPath": "src/draw/glyph/lines.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "name",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "lineSet"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.LineSet:type",
              "docComment": "/**\n * A record of line glyph per direction describing some style for lines.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type LineSet = "
                },
                {
                  "kind": "Reference",
                  "text": "Directed",
                  "canonicalReference": "effect-tree!Draw.Directed:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/types.ts",
              "releaseTag": "Public",
              "name": "LineSet",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.LineSetName:type",
              "docComment": "/**\n * The type of a line set name.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type LineSetName = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "lineSetNames",
                  "canonicalReference": "effect-tree!Draw.lineSetNames:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/lines.ts",
              "releaseTag": "Public",
              "name": "LineSetName",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.lineSetNames:var",
              "docComment": "/**\n * Names of all line sets.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "lineSetNames: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"ascii\", \"dashed\", \"dashedWide\", \"dotted\", \"double\", \"halfSolid\", \"halfSolidNear\", \"halfSolidFar\", \"hDouble\", \"hThick\", \"near\", \"solid\", \"space\", \"thick\", \"thickDashed\", \"thickDashedWide\", \"thickDotted\", \"thin\", \"vDouble\", \"vThick\"]"
                }
              ],
              "fileUrlPath": "src/draw/glyph/lines.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "lineSetNames",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.LineSets:type",
              "docComment": "/**\n * A record of all line sets.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type LineSets = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "LineSetName",
                  "canonicalReference": "effect-tree!Draw.LineSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "LineSet",
                  "canonicalReference": "effect-tree!Draw.LineSet:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/lines.ts",
              "releaseTag": "Public",
              "name": "LineSets",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.mapHorizontalAlignments:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "mapHorizontalAlignments: <A>(f: "
                },
                {
                  "kind": "Content",
                  "text": "(align: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", n: number) => A"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "[A, A, A]"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "f",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "mapHorizontalAlignments"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.mapThemes:function(1)",
              "docComment": "/**\n * Map over all themes to build a record theme `name` ⇒ `f(theme)`.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "mapThemes: <A>(f: "
                },
                {
                  "kind": "Content",
                  "text": "(theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ", name: "
                },
                {
                  "kind": "Reference",
                  "text": "ThemeName",
                  "canonicalReference": "effect-tree!Draw.ThemeName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => A"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ThemeName",
                  "canonicalReference": "effect-tree!Draw.ThemeName:type"
                },
                {
                  "kind": "Content",
                  "text": ", A>"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/themes.ts",
              "returnTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 11
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "f",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 6
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "mapThemes"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.mapVerticalAlignments:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "mapVerticalAlignments: <A>(f: "
                },
                {
                  "kind": "Content",
                  "text": "(align: "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ", n: number) => A"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "[A, A, A]"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "f",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "mapVerticalAlignments"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.matchHorizontal:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "matchHorizontal: <R>(onLeft: "
                },
                {
                  "kind": "Reference",
                  "text": "LazyArg",
                  "canonicalReference": "effect!LazyArg:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R>"
                },
                {
                  "kind": "Content",
                  "text": ", onCenter: "
                },
                {
                  "kind": "Reference",
                  "text": "LazyArg",
                  "canonicalReference": "effect!LazyArg:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R>"
                },
                {
                  "kind": "Content",
                  "text": ", onRight: "
                },
                {
                  "kind": "Reference",
                  "text": "LazyArg",
                  "canonicalReference": "effect!LazyArg:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(o: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ") => R"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 10,
                "endIndex": 13
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "onLeft",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "onCenter",
                  "parameterTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "onRight",
                  "parameterTypeTokenRange": {
                    "startIndex": 7,
                    "endIndex": 9
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "matchHorizontal"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.matchPart:function(1)",
              "docComment": "/**\n * Match part by type.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "matchPart: <R>(onEmpty: "
                },
                {
                  "kind": "Content",
                  "text": "R"
                },
                {
                  "kind": "Content",
                  "text": ", onText: "
                },
                {
                  "kind": "Content",
                  "text": "(s: string) => R"
                },
                {
                  "kind": "Content",
                  "text": ", onRow: "
                },
                {
                  "kind": "Content",
                  "text": "(r: "
                },
                {
                  "kind": "Reference",
                  "text": "Row",
                  "canonicalReference": "effect-tree!Draw.Row:type"
                },
                {
                  "kind": "Content",
                  "text": ") => R"
                },
                {
                  "kind": "Content",
                  "text": ", onColumn: "
                },
                {
                  "kind": "Content",
                  "text": "(c: "
                },
                {
                  "kind": "Reference",
                  "text": "Column",
                  "canonicalReference": "effect-tree!Draw.Column:type"
                },
                {
                  "kind": "Content",
                  "text": ") => R"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "((p: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") => R)"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 13,
                "endIndex": 16
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "onEmpty",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "onText",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "onRow",
                  "parameterTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 8
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "onColumn",
                  "parameterTypeTokenRange": {
                    "startIndex": 9,
                    "endIndex": 12
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "matchPart"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.matchVertical:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "matchVertical: <R>(onTop: "
                },
                {
                  "kind": "Reference",
                  "text": "LazyArg",
                  "canonicalReference": "effect!LazyArg:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R>"
                },
                {
                  "kind": "Content",
                  "text": ", onMiddle: "
                },
                {
                  "kind": "Reference",
                  "text": "LazyArg",
                  "canonicalReference": "effect!LazyArg:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R>"
                },
                {
                  "kind": "Content",
                  "text": ", onBottom: "
                },
                {
                  "kind": "Reference",
                  "text": "LazyArg",
                  "canonicalReference": "effect!LazyArg:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(o: "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ") => R"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 10,
                "endIndex": 13
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "onTop",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "onMiddle",
                  "parameterTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "onBottom",
                  "parameterTypeTokenRange": {
                    "startIndex": 7,
                    "endIndex": 9
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "matchVertical"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.modFormatter:function(1)",
              "docComment": "/**\n * Modify the formatter function of a tree theme using the given function.\n *\n * @param f - Will be given the formatter function and expected to return an updated value.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export declare function modFormatter(f: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string>>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 6,
                "endIndex": 10
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "f",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  },
                  "isOptional": false
                }
              ],
              "name": "modFormatter"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.modIndents:function(1)",
              "docComment": "/**\n * Modify the indent count of a tree theme using the given function.\n *\n * @param f - Will be given the indent count and expected to return an updated value.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export declare function modIndents(f: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<number>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "f",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "name": "modIndents"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.modSpacing:function(1)",
              "docComment": "/**\n * Modify the vertical spacing of a tree theme using the given function.\n *\n * @param f - Will be given the vertical spacing and expected to return an updated value.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export declare function modSpacing(f: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<number>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "f",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "name": "modSpacing"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.noIndentThemes:var",
              "docComment": "/**\n * Names of themes created with an indent count of zero.  @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "noIndentThemes: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"thin\", \"thick\", \"hThick\", \"vThick\", \"unix\", \"unixRound\", \"round\", \"double\", \"hDouble\", \"vDouble\"]"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "noIndentThemes",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.noPadding:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "noPadding: "
                },
                {
                  "kind": "Reference",
                  "text": "DirectedPad",
                  "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "noPadding",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.normalizePad:function(1)",
              "docComment": "/**\n * Upgrade a partial {@link DirectedPad} into a total one, filling in empty slots with zeros.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "normalizePad: (padded?: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "DirectedPad",
                  "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "DirectedPad",
                  "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "returnTypeTokenRange": {
                "startIndex": 6,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "padded",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  },
                  "isOptional": true
                }
              ],
              "name": "normalizePad"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.normalizePadded:function(1)",
              "docComment": "/**\n * Upgrade a partial {@link Padded} into a total one, filling in with defaults.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "normalizePadded: (padded?: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<{\n    pad?: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "DirectedPad",
                  "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n    padStruts?: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Struts",
                  "canonicalReference": "effect-tree!Draw.Struts:interface"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Padded",
                  "canonicalReference": "effect-tree!Draw.Padded:interface"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "returnTypeTokenRange": {
                "startIndex": 12,
                "endIndex": 13
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "padded",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 11
                  },
                  "isOptional": true
                }
              ],
              "name": "normalizePadded"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.normalizeStruts:function(1)",
              "docComment": "/**\n * Upgrade a partial set of struts per direction into a total one.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "normalizeStruts: (struts?: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Struts",
                  "canonicalReference": "effect-tree!Draw.Struts:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Struts",
                  "canonicalReference": "effect-tree!Draw.Struts:interface"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 6,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "struts",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  },
                  "isOptional": true
                }
              ],
              "name": "normalizeStruts"
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.Padded:interface",
              "docComment": "/**\n * An object with a possibly zero padding at every direction and a strut for each such padding: a pair of _vertical_ struts for the _top_ and _bottom_, and a pair of _horizontal_ struts for the _left_ and _right_.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface Padded "
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "releaseTag": "Public",
              "name": "Padded",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.Padded#pad:member",
                  "docComment": "/**\n * How wide/tall should padding be in every direction?\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "pad: "
                    },
                    {
                      "kind": "Reference",
                      "text": "DirectedPad",
                      "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "pad",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.Padded#padStruts:member",
                  "docComment": "/**\n * With what do we fill available pad space in every direction?\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "padStruts: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Struts",
                      "canonicalReference": "effect-tree!Draw.Struts:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "padStruts",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.padding:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "padding: (top: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ", right?: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ", bottom?: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ", left?: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "DirectedPad",
                  "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                }
              ],
              "fileUrlPath": "src/draw/parts/pad.ts",
              "returnTypeTokenRange": {
                "startIndex": 9,
                "endIndex": 10
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "top",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "right",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": true
                },
                {
                  "parameterName": "bottom",
                  "parameterTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 6
                  },
                  "isOptional": true
                },
                {
                  "parameterName": "left",
                  "parameterTypeTokenRange": {
                    "startIndex": 7,
                    "endIndex": 8
                  },
                  "isOptional": true
                }
              ],
              "name": "padding"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Part:type",
              "docComment": "/**\n * A rectangular block of glyphs. Rectangular only in that it appears as a rectangle on a terminal. There are four types of parts, with the last two being recursive:\n *\n * 1. The {@link Empty}. 2. The {@link Text} part is used for a single line of text. 3. The {@link Row} part is used for a row of parts. 4. The {@link Column} part is used for a column of parts.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Part = "
                },
                {
                  "kind": "Reference",
                  "text": "Empty",
                  "canonicalReference": "effect-tree!Draw.Empty:type"
                },
                {
                  "kind": "Content",
                  "text": " | "
                },
                {
                  "kind": "Reference",
                  "text": "Text",
                  "canonicalReference": "effect-tree!Draw.Text:type"
                },
                {
                  "kind": "Content",
                  "text": " | "
                },
                {
                  "kind": "Reference",
                  "text": "Row",
                  "canonicalReference": "effect-tree!Draw.Row:type"
                },
                {
                  "kind": "Content",
                  "text": " | "
                },
                {
                  "kind": "Reference",
                  "text": "Column",
                  "canonicalReference": "effect-tree!Draw.Column:type"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "releaseTag": "Public",
              "name": "Part",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 8
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.partCata:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "partCata: <A>(folder: "
                },
                {
                  "kind": "Reference",
                  "text": "PartFolder",
                  "canonicalReference": "effect-tree!Draw.PartFolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "((part: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") => A)"
                }
              ],
              "fileUrlPath": "src/draw/part/fold.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "folder",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "partCata"
            },
            {
              "kind": "Namespace",
              "canonicalReference": "effect-tree!Draw.PartF:namespace",
              "docComment": "",
              "excerptTokens": [],
              "fileUrlPath": "src/draw.ts",
              "releaseTag": "None",
              "name": "PartF",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.columnF:function(1)",
                  "docComment": "/**\n * @category drawing  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "columnF: (hAligned: "
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontallyAligned",
                      "canonicalReference": "effect-tree!Draw.HorizontallyAligned:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "<A>(cells: A[]) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "ColumnF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.ColumnF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/data.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "hAligned",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "columnF"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.ColumnF:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "ColumnF: <A>(args: "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    readonly cells: A[];\n    readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n}"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    readonly _tag: \"ColumnF\";\n    readonly cells: A[];\n    readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n}"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 9,
                    "endIndex": 16
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "args",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 8
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "ColumnF"
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Draw.PartF.ColumnF:type",
                  "docComment": "/**\n * The non-recursive version of the {@link Column} {@link Part}.  @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type ColumnF<A> = "
                    },
                    {
                      "kind": "Reference",
                      "text": "TaggedEnum.Value",
                      "canonicalReference": "effect!TaggedEnum.Value:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>, 'ColumnF'>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "releaseTag": "Public",
                  "name": "ColumnF",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Draw.PartF.ColumnFData:interface",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface ColumnFData<A> extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontallyAligned",
                      "canonicalReference": "effect-tree!Draw.HorizontallyAligned:interface"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "releaseTag": "Public",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "ColumnFData",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Draw.PartF.ColumnFData#cells:member",
                      "docComment": "",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "cells: "
                        },
                        {
                          "kind": "Content",
                          "text": "A[]"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": false,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "cells",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      }
                    }
                  ],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 2
                    }
                  ]
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Draw.PartF.Covariant:var",
                  "docComment": "/**\n * `Covariant` instance for {@link PartF}.  @category drawing  @category instances\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "Covariant: "
                    },
                    {
                      "kind": "Reference",
                      "text": "CO.Covariant",
                      "canonicalReference": "@effect/typeclass!Covariant:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartFTypeLambda",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartFTypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/instances.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "Covariant",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.EmptyF:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "EmptyF: <A>(args: "
                    },
                    {
                      "kind": "Content",
                      "text": "void"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    readonly _tag: \"EmptyF\";\n}"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "args",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "EmptyF"
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Draw.PartF.EmptyF:type",
                  "docComment": "/**\n * The non-recursive version of the {@link Empty} {@link Part}.  @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type EmptyF = "
                    },
                    {
                      "kind": "Reference",
                      "text": "TaggedEnum.Value",
                      "canonicalReference": "effect!TaggedEnum.Value:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<unknown>, 'EmptyF'>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "releaseTag": "Public",
                  "name": "EmptyF",
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Draw.PartF.emptyF:var",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "emptyF: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EmptyF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.EmptyF:type"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/data.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "emptyF",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Draw.PartF.equalsFail:var",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "equalsFail: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Effect.Effect",
                      "canonicalReference": "effect!Effect:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<void, undefined>"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/Equivalence.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "equalsFail",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Draw.PartF.equalsSuccess:var",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "equalsSuccess: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Effect.Effect",
                      "canonicalReference": "effect!Effect:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<void, undefined>"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/Equivalence.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "equalsSuccess",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.getColumnFEqualsE:function(1)",
                  "docComment": "/**\n * @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getColumnFEqualsE: <A>(equalsA: "
                    },
                    {
                      "kind": "Content",
                      "text": "(self: A, that: A) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Effect.Effect",
                      "canonicalReference": "effect!Effect:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<void, undefined>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "((self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ColumnF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.ColumnF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>, that: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ColumnF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.ColumnF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Effect.Effect",
                      "canonicalReference": "effect!Effect:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<void, undefined>)"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/Equivalence.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 12
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "equalsA",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 4
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getColumnFEqualsE"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.getEquivalence:function(1)",
                  "docComment": "/**\n * Build an [Equivalence](https://effect-ts.github.io/effect/effect/Equivalence.ts.html) for a {@link PartF} from an equivalence of its underlying type.  @category drawing  @category instances  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getEquivalence: <A>(equalsA: "
                    },
                    {
                      "kind": "Reference",
                      "text": "EQ.Equivalence",
                      "canonicalReference": "effect!Equivalence:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "EQ.Equivalence",
                      "canonicalReference": "effect!Equivalence:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/Equivalence.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "equalsA",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getEquivalence"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.getRowFEqualsE:function(1)",
                  "docComment": "/**\n * @category internal  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "getRowFEqualsE: <A>(equalsA: "
                    },
                    {
                      "kind": "Content",
                      "text": "(self: A, that: A) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Effect.Effect",
                      "canonicalReference": "effect!Effect:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<void, undefined>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "((self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "RowF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.RowF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>, that: "
                    },
                    {
                      "kind": "Reference",
                      "text": "RowF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.RowF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "Effect.Effect",
                      "canonicalReference": "effect!Effect:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<void, undefined>)"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/Equivalence.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 12
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "equalsA",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 4
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "getRowFEqualsE"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Draw.PartF.imap:var",
                  "docComment": "/**\n * `Covariant` instance for {@link PartF}.  @category drawing  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "imap: "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    <A, B>(to: (a: A) => B, from: (b: B) => A): <R, O, E>(self: {\n        readonly _tag: \"EmptyF\";\n    } | {\n        readonly _tag: \"TextF\";\n        readonly show: string;\n    } | {\n        readonly _tag: \"RowF\";\n        readonly cells: A[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly vAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticalAlignment",
                      "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly top: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly bottom: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    } | {\n        readonly _tag: \"ColumnF\";\n        readonly cells: A[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    }) => {\n        readonly _tag: \"EmptyF\";\n    } | {\n        readonly _tag: \"TextF\";\n        readonly show: string;\n    } | {\n        readonly _tag: \"RowF\";\n        readonly cells: B[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly vAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticalAlignment",
                      "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly top: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly bottom: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    } | {\n        readonly _tag: \"ColumnF\";\n        readonly cells: B[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    };\n    <R, O, E, A, B>(self: {\n        readonly _tag: \"EmptyF\";\n    } | {\n        readonly _tag: \"TextF\";\n        readonly show: string;\n    } | {\n        readonly _tag: \"RowF\";\n        readonly cells: A[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly vAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticalAlignment",
                      "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly top: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly bottom: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    } | {\n        readonly _tag: \"ColumnF\";\n        readonly cells: A[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    }, to: (a: A) => B, from: (b: B) => A): {\n        readonly _tag: \"EmptyF\";\n    } | {\n        readonly _tag: \"TextF\";\n        readonly show: string;\n    } | {\n        readonly _tag: \"RowF\";\n        readonly cells: B[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly vAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticalAlignment",
                      "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly top: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly bottom: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    } | {\n        readonly _tag: \"ColumnF\";\n        readonly cells: B[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    };\n}"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/instances.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "imap",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 74
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.isColumnF:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "isColumnF: <A>(self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "self",
                      "canonicalReference": "effect-tree!~self"
                    },
                    {
                      "kind": "Content",
                      "text": " is "
                    },
                    {
                      "kind": "Reference",
                      "text": "ColumnF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.ColumnF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "self",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "isColumnF"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.isEmptyF:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "isEmptyF: <A>(self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "self",
                      "canonicalReference": "effect-tree!~self"
                    },
                    {
                      "kind": "Content",
                      "text": " is "
                    },
                    {
                      "kind": "Reference",
                      "text": "EmptyF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.EmptyF:type"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 7
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "self",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "isEmptyF"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.isPartFOf:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "isPartFOf: <Tag extends "
                    },
                    {
                      "kind": "Content",
                      "text": "\"EmptyF\" | \"TextF\" | \"RowF\" | \"ColumnF\""
                    },
                    {
                      "kind": "Content",
                      "text": ">(tag: "
                    },
                    {
                      "kind": "Content",
                      "text": "Tag"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    <T extends {\n        readonly _tag: \"EmptyF\";\n    } | {\n        readonly _tag: \"TextF\";\n        readonly show: string;\n    } | {\n        readonly _tag: \"RowF\";\n        readonly cells: any[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly vAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticalAlignment",
                      "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly top: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly bottom: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    } | {\n        readonly _tag: \"ColumnF\";\n        readonly cells: any[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    }>(u: T): "
                    },
                    {
                      "kind": "Reference",
                      "text": "u",
                      "canonicalReference": "effect-tree!~u"
                    },
                    {
                      "kind": "Content",
                      "text": " is T & {\n        readonly _tag: Tag;\n    };\n    (u: unknown): "
                    },
                    {
                      "kind": "Reference",
                      "text": "u",
                      "canonicalReference": "effect-tree!~u"
                    },
                    {
                      "kind": "Content",
                      "text": " is "
                    },
                    {
                      "kind": "Reference",
                      "text": "Extract",
                      "canonicalReference": "!Extract:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<{\n        readonly _tag: \"EmptyF\";\n    }, {\n        readonly _tag: Tag;\n    }> | "
                    },
                    {
                      "kind": "Reference",
                      "text": "Extract",
                      "canonicalReference": "!Extract:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<{\n        readonly _tag: \"TextF\";\n        readonly show: string;\n    }, {\n        readonly _tag: Tag;\n    }> | "
                    },
                    {
                      "kind": "Reference",
                      "text": "Extract",
                      "canonicalReference": "!Extract:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<{\n        readonly _tag: \"RowF\";\n        readonly cells: unknown[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly vAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticalAlignment",
                      "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly top: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly bottom: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    }, {\n        readonly _tag: Tag;\n    }> | "
                    },
                    {
                      "kind": "Reference",
                      "text": "Extract",
                      "canonicalReference": "!Extract:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<{\n        readonly _tag: \"ColumnF\";\n        readonly cells: unknown[];\n        readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n        readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    }, {\n        readonly _tag: Tag;\n    }>;\n}"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 54
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "tag",
                      "parameterTypeTokenRange": {
                        "startIndex": 3,
                        "endIndex": 4
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "Tag",
                      "constraintTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "isPartFOf"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.isRowF:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "isRowF: <A>(self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "self",
                      "canonicalReference": "effect-tree!~self"
                    },
                    {
                      "kind": "Content",
                      "text": " is "
                    },
                    {
                      "kind": "Reference",
                      "text": "RowF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.RowF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "self",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "isRowF"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.isTextF:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "isTextF: <A>(self: "
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "self",
                      "canonicalReference": "effect-tree!~self"
                    },
                    {
                      "kind": "Content",
                      "text": " is "
                    },
                    {
                      "kind": "Reference",
                      "text": "TextF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.TextF:type"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 7
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "self",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "isTextF"
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Draw.PartF.map:var",
                  "docComment": "/**\n * @category drawing  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "map: "
                    },
                    {
                      "kind": "Reference",
                      "text": "CO.Covariant",
                      "canonicalReference": "@effect/typeclass!Covariant:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartFTypeLambda",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartFTypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">['map']"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/instances.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "map",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.matchPartF:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "matchPartF: <A, R>(empty: "
                    },
                    {
                      "kind": "Content",
                      "text": "R"
                    },
                    {
                      "kind": "Content",
                      "text": ", text: "
                    },
                    {
                      "kind": "Content",
                      "text": "(s: string) => R"
                    },
                    {
                      "kind": "Content",
                      "text": ", row: "
                    },
                    {
                      "kind": "Content",
                      "text": "(row: "
                    },
                    {
                      "kind": "Reference",
                      "text": "RowF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.RowF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>) => R"
                    },
                    {
                      "kind": "Content",
                      "text": ", column: "
                    },
                    {
                      "kind": "Content",
                      "text": "(column: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ColumnF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.ColumnF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>) => R"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "((part: "
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>) => R)"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 13,
                    "endIndex": 16
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "empty",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "text",
                      "parameterTypeTokenRange": {
                        "startIndex": 3,
                        "endIndex": 4
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "row",
                      "parameterTypeTokenRange": {
                        "startIndex": 5,
                        "endIndex": 8
                      },
                      "isOptional": false
                    },
                    {
                      "parameterName": "column",
                      "parameterTypeTokenRange": {
                        "startIndex": 9,
                        "endIndex": 12
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    },
                    {
                      "typeParameterName": "R",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "matchPartF"
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Draw.PartF.PartF:type",
                  "docComment": "/**\n * A filled rectangular block of characters used by the tree drawing routines as an output type. This is the non-recursive version of {@link Part}.  @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type PartF<A> = "
                    },
                    {
                      "kind": "Reference",
                      "text": "TaggedEnum",
                      "canonicalReference": "effect!TaggedEnum:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<{\n    EmptyF: {};\n    TextF: {\n        show: string;\n    };\n    RowF: "
                    },
                    {
                      "kind": "Reference",
                      "text": "RowFData",
                      "canonicalReference": "effect-tree!Draw.PartF_2.RowFData:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>;\n    ColumnF: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ColumnFData",
                      "canonicalReference": "effect-tree!Draw.PartF_2.ColumnFData:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>;\n}>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "releaseTag": "Public",
                  "name": "PartF",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 7
                  }
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Draw.PartF.PartFDefinition:interface",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface PartFDefinition extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "TaggedEnum.WithGenerics",
                      "canonicalReference": "effect!TaggedEnum.WithGenerics:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<1>"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "releaseTag": "Public",
                  "name": "PartFDefinition",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Draw.PartF.PartFDefinition#taggedEnum:member",
                      "docComment": "",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "readonly taggedEnum: "
                        },
                        {
                          "kind": "Reference",
                          "text": "PartF",
                          "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                        },
                        {
                          "kind": "Content",
                          "text": "<this['A']>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": true,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "taggedEnum",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      }
                    }
                  ],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 3
                    }
                  ]
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Draw.PartF.PartFTypeLambda:interface",
                  "docComment": "/**\n * A type lambda for the non-recursive part.  @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface PartFTypeLambda extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "HKT.TypeLambda",
                      "canonicalReference": "effect!TypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "releaseTag": "Public",
                  "name": "PartFTypeLambda",
                  "preserveMemberOrder": false,
                  "members": [
                    {
                      "kind": "PropertySignature",
                      "canonicalReference": "effect-tree!Draw.PartF.PartFTypeLambda#type:member",
                      "docComment": "",
                      "excerptTokens": [
                        {
                          "kind": "Content",
                          "text": "readonly type: "
                        },
                        {
                          "kind": "Reference",
                          "text": "PartF",
                          "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                        },
                        {
                          "kind": "Content",
                          "text": "<this['Target']>"
                        },
                        {
                          "kind": "Content",
                          "text": ";"
                        }
                      ],
                      "isReadonly": true,
                      "isOptional": false,
                      "releaseTag": "Public",
                      "name": "type",
                      "propertyTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      }
                    }
                  ],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 2
                    }
                  ]
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.rowF:function(1)",
                  "docComment": "/**\n * @category drawing  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "rowF: (aligned: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Aligned",
                      "canonicalReference": "effect-tree!Draw.Aligned:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "<A>(cells: A[]) => "
                    },
                    {
                      "kind": "Reference",
                      "text": "RowF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.RowF:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/data.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 6
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "aligned",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "rowF"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.RowF:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "RowF: <A>(args: "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    readonly cells: A[];\n    readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly vAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticalAlignment",
                      "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly top: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly bottom: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n}"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    readonly _tag: \"RowF\";\n    readonly cells: A[];\n    readonly hAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HorizontalAlignment",
                      "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly left: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly right: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "HStrut",
                      "canonicalReference": "effect-tree!Draw.HStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly vAlign: import(\"../align.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticalAlignment",
                      "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly top: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n    readonly bottom: import(\"../struts.js\")."
                    },
                    {
                      "kind": "Reference",
                      "text": "VStrut",
                      "canonicalReference": "effect-tree!Draw.VStrut:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";\n}"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 15,
                    "endIndex": 28
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "args",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 14
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "RowF"
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Draw.PartF.RowF:type",
                  "docComment": "/**\n * The non-recursive version of the {@link Row} {@link Part}.  @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type RowF<A> = "
                    },
                    {
                      "kind": "Reference",
                      "text": "TaggedEnum.Value",
                      "canonicalReference": "effect!TaggedEnum.Value:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>, 'RowF'>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "releaseTag": "Public",
                  "name": "RowF",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Interface",
                  "canonicalReference": "effect-tree!Draw.PartF.RowFData:interface",
                  "docComment": "/**\n * @category internal\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export interface RowFData<A> extends "
                    },
                    {
                      "kind": "Reference",
                      "text": "ColumnFData",
                      "canonicalReference": "effect-tree!Draw.PartF_2.ColumnFData:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ", "
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticallyAligned",
                      "canonicalReference": "effect-tree!Draw.VerticallyAligned:interface"
                    },
                    {
                      "kind": "Content",
                      "text": " "
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "releaseTag": "Public",
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "RowFData",
                  "preserveMemberOrder": false,
                  "members": [],
                  "extendsTokenRanges": [
                    {
                      "startIndex": 1,
                      "endIndex": 3
                    },
                    {
                      "startIndex": 4,
                      "endIndex": 5
                    }
                  ]
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.textF:function(1)",
                  "docComment": "/**\n * @category drawing  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "textF: (show: "
                    },
                    {
                      "kind": "Content",
                      "text": "string"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Reference",
                      "text": "TextF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.TextF:type"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/data.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "show",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "name": "textF"
                },
                {
                  "kind": "Function",
                  "canonicalReference": "effect-tree!Draw.PartF.TextF:function(1)",
                  "docComment": "/**\n * @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "TextF: <A>(args: "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    readonly show: string;\n}"
                    },
                    {
                      "kind": "Content",
                      "text": ") => "
                    },
                    {
                      "kind": "Content",
                      "text": "{\n    readonly _tag: \"TextF\";\n    readonly show: string;\n}"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "returnTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "args",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 2
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ],
                  "name": "TextF"
                },
                {
                  "kind": "TypeAlias",
                  "canonicalReference": "effect-tree!Draw.PartF.TextF:type",
                  "docComment": "/**\n * The non-recursive version of the {@link Text} {@link Part}.  @category drawing\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "export type TextF = "
                    },
                    {
                      "kind": "Reference",
                      "text": "TaggedEnum.Value",
                      "canonicalReference": "effect!TaggedEnum.Value:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartF",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<unknown>, 'TextF'>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/types.ts",
                  "releaseTag": "Public",
                  "name": "TextF",
                  "typeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Draw.PartF.Traversable:var",
                  "docComment": "/**\n * `Traversable` instance for {@link PartF}.  @category drawing  @category instances\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "Traversable: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TA.Traversable",
                      "canonicalReference": "@effect/typeclass!Traversable:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartFTypeLambda",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartFTypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/instances.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "Traversable",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                },
                {
                  "kind": "Variable",
                  "canonicalReference": "effect-tree!Draw.PartF.traverse:var",
                  "docComment": "/**\n * `Covariant` instance for {@link PartF}.  @category drawing  @function\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "traverse: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TA.Traversable",
                      "canonicalReference": "@effect/typeclass!Traversable:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "PartFTypeLambda",
                      "canonicalReference": "effect-tree!Draw.PartF_2.PartFTypeLambda:interface"
                    },
                    {
                      "kind": "Content",
                      "text": ">['traverse']"
                    }
                  ],
                  "fileUrlPath": "src/draw/partF/instances.ts",
                  "isReadonly": true,
                  "releaseTag": "Public",
                  "name": "traverse",
                  "variableTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  }
                }
              ]
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.PartFolder:type",
              "docComment": "/**\n * A function of the type `PartF<A> ⇒ A`.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type PartFolder<A> = "
                },
                {
                  "kind": "Reference",
                  "text": "Algebra",
                  "canonicalReference": "effect-ts-folds!Algebra:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "PartFTypeLambda",
                  "canonicalReference": "effect-tree!Draw.PartF_2.PartFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ", A>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/part/fold.ts",
              "releaseTag": "Public",
              "name": "PartFolder",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.prefixGlyph:function(1)",
              "docComment": "/**\n * Given a {@link Theme} and a {@link GlyphRole}, returns a function that will prefix a string with the correct glyph.\n *\n * @param theme - The {@link Theme} to use.\n *\n * @returns The prefixed string.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "prefixGlyph: (theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(role: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "theme",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "prefixGlyph"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.prefixText:function(1)",
              "docComment": "/**\n * Combine two text parts horizontally placing the first to the right of the second.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "prefixText: (prefix: "
                },
                {
                  "kind": "Reference",
                  "text": "Text",
                  "canonicalReference": "effect-tree!Draw.Text:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Text",
                  "canonicalReference": "effect-tree!Draw.Text:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "prefix",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "prefixText"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.repeatText:var",
              "docComment": "/**\n * A text part that is `width` wide composed entirely of the given string repeated or sliced.\n *\n * @example\n *\n * import {Draw} from 'effect-tree'\n *\n * const repeated = Draw.repeatText.rest(3, 'A') // ‘AAA’  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "repeatText: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (repeat: string): (width: number) => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (width: number, repeat: string): "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/atoms.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "repeatText",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.replaceBorderElbow:var",
              "docComment": "/**\n * Replace the border elbow at a direction in the given set.\n *\n * @param set - The border set to change.\n *\n * @param direction - Corner direction to change.\n *\n * @param glyph - New glyph.\n *\n * @returns Updated border set.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "replaceBorderElbow: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (set: "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ", direction: "
                },
                {
                  "kind": "Reference",
                  "text": "CornerDirection",
                  "canonicalReference": "effect-tree!Draw.CornerDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "CornerDirection",
                  "canonicalReference": "effect-tree!Draw.CornerDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ">;\n    named: (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "CornerDirection",
                  "canonicalReference": "effect-tree!Draw.CornerDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", from: "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSetName",
                  "canonicalReference": "effect-tree!Draw.ElbowSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/draw/glyph/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "replaceBorderElbow",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 22
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.replaceBorderLine:var",
              "docComment": "/**\n * Replace the border line at a direction in the given set.\n *\n * @param set - The border set to change.\n *\n * @param direction - Line direction to change.\n *\n * @param glyph - New glyph.\n *\n * @returns Updated border set.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "replaceBorderLine: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (set: "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ", direction: "
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ">;\n    named: (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", from: "
                },
                {
                  "kind": "Reference",
                  "text": "LineSetName",
                  "canonicalReference": "effect-tree!Draw.LineSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/draw/glyph/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "replaceBorderLine",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 22
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.replaceElbow:var",
              "docComment": "/**\n * Given a direction and a glyph, replaces the elbow at this direction in a given elbow set with the given glyph and returns the new elbow set.\n *\n * At the key `named` you will find a version that does the same but accepts a _name_ of an elbow set instead of an elbow set.\n *\n * @param set - Elbow set to change.\n *\n * @param direction - A {@link CornerDirection} of the glyph to be changed.\n *\n * @param glyph - String of new glyph.\n *\n * @returns Updated elbow set.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "replaceElbow: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (set: "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSet",
                  "canonicalReference": "effect-tree!Draw.ElbowSet:type"
                },
                {
                  "kind": "Content",
                  "text": ", direction: "
                },
                {
                  "kind": "Reference",
                  "text": "CornerDirection",
                  "canonicalReference": "effect-tree!Draw.CornerDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSet",
                  "canonicalReference": "effect-tree!Draw.ElbowSet:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "CornerDirection",
                  "canonicalReference": "effect-tree!Draw.CornerDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSet",
                  "canonicalReference": "effect-tree!Draw.ElbowSet:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n    named: (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "CornerDirection",
                  "canonicalReference": "effect-tree!Draw.CornerDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string) => (name: "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSetName",
                  "canonicalReference": "effect-tree!Draw.ElbowSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "ElbowSet",
                  "canonicalReference": "effect-tree!Draw.ElbowSet:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/glyph/elbows.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "replaceElbow",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 20
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.replaceLine:var",
              "docComment": "/**\n * Given a direction and a glyph, replaces the line at this direction in a given line set set with the given glyph and returns the new line set.\n *\n * At the key `named` you will find a version that does the same but accepts a _name_ of a line set instead of a line set.\n *\n * @param set - Line set to change.\n *\n * @param direction - A {@link Direction} of the glyph to be changed.\n *\n * @param glyph - String of new glyph.\n *\n * @returns Updated line set.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "replaceLine: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (set: "
                },
                {
                  "kind": "Reference",
                  "text": "LineSet",
                  "canonicalReference": "effect-tree!Draw.LineSet:type"
                },
                {
                  "kind": "Content",
                  "text": ", direction: "
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "LineSet",
                  "canonicalReference": "effect-tree!Draw.LineSet:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "LineSet",
                  "canonicalReference": "effect-tree!Draw.LineSet:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n    named: (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string) => (name: "
                },
                {
                  "kind": "Reference",
                  "text": "LineSetName",
                  "canonicalReference": "effect-tree!Draw.LineSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "LineSet",
                  "canonicalReference": "effect-tree!Draw.LineSet:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/glyph/lines.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "replaceLine",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 20
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.replaceTee:var",
              "docComment": "/**\n * Given a direction and a glyph, replaces the tee at this direction in a given tee set with the given glyph and returns the new tee set.\n *\n * At the key `named` you will find a version that does the same but accepts a _name_ of a tee set instead of an tee set.\n *\n * @param set - Tee set to change.\n *\n * @param direction - A {@link Direction} of the glyph to be changed.\n *\n * @param glyph - String of new glyph.\n *\n * @returns Updated tee set.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "replaceTee: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (set: "
                },
                {
                  "kind": "Reference",
                  "text": "TeeSet",
                  "canonicalReference": "effect-tree!Draw.TeeSet:type"
                },
                {
                  "kind": "Content",
                  "text": ", direction: "
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "TeeSet",
                  "canonicalReference": "effect-tree!Draw.TeeSet:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TeeSet",
                  "canonicalReference": "effect-tree!Draw.TeeSet:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n    named: (direction: "
                },
                {
                  "kind": "Reference",
                  "text": "Direction",
                  "canonicalReference": "effect-tree!Draw.Direction:type"
                },
                {
                  "kind": "Content",
                  "text": ", glyph: string) => (name: "
                },
                {
                  "kind": "Reference",
                  "text": "TeeSetName",
                  "canonicalReference": "effect-tree!Draw.TeeSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "TeeSet",
                  "canonicalReference": "effect-tree!Draw.TeeSet:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/glyph/tees.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "replaceTee",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 20
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.Row:function(1)",
              "docComment": "/**\n * Combine parts horizontally.\n *\n * @returns A new part that is composed of the given parts.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Row: (aligned: "
                },
                {
                  "kind": "Reference",
                  "text": "Aligned",
                  "canonicalReference": "effect-tree!Draw.Aligned:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "((cells: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": "[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "Row",
                  "canonicalReference": "effect-tree!Draw.Row:type"
                },
                {
                  "kind": "Content",
                  "text": ")"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "aligned",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "Row"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Row:type",
              "docComment": "/**\n * A rectangular row of parts that is horizontally and vertically aligned and possibly has horizontal and vertical struts to fill in empty space on alignment. The non-recursive version is {@link RowF}.\n *\n * The expanded type:\n * ```ts\n * {\n *   unfixed: {\n *     cells:  A[]\n *     hAlign: HorizontalAlignment\n *     vAlign: HorizontalAlignment\n *     top:    VStrut\n *     right:  HStrut\n *     bottom: VStrut\n *     left:   HStrut\n *   }\n * }\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Row = "
                },
                {
                  "kind": "Content",
                  "text": "{\n    unfixed: "
                },
                {
                  "kind": "Reference",
                  "text": "RowF",
                  "canonicalReference": "effect-tree!Draw.PartF_2.RowF:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n} & "
                },
                {
                  "kind": "Reference",
                  "text": "Fix",
                  "canonicalReference": "effect-ts-folds!Fix:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "PartFTypeLambda",
                  "canonicalReference": "effect-tree!Draw.PartF_2.PartFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "releaseTag": "Public",
              "name": "Row",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.row:var",
              "docComment": "/**\n * Combine parts horizontally.\n *\n * The 1st cell will be drawn at the left of the row, the final at the bottom.\n *\n * @returns A new part that is composed of the given parts.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "row: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (vAlign?: "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": "): (hAlign?: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "BuildRow",
                  "canonicalReference": "effect-tree!Draw.BuildRow:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n} & "
                },
                {
                  "kind": "Reference",
                  "text": "BuildAlignedRow",
                  "canonicalReference": "effect-tree!Draw.BuildAlignedRow:type"
                }
              ],
              "fileUrlPath": "src/draw/part/row.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "row",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 9
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.setBoxNodesFormatter:var",
              "docComment": "/**\n * Set the theme formatter to draw boxes around nodes.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "setBoxNodesFormatter: "
                },
                {
                  "kind": "Reference",
                  "text": "Function.EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/variants/boxedNodes.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "setBoxNodesFormatter",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.setFormatter:function(1)",
              "docComment": "/**\n * Set the `formatter` of a theme.\n *\n * @param formatter - New formatter.\n *\n * @returns Theme with updated formatter.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "setFormatter: (formatter: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "formatter",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "name": "setFormatter"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.setIndents:function(1)",
              "docComment": "/**\n * Set the indent count of a tree theme.\n *\n * @param indents - Number of indents from parent to child.\n *\n * @returns Theme with updated indent count.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "setIndents: (indents: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "indents",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "setIndents"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.setSpacing:function(1)",
              "docComment": "/**\n * Set the vertical spacing of a tree theme.\n *\n * @param spacing - Number of lines of vertical space between tree nodes.\n *\n * @returns Theme with updated vertical spacing.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "setSpacing: (spacing: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "spacing",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "setSpacing"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.showAlignment:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showAlignment: (align: "
                },
                {
                  "kind": "Reference",
                  "text": "Alignment",
                  "canonicalReference": "effect-tree!Draw.Alignment:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "align",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "showAlignment"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.showAlignments:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showAlignments: ({ hAlign, vAlign, }: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    hAlign: "
                },
                {
                  "kind": "Reference",
                  "text": "HorizontalAlignment",
                  "canonicalReference": "effect-tree!Draw.HorizontalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    vAlign: "
                },
                {
                  "kind": "Reference",
                  "text": "VerticalAlignment",
                  "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ hAlign, vAlign, }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 6
                  },
                  "isOptional": false
                }
              ],
              "name": "showAlignments"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.showHStrut:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showHStrut: ({ prefix, body, suffix }: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ prefix, body, suffix }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "showHStrut"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.showHStruts:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showHStruts: ({ right, left }: "
                },
                {
                  "kind": "Reference",
                  "text": "HStruts",
                  "canonicalReference": "effect-tree!Draw.HStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ right, left }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "showHStruts"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.showPart:function(1)",
              "docComment": "/**\n * @category internal  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showPart: (part: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/part/show.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "part",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "showPart"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.showPartAlgebra:var",
              "docComment": "/**\n * @category internal  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showPartAlgebra: "
                },
                {
                  "kind": "Reference",
                  "text": "PartFolder",
                  "canonicalReference": "effect-tree!Draw.PartFolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/draw/part/show.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "showPartAlgebra",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.showStrut:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showStrut: (strut: "
                },
                {
                  "kind": "Reference",
                  "text": "BaseStrut",
                  "canonicalReference": "effect-tree!Draw.BaseStrut:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Axis",
                  "canonicalReference": "effect-tree!Draw.Axis:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 6,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "strut",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  },
                  "isOptional": false
                }
              ],
              "name": "showStrut"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.showStruts:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showStruts: ({ top, right, bottom, left }: "
                },
                {
                  "kind": "Reference",
                  "text": "Struts",
                  "canonicalReference": "effect-tree!Draw.Struts:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ top, right, bottom, left }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "showStruts"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.showVStrut:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showVStrut: ({ prefix, body, suffix }: "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ prefix, body, suffix }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "showVStrut"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.showVStruts:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "showVStruts: ({ top, bottom }: "
                },
                {
                  "kind": "Reference",
                  "text": "VStruts",
                  "canonicalReference": "effect-tree!Draw.VStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "string"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ top, bottom }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "showVStruts"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.spacePad:var",
              "docComment": "/**\n * Pad a part with spaces in all directions.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "spacePad: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ", pad: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "DirectedPad",
                  "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                },
                {
                  "kind": "Content",
                  "text": ">): "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    ({ top, right, bottom, left }: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "DirectedPad",
                  "canonicalReference": "effect-tree!Draw.DirectedPad:type"
                },
                {
                  "kind": "Content",
                  "text": ">): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/atoms.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "spacePad",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 18
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.stackText:var",
              "docComment": "/**\n * A column part that joins the given string list vertically.\n *\n * At the key `rest` you will find a version that accepts the strings as a list of arguments.\n *\n * @example\n *\n * import {Draw} from 'effect-tree'\n *\n * const abcTower = Draw.stackText.rest('A', 'B', 'C') // ‘A // B // C’  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "stackText: "
                },
                {
                  "kind": "Content",
                  "text": "((xs: string[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") & {\n    rest: (...xs: string[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/atoms.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "stackText",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.StringDraw:interface",
              "docComment": "/**\n * A function that draws string trees into a non-empty array of string rows. Defined as {@link BaseDraw} fixed on `string` input and on output of `NonEmptyArray<string>`.\n *\n * A function of the type:\n * ```ts\n * { (self: Tree<string>): NonEmptyArray<string> }\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface StringDraw extends "
                },
                {
                  "kind": "Reference",
                  "text": "BaseDraw",
                  "canonicalReference": "effect-tree!Draw.BaseDraw:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string, "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>>"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/draw/tree/draw.ts",
              "releaseTag": "Public",
              "name": "StringDraw",
              "preserveMemberOrder": false,
              "members": [],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 5
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.StrutEquivalence:var",
              "docComment": "/**\n * An [Equivalence](https://effect-ts.github.io/effect/effect/Equivalence.ts.html) for values of the {@link BaseStrut} type.  @category drawing  @category instances  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "StrutEquivalence: "
                },
                {
                  "kind": "Reference",
                  "text": "EQ.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "BaseStrut",
                  "canonicalReference": "effect-tree!Draw.BaseStrut:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Axis",
                  "canonicalReference": "effect-tree!Draw.Axis:type"
                },
                {
                  "kind": "Content",
                  "text": ">>"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "StrutEquivalence",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.Struts:function(1)",
              "docComment": "/**\n * Create {@link Struts} from horizontal and vertical struts. If only a pair is given it will be used for all directions. If none are given returns the default struts of empty line and space.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Struts: (top?: "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ", right?: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ", bottom?: "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ", left?: "
                },
                {
                  "kind": "Reference",
                  "text": "HStrut",
                  "canonicalReference": "effect-tree!Draw.HStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Struts",
                  "canonicalReference": "effect-tree!Draw.Struts:interface"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 9,
                "endIndex": 10
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "top",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": true
                },
                {
                  "parameterName": "right",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": true
                },
                {
                  "parameterName": "bottom",
                  "parameterTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 6
                  },
                  "isOptional": true
                },
                {
                  "parameterName": "left",
                  "parameterTypeTokenRange": {
                    "startIndex": 7,
                    "endIndex": 8
                  },
                  "isOptional": true
                }
              ],
              "name": "Struts"
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.Struts:interface",
              "docComment": "/**\n * A record of strut per direction: horizontal struts on the horizontal directions, and vertical ones on the vertical directions.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface Struts extends "
                },
                {
                  "kind": "Reference",
                  "text": "HStruts",
                  "canonicalReference": "effect-tree!Draw.HStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "VStruts",
                  "canonicalReference": "effect-tree!Draw.VStruts:type"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "releaseTag": "Public",
              "name": "Struts",
              "preserveMemberOrder": false,
              "members": [],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 2
                },
                {
                  "startIndex": 3,
                  "endIndex": 4
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.StrutsEquivalence:var",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "StrutsEquivalence: "
                },
                {
                  "kind": "Reference",
                  "text": "EQ.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Struts",
                  "canonicalReference": "effect-tree!Draw.Struts:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "StrutsEquivalence",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.suffixGlyph:function(1)",
              "docComment": "/**\n * Given a {@link Theme} and a {@link GlyphRole}, returns a function that will suffix a string with the correct glyph.\n *\n * @param theme - The {@link Theme} to use.\n *\n * @returns The suffixed string.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "suffixGlyph: (theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(role: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphRole",
                  "canonicalReference": "effect-tree!Draw.GlyphRole:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "theme",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "suffixGlyph"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.suffixText:function(1)",
              "docComment": "/**\n * Combine two text parts horizontally placing the first to the left of the second.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "suffixText: (suffix: "
                },
                {
                  "kind": "Reference",
                  "text": "Text",
                  "canonicalReference": "effect-tree!Draw.Text:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Text",
                  "canonicalReference": "effect-tree!Draw.Text:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "suffix",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "suffixText"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.tailBranch:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tailBranch: (theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part.Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/tree/atoms.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "theme",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "tailBranch"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.teeSet:function(1)",
              "docComment": "/**\n * Get a tee set by name.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "teeSet: (name: "
                },
                {
                  "kind": "Reference",
                  "text": "TeeSetName",
                  "canonicalReference": "effect-tree!Draw.TeeSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "TeeSet",
                  "canonicalReference": "effect-tree!Draw.TeeSet:type"
                }
              ],
              "fileUrlPath": "src/draw/glyph/tees.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "name",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "teeSet"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.TeeSet:type",
              "docComment": "/**\n * A record of line glyph per direction describing some style for tees.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type TeeSet = "
                },
                {
                  "kind": "Reference",
                  "text": "Directed",
                  "canonicalReference": "effect-tree!Draw.Directed:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/types.ts",
              "releaseTag": "Public",
              "name": "TeeSet",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.TeeSetName:type",
              "docComment": "/**\n * The type of a tee set name.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type TeeSetName = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "teeSetNames",
                  "canonicalReference": "effect-tree!Draw.teeSetNames:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/tees.ts",
              "releaseTag": "Public",
              "name": "TeeSetName",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.teeSetNames:var",
              "docComment": "/**\n * Names of all tee sets.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "teeSetNames: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"ascii\", \"double\", \"hDouble\", \"hThick\", \"solid\", \"space\", \"thick\", \"thin\", \"vDouble\", \"vThick\", \"vThickTop\", \"vThickBottom\"]"
                }
              ],
              "fileUrlPath": "src/draw/glyph/tees.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "teeSetNames",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.TeeSets:type",
              "docComment": "/**\n * A record of all tee sets. A tee set has a tee glyph defined for each tee direction. The tees are grouped into sets by style.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type TeeSets = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TeeSetName",
                  "canonicalReference": "effect-tree!Draw.TeeSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "TeeSet",
                  "canonicalReference": "effect-tree!Draw.TeeSet:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/glyph/tees.ts",
              "releaseTag": "Public",
              "name": "TeeSets",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.text:function(1)",
              "docComment": "/**\n * Build a part from a single line of text.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "text: (show: "
                },
                {
                  "kind": "Content",
                  "text": "string"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Text",
                  "canonicalReference": "effect-tree!Draw.Text:type"
                }
              ],
              "fileUrlPath": "src/draw/part/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "show",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "text"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Text:type",
              "docComment": "/**\n * A {@link Part} that displays a single line of text. The non-recursive version is {@link TextF}.\n *\n * The expanded type:\n * ```ts\n * {unfixed: {show: string}}\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Text = "
                },
                {
                  "kind": "Content",
                  "text": "{\n    unfixed: "
                },
                {
                  "kind": "Reference",
                  "text": "TextF",
                  "canonicalReference": "effect-tree!Draw.PartF_2.TextF:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n} & "
                },
                {
                  "kind": "Reference",
                  "text": "Fix",
                  "canonicalReference": "effect-ts-folds!Fix:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "PartFTypeLambda",
                  "canonicalReference": "effect-tree!Draw.PartF_2.PartFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "releaseTag": "Public",
              "name": "Text",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 8
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.Theme:interface",
              "docComment": "/**\n * A _tree theme_:\n *\n * - Maps drawing roles to actual glyphs and styles. For example, a theme could map the glyph role `top-left-elbow`, used when you need an elbow shape pointing top-left, to the glyph `┌`, while another could map it to the glyph `╭`. - Configures indent count. Indents used when moving from parent to child and set the horizontal spacing between adjacent tree levels. - Configures vertical spacing. Vertical spacing is added between nodes. - Can format nodes before drawing, for example to convert to string.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface Theme "
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "releaseTag": "Public",
              "name": "Theme",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.Theme#formatter:member",
                  "docComment": "/**\n * The formatting function can change the tree label before it is drawn.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "formatter: "
                    },
                    {
                      "kind": "Content",
                      "text": "(node: string) => string"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "formatter",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.Theme#glyphs:member",
                  "docComment": "/**\n * A map of glyph role to glyphs that will be used to compose the tree.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "glyphs: "
                    },
                    {
                      "kind": "Reference",
                      "text": "GlyphSet",
                      "canonicalReference": "effect-tree!Draw.GlyphSet:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "glyphs",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.Theme#indents:member",
                  "docComment": "/**\n * The number of times that the theme glyphs for the role `indent` will be repeated when indenting a part. Higher numbers increase the horizontal space between tree levels.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "indents: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "indents",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.Theme#spacing:member",
                  "docComment": "/**\n * The number of empty lines added between vertical nodes. A higher number increases table vertical spacing between nodes.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "spacing: "
                    },
                    {
                      "kind": "Content",
                      "text": "number"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "spacing",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.Theme:var",
              "docComment": "/**\n * Theme constructor.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Theme: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    ({ spacing, indents, glyphs, formatter, }: "
                },
                {
                  "kind": "Reference",
                  "text": "Partial",
                  "canonicalReference": "!Partial:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">): "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n    fromGlyphSet(glyphs?: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphSet",
                  "canonicalReference": "effect-tree!Draw.GlyphSet:type"
                },
                {
                  "kind": "Content",
                  "text": ", indents?: number, theme?: "
                },
                {
                  "kind": "Reference",
                  "text": "Omit",
                  "canonicalReference": "!Omit:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ", \"glyphs\" | \"indents\">): "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n    fromNamedGlyphSet(name?: "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphSetName",
                  "canonicalReference": "effect-tree!Draw.GlyphSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ", indents?: number, theme?: "
                },
                {
                  "kind": "Reference",
                  "text": "Omit",
                  "canonicalReference": "!Omit:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ", \"glyphs\" | \"indents\">): "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "Theme",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 24
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.Themed:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Themed = "
                },
                {
                  "kind": "Content",
                  "text": "(theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => string"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "releaseTag": "Public",
              "name": "Themed",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.ThemedPart:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type ThemedPart = "
                },
                {
                  "kind": "Content",
                  "text": "(theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "releaseTag": "Public",
              "name": "ThemedPart",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.themedTree:var",
              "docComment": "/**\n * Draw a tree as a 2D array of glyphs in the given theme.\n *\n * At the key `unlines` you will find a version that joins output into a string.\n *\n * You can get themes by name using the {@link getTheme | getTheme function}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "themedTree: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>, theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>;\n    (theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": "): (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>) => "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>;\n    unlines: (theme: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>) => string;\n}"
                }
              ],
              "fileUrlPath": "src/draw/tree/draw.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "themedTree",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 18
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.ThemeMap:type",
              "docComment": "/**\n * Type of theme registry mapping theme names to themes.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type ThemeMap = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ThemeName",
                  "canonicalReference": "effect-tree!Draw.ThemeName:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "releaseTag": "Public",
              "name": "ThemeMap",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.ThemeName:type",
              "docComment": "/**\n * Type of theme names.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type ThemeName = "
                },
                {
                  "kind": "Reference",
                  "text": "GlyphSetName",
                  "canonicalReference": "effect-tree!Draw.GlyphSetName:type"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "releaseTag": "Public",
              "name": "ThemeName",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.themeNames:var",
              "docComment": "/**\n * Names of glyph sets created with an indent count of one.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "themeNames: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"thin\", \"thick\", \"hThick\", \"vThick\", \"unix\", \"unixRound\", \"round\", \"double\", \"hDouble\", \"vDouble\", \"ascii\", \"bullets\", \"space\"]"
                }
              ],
              "fileUrlPath": "src/draw/tree/theme/types.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "themeNames",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.topElbowDirections:var",
              "docComment": "/**\n * Corners for the top of a box.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "topElbowDirections: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"topLeft\", \"topRight\"]"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "topElbowDirections",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.treeLayout:var",
              "docComment": "/**\n * Convert a tree into a themed part.\n *\n * You can find a flipped version under the key `flip`.\n *\n * @param tree - The string tree to draw.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "treeLayout: "
                },
                {
                  "kind": "Content",
                  "text": "typeof "
                },
                {
                  "kind": "Reference",
                  "text": "_treeLayout",
                  "canonicalReference": "effect-tree!~_treeLayout:function"
                },
                {
                  "kind": "Content",
                  "text": " & {\n    flip: (b: "
                },
                {
                  "kind": "Reference",
                  "text": "Theme",
                  "canonicalReference": "effect-tree!Draw.Theme:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => (a: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/tree/layout.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "treeLayout",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.unfixColumn:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "unfixColumn: (fixed: "
                },
                {
                  "kind": "Reference",
                  "text": "Column",
                  "canonicalReference": "effect-tree!Draw.Column:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "ColumnF",
                  "canonicalReference": "effect-tree!Draw.PartF_2.ColumnF:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "fixed",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "unfixColumn"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.unfixPart:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "unfixPart: <Type extends "
                },
                {
                  "kind": "Reference",
                  "text": "PartF",
                  "canonicalReference": "effect-tree!Draw.PartF_2.PartF_3:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ">(fixed: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "Type"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "returnTypeTokenRange": {
                "startIndex": 8,
                "endIndex": 9
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "fixed",
                  "parameterTypeTokenRange": {
                    "startIndex": 6,
                    "endIndex": 7
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "Type",
                  "constraintTokenRange": {
                    "startIndex": 1,
                    "endIndex": 5
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "unfixPart"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.unfixRow:function(1)",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "unfixRow: (fixed: "
                },
                {
                  "kind": "Reference",
                  "text": "Row",
                  "canonicalReference": "effect-tree!Draw.Row:type"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "RowF",
                  "canonicalReference": "effect-tree!Draw.PartF_2.RowF:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/part/types.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "fixed",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "unfixRow"
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.UnlinesDraw:interface",
              "docComment": "/**\n * Type of the unlines draw function: a {@link BaseDraw} that outputs to a non-empty array of strings, and has a variant under the `unlines` key.\n *\n * At the key `unlines` you will find a version that draws to a `string` instead of a `NonEmptyArray<string>` by joining the rows with newlines.\n *\n * A function of the type:\n * ```ts\n * {\n *   (self: Tree<A>): NonEmptyArray<string>\n *   unlines: (self: Tree<A>) ⇒ NonEmptyArray<string>\n * }\n * ```\n *\n * @typeParam A - Underlying type of the tree being printed.  @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface UnlinesDraw<A> extends "
                },
                {
                  "kind": "Reference",
                  "text": "BaseDraw",
                  "canonicalReference": "effect-tree!Draw.BaseDraw:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A, "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>>"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/draw/tree/draw.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "UnlinesDraw",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.UnlinesDraw#unlines:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "unlines: "
                    },
                    {
                      "kind": "Reference",
                      "text": "BaseDraw",
                      "canonicalReference": "effect-tree!Draw.BaseDraw:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A, string>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "unlines",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 5
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.vBorders:var",
              "docComment": "/**\n * Add borders to the top and bottom of the given part.\n *\n * At the key `corners` you will find a version that has the same signature but adds corner glyphs at the left and right edges of th top and bottom borders.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "vBorders: "
                },
                {
                  "kind": "Content",
                  "text": "((set: "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">) & {\n    corners: (set: "
                },
                {
                  "kind": "Reference",
                  "text": "BorderSet",
                  "canonicalReference": "effect-tree!Draw.BorderSet:interface"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/borders.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "vBorders",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.VerticalAlignment:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type VerticalAlignment = "
                },
                {
                  "kind": "Content",
                  "text": "(typeof "
                },
                {
                  "kind": "Reference",
                  "text": "verticalAlignments",
                  "canonicalReference": "effect-tree!Draw.verticalAlignments:var"
                },
                {
                  "kind": "Content",
                  "text": ")[number]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "releaseTag": "Public",
              "name": "VerticalAlignment",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.verticalAlignments:var",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "verticalAlignments: "
                },
                {
                  "kind": "Content",
                  "text": "readonly [\"top\", \"middle\", \"bottom\"]"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "verticalAlignments",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.VerticalDirection:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type VerticalDirection = "
                },
                {
                  "kind": "Content",
                  "text": "'top' | 'bottom'"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/direction.ts",
              "releaseTag": "Public",
              "name": "VerticalDirection",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.VerticalEquivalence:var",
              "docComment": "/**\n * Equivalence for {@link VerticallyAligned}.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "VerticalEquivalence: "
                },
                {
                  "kind": "Reference",
                  "text": "EQ.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "VerticallyAligned",
                  "canonicalReference": "effect-tree!Draw.VerticallyAligned:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "VerticalEquivalence",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Draw.VerticallyAligned:interface",
              "docComment": "/**\n * ```ts\n * {\n *   vAlign: VerticalAlignment\n *   top: VStrut\n *   bottom: VStrut\n * }\n * ```\n *\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface VerticallyAligned extends "
                },
                {
                  "kind": "Reference",
                  "text": "VStruts",
                  "canonicalReference": "effect-tree!Draw.VStruts:type"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/draw/align/data.ts",
              "releaseTag": "Public",
              "name": "VerticallyAligned",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Draw.VerticallyAligned#vAlign:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "vAlign: "
                    },
                    {
                      "kind": "Reference",
                      "text": "VerticalAlignment",
                      "canonicalReference": "effect-tree!Draw.VerticalAlignment:type"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "vAlign",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 2
                }
              ]
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Draw.vIndent:function(1)",
              "docComment": "/**\n * Returns the empty part if the given height is zero, else a zero-width column at the given height.\n *\n * @example\n *\n * import {vIndent} from 'effect-tree'\n *\n * const twoLines = vIndent(2) // ‘ // ’ const nothing = vIndent(0) // ‘’  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "vIndent: (height: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                }
              ],
              "fileUrlPath": "src/draw/parts/atoms.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "height",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "name": "vIndent"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.vSpace:var",
              "docComment": "/**\n * Pad a part with top and bottom padding filled with spaces.\n *\n * At the keys `top` and `bottom` you will find versions that pad only a single side of the given part.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "vSpace: "
                },
                {
                  "kind": "Content",
                  "text": "((padTop?: number, padBottom?: number) => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ">) & {\n    top: (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ", pad?: number) => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    bottom: (self: "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ", pad?: number) => "
                },
                {
                  "kind": "Reference",
                  "text": "Part",
                  "canonicalReference": "effect-tree!Draw.Part_2:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/draw/parts/atoms.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "vSpace",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.VStrut:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type VStrut = "
                },
                {
                  "kind": "Reference",
                  "text": "BaseStrut",
                  "canonicalReference": "effect-tree!Draw.BaseStrut:interface"
                },
                {
                  "kind": "Content",
                  "text": "<'vertical'>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "releaseTag": "Public",
              "name": "VStrut",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.VStrut:var",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "VStrut: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (body?: "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>, prefix?: string[], suffix?: string[]): "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    empty: "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    fill({ prefix, body, suffix }: "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                },
                {
                  "kind": "Content",
                  "text": "): (available: number) => string[];\n}"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "VStrut",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Draw.VStruts:type",
              "docComment": "/**\n * @category drawing\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type VStruts = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "VerticalDirection",
                  "canonicalReference": "effect-tree!Draw.VerticalDirection:type"
                },
                {
                  "kind": "Content",
                  "text": ", "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "releaseTag": "Public",
              "name": "VStruts",
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.VStruts:var",
              "docComment": "/**\n * Build a pair of top/bottom vertical struts form the given vertical struts.  @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "VStruts: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    (top: "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                },
                {
                  "kind": "Content",
                  "text": ", bottom?: "
                },
                {
                  "kind": "Reference",
                  "text": "VStrut",
                  "canonicalReference": "effect-tree!Draw.VStrut:type"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "VStruts",
                  "canonicalReference": "effect-tree!Draw.VStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    empty: "
                },
                {
                  "kind": "Reference",
                  "text": "VStruts",
                  "canonicalReference": "effect-tree!Draw.VStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ";\n    fill({ top, bottom }: "
                },
                {
                  "kind": "Reference",
                  "text": "VStruts",
                  "canonicalReference": "effect-tree!Draw.VStruts:type"
                },
                {
                  "kind": "Content",
                  "text": "): ([availableTop, availableBottom]: [number, number]) => (lines: string[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<string>;\n}"
                }
              ],
              "fileUrlPath": "src/draw/struts/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "VStruts",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Draw.VStrutsEquivalence:var",
              "docComment": "/**\n * @category drawing  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "VStrutsEquivalence: "
                },
                {
                  "kind": "Reference",
                  "text": "EQ.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "VStruts",
                  "canonicalReference": "effect-tree!Draw.VStruts:type"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/draw/struts/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "VStrutsEquivalence",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            }
          ]
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!drawTree:var",
          "docComment": "/**\n * Draw a string or numeric tree into a non-empty array of string rows.\n *\n * At the key `unlines` you will find a version the returns a string of the joined rows.\n *\n * At the key `numeric` you will find a version that draws _numeric_ trees, and it too has a key `unlines` with a version that draws to strings rather than an array of rows.\n *\n * At each key named after a {@link themeNames | theme name}, you will find a version of the function with its `numeric` and `unlines` variants, that draws the tree at the given theme.\n *\n * @example\n *\n * import {Array} from 'effect' import {drawTree} from 'effect-tree'\n *\n * const stringTree = of('foo') const numericTree = of(42)\n *\n * // Draw a string tree into arrays of rows using default theme. const stringRows : Array.NonEmptyArray<string> = drawTree(stringTree)\n *\n * // Draw a numeric tree into arrays of rows using default theme. const numericRows: Array.NonEmptyArray<string> = drawTree.number(numericTree)\n *\n * // Draw string trees to a string using default theme for `console.log`, for // example. console.log(drawTree.unlines(stringTree))\n *\n * // Draw numeric trees to a string using default theme. console.log(drawTree.numeric.unlines(numericTree))\n *\n * // Draw string trees using a specific theme into rows. const stringAsciiRows = drawTree.ascii(stringTree))\n *\n * // Draw string trees using a specific theme into a string. console.log(drawTree.ascii.unlines(stringTree))\n *\n * // Draw numeric trees using a specific theme into rows. const numericAsciiRows = drawTree.ascii.numeric(numericTree))\n *\n * // Draw numeric trees using a specific theme into a string. console.log(drawTree.ascii.numeric.unlines(numericTree))  @category drawing  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "drawTree: "
            },
            {
              "kind": "Reference",
              "text": "DrawTree",
              "canonicalReference": "effect-tree!Draw.DrawTree:interface"
            }
          ],
          "fileUrlPath": "src/draw/tree/draw.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "drawTree",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!drill:var",
          "docComment": "/**\n * Drill down to get the child node at a given index path or none. Negative indexes are handled as in {@link nthChild}: as offsets from the end of the forest with `-1` being the last child, `-2` the child before it, and so on.\n *\n * An empty path will return the given tree.\n *\n * @param path - a possibly empty array of numeric indexes that form a path from root node to some child node. accepted.\n *\n * @param self - node will be taken from the forest of this node.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns An optional tree.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "drill: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(path: number[], self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): "
            },
            {
              "kind": "Reference",
              "text": "Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (path: number[]) => "
            },
            {
              "kind": "Reference",
              "text": "Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n    flip: (path: number[]) => <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "drill",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 20
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!Endo:interface",
          "docComment": "/**\n * Just like {@link EndoOf} except the type `A` is open.  @category internal\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface Endo "
            }
          ],
          "fileUrlPath": "src/util/Function.ts",
          "releaseTag": "Public",
          "name": "Endo",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "CallSignature",
              "canonicalReference": "effect-tree!Endo:call(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "<A>(a: "
                },
                {
                  "kind": "Content",
                  "text": "A"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Content",
                  "text": "A"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "a",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ]
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!EndoK:interface",
          "docComment": "/**\n * Just like {@link Endo} except the endomorphism is between higher-kinded types.  @category internal\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface EndoK<F extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": "> "
            }
          ],
          "fileUrlPath": "src/util/Function.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "F",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "EndoK",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "CallSignature",
              "canonicalReference": "effect-tree!EndoK:call(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "<A>(a: "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.Kind",
                  "canonicalReference": "effect!Kind:type"
                },
                {
                  "kind": "Content",
                  "text": "<F, never, unknown, unknown, A>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Content",
                  "text": "typeof "
                },
                {
                  "kind": "Reference",
                  "text": "a",
                  "canonicalReference": "effect-tree!~a:var"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "a",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ]
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!EndoOf:interface",
          "docComment": "/**\n * A function from a type `A` to itself. Just like {@link EndoOf} except the type `A` is open.  @category internal\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface EndoOf<A> "
            }
          ],
          "fileUrlPath": "src/util/Function.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "EndoOf",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "CallSignature",
              "canonicalReference": "effect-tree!EndoOf:call(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "(a: "
                },
                {
                  "kind": "Content",
                  "text": "A"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Content",
                  "text": "A"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "a",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ]
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!eqv:var",
          "docComment": "/**\n * Threads the logical connective `eqv`, also known as _bidirectional implication_, through all the nodes of a boolean tree and returns the boolean result.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "eqv: "
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<boolean>>"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "eqv",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!eqvFold:var",
          "docComment": "/**\n * @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "eqvFold: "
            },
            {
              "kind": "Reference",
              "text": "BooleanFolder",
              "canonicalReference": "effect-tree!BooleanFolder:type"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "eqvFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!every:var",
          "docComment": "/**\n * True if every node in the given boolean tree is true.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "every: "
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<boolean>>"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "every",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!everyFold:var",
          "docComment": "/**\n * @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "everyFold: "
            },
            {
              "kind": "Reference",
              "text": "BooleanFolder",
              "canonicalReference": "effect-tree!BooleanFolder:type"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "everyFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!everyOf:var",
          "docComment": "/**\n * True if the given predicate is true for every node in the given tree.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "everyOf: "
            },
            {
              "kind": "Reference",
              "text": "BooleanFold",
              "canonicalReference": "effect-tree!BooleanFold:type"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "everyOf",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!filterLeaves:function(1)",
          "docComment": "/**\n * Filter leaves so that only those satisfying the given predicate remain.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "filterLeaves: <A>(predicate: "
            },
            {
              "kind": "Reference",
              "text": "Predicate.Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/ops/filter.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "predicate",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "filterLeaves"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!filterLeavesFold:function(1)",
          "docComment": "/**\n * Filter leaves at a level algebra.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "filterLeavesFold: <A>(predicate: "
            },
            {
              "kind": "Reference",
              "text": "Predicate.Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/ops/filter.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "predicate",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "filterLeavesFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!filterMinimumLeaf:function(1)",
          "docComment": "/**\n * Filter out the minimal leaf for the given order and return a tuple with:\n *\n * 1. The given tree with its minimal leaf removed. 2. The minimal leaf that was removed. 3. The minimal leaf parent, or `None` if the tree is a leaf.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "filterMinimumLeaf: <A>(order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(t: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => [filtered: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, minLeaf: A, maybeParent: "
            },
            {
              "kind": "Reference",
              "text": "Option.Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<A>]"
            }
          ],
          "fileUrlPath": "src/ops/filter.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "filterMinimumLeaf"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!filterNodes:function(1)",
          "docComment": "/**\n * Filter nodes so that only those satisfying the given predicate remain.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "filterNodes: <A>(predicate: "
            },
            {
              "kind": "Reference",
              "text": "Predicate.Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/ops/filter.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "predicate",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "filterNodes"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!filterNodesFold:function(1)",
          "docComment": "/**\n * Filter nodes at a tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "filterNodesFold: <A>(predicate: "
            },
            {
              "kind": "Reference",
              "text": "Predicate.Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/ops/filter.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 10
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "predicate",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "filterNodesFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!firstChild:function(1)",
          "docComment": "/**\n * Return the first child tree of a branch.\n *\n * @param self - tree to navigate.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns The tree that is first in the forest of the given branch.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "firstChild: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "firstChild"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!fixBranch:function(1)",
          "docComment": "/**\n * Like {@link fixTree} but exclusively for branches.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "fixBranch: <A>(branchF: "
            },
            {
              "kind": "Reference",
              "text": "BranchF",
              "canonicalReference": "effect-tree!TreeF.BranchF:interface"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "branchF",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "fixBranch"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!fixTree:function(1)",
          "docComment": "/**\n * Convert the non-recursive version of the tree with children of type `Tree<A>` into the recursive {@link Tree} type.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "fixTree: <A>(treeF: "
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "treeF",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "fixTree"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!flap:var",
          "docComment": "/**\n * @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "flap: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A, B>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<(a: A) => B>): (a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>;\n    <A, B>(a: A, self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<(a: A) => B>): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>;\n}"
            }
          ],
          "fileUrlPath": "src/instances/Covariant.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "flap",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 10
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!flatMap:var",
          "docComment": "/**\n * Tree `flatmap`.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "flatMap: "
            },
            {
              "kind": "Reference",
              "text": "FlatMap.FlatMap",
              "canonicalReference": "@effect/typeclass!FlatMap:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">['flatMap']"
            }
          ],
          "fileUrlPath": "src/instances/Monad.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "flatMap",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!flatMapEffect:var",
          "docComment": "/**\n * `Flatmap` with an effectful function of a tree in depth-first post-order.\n *\n * At the key `pre` you will find a function that runs the effect in depth-first pre-order.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "flatMapEffect: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A, B, E = unknown, R = never>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, f: (a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>): "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>;\n    <A, B, E = unknown, R = never>(f: (a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>;\n    pre: <A, B, E = unknown, R = never>(f: (a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>) => (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>;\n}"
            }
          ],
          "fileUrlPath": "src/instances/Monad.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "flatMapEffect",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 32
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!flatten:function(1)",
          "docComment": "/**\n * Flatten a nested tree.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "flatten: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/instances/Monad.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "flatten"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!flattenEffect:function(1)",
          "docComment": "/**\n * Flatten a nested tree into an effect.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "flattenEffect: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/instances/Monad.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 10
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "flattenEffect"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!flattenFold:function(1)",
          "docComment": "/**\n * Flatten a single level of a nested tree.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "flattenFold: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/instances/Monad.ts",
          "returnTypeTokenRange": {
            "startIndex": 8,
            "endIndex": 10
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "flattenFold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!Foldable:var",
          "docComment": "/**\n * Foldable instance for {@link Tree}.  @category instances\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "Foldable: "
            },
            {
              "kind": "Reference",
              "text": "FO.Foldable",
              "canonicalReference": "@effect/typeclass!Foldable:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "Foldable",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!foldMap:function(1)",
          "docComment": "/**\n * Fold a `Tree<A>` into an `A` using a `Monoid<A>`.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "foldMap: <A>(M: "
            },
            {
              "kind": "Reference",
              "text": "Monoid.Monoid",
              "canonicalReference": "@effect/typeclass!Monoid:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFold",
              "canonicalReference": "effect-tree!TreeFold:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "M",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "foldMap"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!folds:var",
          "docComment": "/**\n * All folds in a single place.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "folds: "
            },
            {
              "kind": "Content",
              "text": "{\n    allLeaves: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderK",
              "canonicalReference": "effect-tree!TreeFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArrayTypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">;\n    arrays: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderK",
              "canonicalReference": "effect-tree!TreeFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Arrays.TreeArrayLambda",
              "canonicalReference": "effect-tree!Codec.Arrays.TreeArrayLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">;\n    boolean: (M: import(\"@effect/typeclass/Monoid\")."
            },
            {
              "kind": "Reference",
              "text": "Monoid",
              "canonicalReference": "@effect/typeclass!Monoid:interface"
            },
            {
              "kind": "Content",
              "text": "<boolean>) => <A>(predicate: import(\"effect/Predicate\")."
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, boolean>;\n    countOf: <A>(predicate: import(\"effect/Predicate\")."
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, number>;\n    degree: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderOf",
              "canonicalReference": "effect-tree!TreeFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number>;\n    descendantCount: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderOf",
              "canonicalReference": "effect-tree!TreeFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number>;\n    edges: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderK",
              "canonicalReference": "effect-tree!TreeFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Edges.EdgeListTypeLambda",
              "canonicalReference": "effect-tree!Codec.Edges.EdgeListTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">;\n    eqv: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "BooleanFolder",
              "canonicalReference": "effect-tree!BooleanFolder:type"
            },
            {
              "kind": "Content",
              "text": ";\n    every: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "BooleanFolder",
              "canonicalReference": "effect-tree!BooleanFolder:type"
            },
            {
              "kind": "Content",
              "text": ";\n    filterLeaves: <A>(predicate: import(\"effect/Predicate\")."
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n    filterNodes: <A>(predicate: import(\"effect/Predicate\")."
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n    flatten: <A>(self: import(\"./treeF.js\")."
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    growLeaves: <A>(grow: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeUnfold",
              "canonicalReference": "effect-tree!TreeUnfold:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n    includes: <A>(equals: import(\"effect/Equivalence\")."
            },
            {
              "kind": "Reference",
              "text": "Equivalence",
              "canonicalReference": "effect!Equivalence:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => ((needle: A) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, boolean>);\n    levels: <A>(self: import(\"./treeF.js\")."
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, import(\"./util/Array.js\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray2",
              "canonicalReference": "effect-tree!NonEmptyArray2:type"
            },
            {
              "kind": "Content",
              "text": "<A>>) => import(\"./util/Array.js\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray2",
              "canonicalReference": "effect-tree!NonEmptyArray2:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    maximumDegree: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderOf",
              "canonicalReference": "effect-tree!TreeFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number>;\n    maximumHeight: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderOf",
              "canonicalReference": "effect-tree!TreeFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number>;\n    monoid: <A>(M: import(\"@effect/typeclass/Monoid\")."
            },
            {
              "kind": "Reference",
              "text": "Monoid",
              "canonicalReference": "@effect/typeclass!Monoid:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>;\n    nodeOrdinalFold: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderOf",
              "canonicalReference": "effect-tree!TreeFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number>;\n    numericMax: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>;\n    numericMin: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>;\n    numericProduct: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>;\n    numericSum: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>;\n    paths: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderK",
              "canonicalReference": "effect-tree!TreeFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray2TypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArray2TypeLambda:type"
            },
            {
              "kind": "Content",
              "text": ">;\n    postOrder: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderK",
              "canonicalReference": "effect-tree!TreeFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArrayTypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">;\n    predicate: (M: import(\"@effect/typeclass/Monoid\")."
            },
            {
              "kind": "Reference",
              "text": "Monoid",
              "canonicalReference": "@effect/typeclass!Monoid:interface"
            },
            {
              "kind": "Content",
              "text": "<boolean>) => <A>(predicate: import(\"effect/Predicate\")."
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, boolean>;\n    preOrder: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeFolderK",
              "canonicalReference": "effect-tree!TreeFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArrayTypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">;\n    some: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "BooleanFolder",
              "canonicalReference": "effect-tree!BooleanFolder:type"
            },
            {
              "kind": "Content",
              "text": ";\n    unzip: <A, B>(t: import(\"./treeF.js\")."
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<[A, B], [import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>]>) => [import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>];\n    unzipTheseFold: <A, B>(self: import(\"./treeF.js\")."
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<import(\"./util/These.js\")."
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>, import(\"./util/These.js\")."
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>>>) => import(\"./util/These.js\")."
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>>;\n    xor: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "BooleanFolder",
              "canonicalReference": "effect-tree!BooleanFolder:type"
            },
            {
              "kind": "Content",
              "text": ";\n}"
            }
          ],
          "fileUrlPath": "src/folds.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "folds",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 136
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!ForestOf:type",
          "docComment": "/**\n * A non-empty list of trees.\n *\n * @typeParam A - Underlying tree type.  @category basic\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ForestOf<A> = "
            },
            {
              "kind": "Reference",
              "text": "NonEmptyReadonlyArray",
              "canonicalReference": "effect!NonEmptyReadonlyArray:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/tree/types.ts",
          "releaseTag": "Public",
          "name": "ForestOf",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!ForestTypeLambda:type",
          "docComment": "/**\n * A type lambda for `Array.NonEmptyArray<Tree<?>>`.  @category refold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ForestTypeLambda = "
            },
            {
              "kind": "Reference",
              "text": "ComposeTypeLambda",
              "canonicalReference": "effect-ts-laws!ComposeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArrayTypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", "
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/types.ts",
          "releaseTag": "Public",
          "name": "ForestTypeLambda",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!from:function(1)",
          "docComment": "/**\n * A version of {@link tree} where the forest is a rest argument.\n *\n * @typeParam A - Underlying tree type.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "from: <A>(value: "
            },
            {
              "kind": "Content",
              "text": "A"
            },
            {
              "kind": "Content",
              "text": ", ...forest: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "value",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            },
            {
              "parameterName": "forest",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "from"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!getBranchForest:function(1)",
          "docComment": "/**\n * Get the forest of a branch node.\n *\n * @param self - the branch to query.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns The non-empty forest of the given branch..  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "getBranchForest: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "getBranchForest"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!getEquivalence:function(1)",
          "docComment": "/**\n * Creates an `Equivalence` for a {@link Tree}<A> type, given an Equivalence for the underlying type `A`.\n *\n * The equivalence will scan every node of both trees to make sure that are the same, but will short-circuit on a mismatch.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "getEquivalence: <A>(equalsA: "
            },
            {
              "kind": "Reference",
              "text": "Equivalence.Equivalence",
              "canonicalReference": "effect!Equivalence:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Equivalence.Equivalence",
              "canonicalReference": "effect!Equivalence:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/instances/Equivalence.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "equalsA",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "getEquivalence"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!getEquivalenceEffect:function(1)",
          "docComment": "/**\n * List {@link getEquivalence} but the result is left inside an effect.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "getEquivalenceEffect: <A>(equalsA: "
            },
            {
              "kind": "Reference",
              "text": "Equivalence.Equivalence",
              "canonicalReference": "effect!Equivalence:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, that: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<void, undefined>"
            }
          ],
          "fileUrlPath": "src/instances/Equivalence.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "equalsA",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "getEquivalenceEffect"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!getForest:function(1)",
          "docComment": "/**\n * Get the forest of any tree node. Result could be an empty list if the given node is a {@link Leaf}.\n *\n * See {@link getBranchForest} for a version that returns the non-empty forest of a branch.\n *\n * @param self - The tree being queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns A possibly empty list of trees.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "getForest: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "readonly "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "getForest"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!getMonoid:function(1)",
          "docComment": "/**\n * Creates a `Monoid` for a `Tree<A>` type, given a `Monoid` for the underlying type `A`. `empty` will be a `leaf(M.empty)`.  @category instances\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "getMonoid: <A>(F: "
            },
            {
              "kind": "Reference",
              "text": "Monoid.Monoid",
              "canonicalReference": "@effect/typeclass!Monoid:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Monoid.Monoid",
              "canonicalReference": "@effect/typeclass!Monoid:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/instances/Applicative.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "F",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "getMonoid"
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!GetNodes:type",
          "docComment": "/**\n * @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type GetNodes = "
            },
            {
              "kind": "Content",
              "text": "<A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Array.NonEmptyArray",
              "canonicalReference": "effect!NonEmptyArray:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/ops/traverse.ts",
          "releaseTag": "Public",
          "name": "GetNodes",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!getOrder:function(1)",
          "docComment": "/**\n * Build an order for {@link Tree} from and order of its underlying type.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "getOrder: <A>(orderA: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/instances/Order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "orderA",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "getOrder"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!getSemigroup:function(1)",
          "docComment": "/**\n * Creates an `Semigroup` for a `Tree<A>` type, given a `Semigroup` for the underlying type `A`.  @category instances\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "getSemigroup: <A>(F: "
            },
            {
              "kind": "Reference",
              "text": "Semigroup.Semigroup",
              "canonicalReference": "@effect/typeclass!Semigroup:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Semigroup.Semigroup",
              "canonicalReference": "@effect/typeclass!Semigroup:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/instances/Applicative.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "F",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "getSemigroup"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!getValue:function(1)",
          "docComment": "/**\n * Get the value of a node.\n *\n * @param self - the tree to query.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns Value of the tree root node.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "getValue: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "A"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "getValue"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!growLeaves:function(1)",
          "docComment": "/**\n * Grows the tree at its leaves.\n *\n * Given a function of type `(a: A) ⇒ Tree<A>` replacing a value of type `A` with a `Tree<A>`, grow the tree by running all leaves through this function, replacing the leaves with the function results.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "growLeaves: <A>(grow: "
            },
            {
              "kind": "Reference",
              "text": "TreeUnfold",
              "canonicalReference": "effect-tree!TreeUnfold:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFold",
              "canonicalReference": "effect-tree!TreeFold:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "grow",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "growLeaves"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!growLeavesFold:function(1)",
          "docComment": "/**\n * Grow all leaves according to the given `grow` function for a single level of the tree.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "growLeavesFold: <A>(grow: "
            },
            {
              "kind": "Reference",
              "text": "TreeUnfold",
              "canonicalReference": "effect-tree!TreeUnfold:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "grow",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "growLeavesFold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!imap:var",
          "docComment": "/**\n * @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "imap: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A, B>(to: (a: A) => B, from: (b: B) => A): <R, O, E>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>;\n    <R, O, E, A, B>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, to: (a: A) => B, from: (b: B) => A): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>;\n}"
            }
          ],
          "fileUrlPath": "src/instances/Covariant.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "imap",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 10
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!includes:function(1)",
          "docComment": "/**\n * True if `needle` is found in the tree.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "includes: <A>(equals: "
            },
            {
              "kind": "Reference",
              "text": "Equivalence.Equivalence",
              "canonicalReference": "effect!Equivalence:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "((a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Predicate.Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>)"
            }
          ],
          "fileUrlPath": "src/ops/filter.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "equals",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "includes"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!includesFold:function(1)",
          "docComment": "/**\n * True if `needle` is found in tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "includesFold: <A>(equals: "
            },
            {
              "kind": "Reference",
              "text": "Equivalence.Equivalence",
              "canonicalReference": "effect!Equivalence:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "((needle: A) => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, boolean>)"
            }
          ],
          "fileUrlPath": "src/ops/filter.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "equals",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "includesFold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!insertAllAt:var",
          "docComment": "/**\n * Insert a list of trees before Nth child of the given tree. The list is inserted so that the head element of the inserted list becomes the Nth child of the tree, and the previous Nth child is pushed after the inserted list.\n *\n * Negative indexes are handled as offsets from the final tree in the forest so that inserting a list to index `-1` inserts the list _before_ the last tree of the forest. Use {@link appendAll} to append _after_ the last tree in the forest.\n *\n * If `self` is a _leaf_, it is converted into a branch.\n *\n * If the index is out-of-bounds, I.E.: negative or greater than `forest length - 1`, the list is appended to the _end_ of the forest.\n *\n * @param self - The tree to modify.\n *\n * @param children - Non-empty list of child trees to insert.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns A new updated tree with the new child trees inserted.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "insertAllAt: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, n: number, children: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>): "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(n: number, children: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/add.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "insertAllAt",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 14
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!insertAt:var",
          "docComment": "/**\n * Insert a tree before Nth child of the given tree. The tree is inserted so that it becomes the Nth child of the tree, and the previous Nth child becomes moves over to position N+1.\n *\n * Negative indexes are handled as offsets from the final tree in the forest so that inserting a tree to index `-1` inserts the tree _before_ the last tree of the forest. Use {@link append} to append _after_ the last tree.\n *\n * If `self` is a _leaf_, it is converted into a branch.\n *\n * If the index is out-of-bounds, I.E.: negative or greater than `forest length - 1`, the tree is appended to the _end_ of the forest.\n *\n * @param self - The tree to modify.\n *\n * @param child - Child to insert.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns A new updated tree with the new node inserted.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "insertAt: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, child: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, n: number): "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(child: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, n: number) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/add.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "insertAt",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 14
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!isBranch:function(1)",
          "docComment": "/**\n * Type guard for the tree {@link Branch} type.\n *\n * @typeParam A - Underlying tree type.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "isBranch: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "self",
              "canonicalReference": "effect-tree!~self"
            },
            {
              "kind": "Content",
              "text": " is "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "isBranch"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!isLeaf:function(1)",
          "docComment": "/**\n * Type guard for the tree {@link Leaf} type.\n *\n * @typeParam A - Underlying tree type.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "isLeaf: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "self",
              "canonicalReference": "effect-tree!~self"
            },
            {
              "kind": "Content",
              "text": " is "
            },
            {
              "kind": "Reference",
              "text": "Leaf",
              "canonicalReference": "effect-tree!Leaf:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "isLeaf"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!lastChild:function(1)",
          "docComment": "/**\n * Return the last child tree of a branch.\n *\n * @param self - tree to navigate.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns The tree that is last in the forest of the given branch.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "lastChild: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "lastChild"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!leaf:function(1)",
          "docComment": "/**\n * Create a new leaf from its value.\n *\n * @param value - The tree root value.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns A new leaf with the given value.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "leaf: <A>(value: "
            },
            {
              "kind": "Content",
              "text": "A"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Leaf",
              "canonicalReference": "effect-tree!Leaf:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "value",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "leaf"
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!Leaf:type",
          "docComment": "/**\n * The leaf type of {@link Tree}. Leaves are simple wrappers over {@link LeafF} values.\n *\n * @typeParam A - Underlying tree type.  @category basic\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Leaf<A> = "
            },
            {
              "kind": "Reference",
              "text": "Record",
              "canonicalReference": "!Record:type"
            },
            {
              "kind": "Content",
              "text": "<'unfixed', "
            },
            {
              "kind": "Reference",
              "text": "LeafF",
              "canonicalReference": "effect-tree!TreeF.LeafF:interface"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/tree/types.ts",
          "releaseTag": "Public",
          "name": "Leaf",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!length:function(1)",
          "docComment": "/**\n * Compute child count for root node.\n *\n * @param self - The tree being queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns Numeric child count.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "length: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "number"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "length"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!levels:function(1)",
          "docComment": "/**\n * Returns tree nodes grouped by level.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "levels: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray2",
              "canonicalReference": "effect-tree!NonEmptyArray2:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "levels"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!levelsFold:function(1)",
          "docComment": "/**\n * Group a level of the tree by _depth_: number of levels between the node and the tree root.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "levelsFold: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray2",
              "canonicalReference": "effect-tree!NonEmptyArray2:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray2",
              "canonicalReference": "effect-tree!NonEmptyArray2:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "levelsFold"
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!LevelTreeSettings:interface",
          "docComment": "/**\n * Settings for the `unfolds.levelTree` unfold.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface LevelTreeSettings "
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "releaseTag": "Public",
          "name": "LevelTreeSettings",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "effect-tree!LevelTreeSettings#degree:member",
              "docComment": "/**\n * Function to be run at each node to determine its child count, also called _degree_. The function will be called with the node _depth_.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "degree?: "
                },
                {
                  "kind": "Content",
                  "text": "(depth: number) => number"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": true,
              "releaseTag": "Public",
              "name": "degree",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "effect-tree!LevelTreeSettings#depth:member",
              "docComment": "/**\n * Requested depth of unfolded tree.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "depth: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "depth",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!levelTreeUnfold:function(1)",
          "docComment": "/**\n * Unfold a single layer of a numeric level tree.  @category unfold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "levelTreeUnfold: ({ depth, degree, }: "
            },
            {
              "kind": "Reference",
              "text": "LevelTreeSettings",
              "canonicalReference": "effect-tree!LevelTreeSettings:interface"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeUnfolder",
              "canonicalReference": "effect-tree!TreeUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "{ depth, degree, }",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "levelTreeUnfold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!map:var",
          "docComment": "/**\n * Map over all tree nodes using the given function.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "map: "
            },
            {
              "kind": "Reference",
              "text": "CO.Covariant",
              "canonicalReference": "@effect/typeclass!Covariant:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">['map']"
            }
          ],
          "fileUrlPath": "src/instances/Covariant.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "map",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!mapEffect:var",
          "docComment": "/**\n * Map an effectful function over the tree in post-order: parent effect is run _after_ children.\n *\n * At the key `pre` you will find a function that runs the effect in depth-first pre-order.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "mapEffect: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A, B, E = unknown, R = never>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, f: (a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<B, E, R>): "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>;\n    <A, B, E = unknown, R = never>(f: (a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<B, E, R>): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>;\n    pre: <A, B, E = unknown, R = never>(f: (a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<B, E, R>) => (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>;\n}"
            }
          ],
          "fileUrlPath": "src/instances/Covariant.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "mapEffect",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 26
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!match:function(1)",
          "docComment": "/**\n * Match a {@link Tree} to leaves and branches.\n *\n * @param matcher - A record with the keys `onLeaf` and `onBranch`.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns Result of the match.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "match: <A, R>({ onLeaf, onBranch }: "
            },
            {
              "kind": "Reference",
              "text": "Matcher",
              "canonicalReference": "effect-tree!Matcher:interface"
            },
            {
              "kind": "Content",
              "text": "<A, R>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "((self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => R)"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "{ onLeaf, onBranch }",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "match"
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!Matcher:interface",
          "docComment": "/**\n * @category basic\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface Matcher<A, R> "
            }
          ],
          "fileUrlPath": "src/tree/types.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "Matcher",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "effect-tree!Matcher#onBranch:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "onBranch: "
                },
                {
                  "kind": "Content",
                  "text": "(node: A, forest: "
                },
                {
                  "kind": "Reference",
                  "text": "ForestOf",
                  "canonicalReference": "effect-tree!ForestOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => R"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "onBranch",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "effect-tree!Matcher#onLeaf:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "onLeaf: "
                },
                {
                  "kind": "Content",
                  "text": "(node: A) => R"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "onLeaf",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!max:function(1)",
          "docComment": "/**\n * Find max node value in a numeric tree.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "max: (tree: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<number>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "number"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "tree",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "max"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!maximumDegreeFold:var",
          "docComment": "/**\n * Measure max node degree at a tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumDegreeFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolderOf",
              "canonicalReference": "effect-tree!TreeFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "maximumDegreeFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!maximumHeightFold:var",
          "docComment": "/**\n * Measure max node height from its deepest descendant at tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumHeightFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolderOf",
              "canonicalReference": "effect-tree!TreeFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "maximumHeightFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!maximumLeaf:function(1)",
          "docComment": "/**\n * Return the largest leaf in the tree according to the given order.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumLeaf: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(tree: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => A"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "maximumLeaf"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!maximumLeafAndParent:function(1)",
          "docComment": "/**\n * Just like `maximumLeaf` but returns the leaf tupled with its parent or `None` if the tree if a leaf.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumLeafAndParent: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "((self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => readonly [A, "
            },
            {
              "kind": "Reference",
              "text": "Option.Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<A>])"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "maximumLeafAndParent"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!maximumLeafAndParentFold:var",
          "docComment": "/**\n * Just like `maximumLeafFold` but result include the parent node of the maximal leaf, or `None` if given tree is a leaf.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumLeafAndParentFold: "
            },
            {
              "kind": "Content",
              "text": "typeof "
            },
            {
              "kind": "Reference",
              "text": "minimumLeafParentFold",
              "canonicalReference": "effect-tree!minimumLeafParentFold:var"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "maximumLeafAndParentFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!maximumLeafFold:function(1)",
          "docComment": "/**\n * Find minimum leaf at tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumLeafFold: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "maximumLeafFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!maximumNode:function(1)",
          "docComment": "/**\n * Return the largest value in the tree according to the given order.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumNode: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(tree: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => A"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "maximumNode"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!maximumNodeDegree:var",
          "docComment": "/**\n * Compute the maximum child count of any node in the tree.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumNodeDegree: "
            },
            {
              "kind": "Reference",
              "text": "TreeFoldOf",
              "canonicalReference": "effect-tree!TreeFoldOf:type"
            },
            {
              "kind": "Content",
              "text": "<number>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "maximumNodeDegree",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!maximumNodeFold:function(1)",
          "docComment": "/**\n * Find maximum node at tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumNodeFold: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "maximumNodeFold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!maximumNodeHeight:var",
          "docComment": "/**\n * Compute the maximum node depth of all nodes in a tree.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "maximumNodeHeight: "
            },
            {
              "kind": "Reference",
              "text": "TreeFoldOf",
              "canonicalReference": "effect-tree!TreeFoldOf:type"
            },
            {
              "kind": "Content",
              "text": "<number>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "maximumNodeHeight",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!min:function(1)",
          "docComment": "/**\n * Find min node value in a numeric tree.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "min: (tree: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<number>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "number"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "tree",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "min"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!minimumLeaf:function(1)",
          "docComment": "/**\n * Return the smallest leaf in the tree according to the given order.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "minimumLeaf: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(tree: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => A"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "minimumLeaf"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!minimumLeafAndParent:function(1)",
          "docComment": "/**\n * Just like `minimumLeaf` but returns the leaf tupled with its parent or `None` if the tree if a leaf.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "minimumLeafAndParent: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "((self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => readonly [A, "
            },
            {
              "kind": "Reference",
              "text": "Option.Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<A>])"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "minimumLeafAndParent"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!minimumLeafFold:function(1)",
          "docComment": "/**\n * Find minimum leaf at tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "minimumLeafFold: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "minimumLeafFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!minimumLeafParentFold:function(1)",
          "docComment": "/**\n * Just like `minimumLeafFold` but result include the parent node of the minimal leaf, or `None` if given tree is a leaf.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "minimumLeafParentFold: <A>(o: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, readonly [A, "
            },
            {
              "kind": "Reference",
              "text": "Option.Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<A>]>"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "o",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "minimumLeafParentFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!minimumNode:function(1)",
          "docComment": "/**\n * Return the smallest value in the tree according to the given order.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "minimumNode: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(tree: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => A"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "minimumNode"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!minimumNodeFold:function(1)",
          "docComment": "/**\n * Find minimum node at tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "minimumNodeFold: <A>(Order: "
            },
            {
              "kind": "Reference",
              "text": "Order.Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            }
          ],
          "fileUrlPath": "src/ops/order.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "Order",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "minimumNodeFold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!modBranch:var",
          "docComment": "/**\n * Run the given function over the given tree if it is a branch, else return the tree unchanged. This is like {@link match} where the `onLeaf` branch is set to `identity`.\n *\n * @param self - Tree on which to run the given function.\n *\n * @param f - A function from {@link Branch} to {@link Tree}.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns The tree unchanged if it is a leaf, else the result of applying the given function on the branch.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "modBranch: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, f: (branch: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(f: (branch: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "modBranch",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 18
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!modBranchForest:function(1)",
          "docComment": "/**\n * Same as {@link modForest} but only accepts branches, so the given function is guaranteed to get a non empty forest as its argument.\n *\n * @param f - Function to apply on the root forest.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns The given branch with its root forest set to the result of the given function.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "modBranchForest: <A>(f: "
            },
            {
              "kind": "Content",
              "text": "(a: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "((self: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>)"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "returnTypeTokenRange": {
            "startIndex": 7,
            "endIndex": 12
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "f",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "modBranchForest"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!modForest:var",
          "docComment": "/**\n * Run a function to change the root node forest. If the tree is a {@link Leaf} the given function will receive the empty array as a parameter, if it returns any trees then leaves will be turned into a {@link Branch}es, and if it returns the empty array branches will be turned into leaves.\n *\n * @param self - Tree on which to run the given function.\n *\n * @param f - Function to apply on the root forest.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns The given tree with its root forest set to the result of the given function.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "modForest: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, f: "
            },
            {
              "kind": "Reference",
              "text": "EndoOf",
              "canonicalReference": "effect-tree!EndoOf:interface"
            },
            {
              "kind": "Content",
              "text": "<readonly "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]>): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(f: "
            },
            {
              "kind": "Reference",
              "text": "EndoOf",
              "canonicalReference": "effect-tree!EndoOf:interface"
            },
            {
              "kind": "Content",
              "text": "<readonly "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]>): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "modForest",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 18
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!modValue:var",
          "docComment": "/**\n * Run a function to change the value, but not the type, of the top level node of the given tree.\n *\n * @param self - Tree on which to run the given function.\n *\n * @param f - Function to apply on the root node value.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns The given tree with its root node value set to the result of the given function.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "modValue: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, f: (a: A) => A): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(f: (a: A) => A): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "modValue",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 10
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!Monad:var",
          "docComment": "/**\n * Monad instance for {@link Tree}.  @category instances\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "Monad: "
            },
            {
              "kind": "Reference",
              "text": "MD.Monad",
              "canonicalReference": "@effect/typeclass!Monad:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/instances/Monad.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "Monad",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!MonoidAverage:var",
          "docComment": "/**\n * A monoid for running a running average.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "MonoidAverage: "
            },
            {
              "kind": "Reference",
              "text": "Monoid.Monoid",
              "canonicalReference": "@effect/typeclass!Monoid:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "RunningAverage",
              "canonicalReference": "effect-tree!RunningAverage:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "MonoidAverage",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!monoidFold:function(1)",
          "docComment": "/**\n * Fold a single level of a tree using a monoid of the node type.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "monoidFold: <A>(M: "
            },
            {
              "kind": "Reference",
              "text": "Monoid.Monoid",
              "canonicalReference": "@effect/typeclass!Monoid:interface"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "M",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "monoidFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!multiply:function(1)",
          "docComment": "/**\n * Multiply all node values in a numeric tree and return the product.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "multiply: (tree: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<number>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "number"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "tree",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "multiply"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!nAryTree:var",
          "docComment": "/**\n * Create an N-ary level tree with the given degree at the given depth. In a _level tree_, the value of each node is set to its depth. An N-ary tree is one where all nodes, except the leaves, have the same child count.\n *\n * At the key `string` you will find a version that returns the tree where nodes have been formatted as strings instead of number.\n *\n * @param settings - The child count for all nodes except leaves, and the tree depth requested.\n *\n * @returns An N-ary level tree of the given depth..  @category ops  @function\n *\n * @example\n *\n * import {nAryTree, drawTree} from 'effect-tree'\n *\n * const tree = nAryTree({depth: 2, degree: 4})\n *\n * console.log(drawTree.unlines(tree))\n *\n * // ┬1 // ├─2 // ├─2 // ├─2 // └─2\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "nAryTree: "
            },
            {
              "kind": "Content",
              "text": "{\n    ({ degree, depth, }: {\n        degree: number;\n        depth: number;\n    }): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<number>;\n    string: (a_0: {\n        degree: number;\n        depth: number;\n    }) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<string>;\n}"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "nAryTree",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!nodeCount:var",
          "docComment": "/**\n * Count all nodes that are descendants of the root node and the root node itself.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "nodeCount: "
            },
            {
              "kind": "Reference",
              "text": "TreeFoldOf",
              "canonicalReference": "effect-tree!TreeFoldOf:type"
            },
            {
              "kind": "Content",
              "text": "<number>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "nodeCount",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!nodeCountAtLeast:function(1)",
          "docComment": "/**\n * True if node count is at least the given number. Will short-circuit when condition is reached rather than traverse entire tree.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "nodeCountAtLeast: (atLeast: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "<A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => boolean"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "atLeast",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "nodeCountAtLeast"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!nodeCountAtLeastFold:function(1)",
          "docComment": "/**\n * Fails if node count is at least the given number.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "nodeCountAtLeastFold: (atLeast: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectFolderOf",
              "canonicalReference": "effect-tree!TreeEffectFolderOf:interface"
            },
            {
              "kind": "Content",
              "text": "<number, void>"
            }
          ],
          "fileUrlPath": "src/ops/counts.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "atLeast",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "nodeCountAtLeastFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!nodeOrdinalFold:function(1)",
          "docComment": "/**\n * Fold nodes of a tree level to their ordinal in depth-first pre-order.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "nodeOrdinalFold: (counter: "
            },
            {
              "kind": "Reference",
              "text": "Ref.Ref",
              "canonicalReference": "effect!Ref:interface"
            },
            {
              "kind": "Content",
              "text": "<number>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "<A, E = never, R = never>(_: "
            },
            {
              "kind": "Reference",
              "text": "Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, number>>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<number, E, R>"
            }
          ],
          "fileUrlPath": "src/ops/ordinal.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "counter",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "nodeOrdinalFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!nodeOrdinalUnfold:function(1)",
          "docComment": "/**\n * Unfold nodes of a tree level to their ordinal in depth-first pre-order.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "nodeOrdinalUnfold: (counter: "
            },
            {
              "kind": "Reference",
              "text": "Ref.Ref",
              "canonicalReference": "effect!Ref:interface"
            },
            {
              "kind": "Content",
              "text": "<number>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "<A, E = never, R = never>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<number, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>, E, R>"
            }
          ],
          "fileUrlPath": "src/ops/ordinal.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 13
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "counter",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "nodeOrdinalUnfold"
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!NonEmptyArray2:type",
          "docComment": "/**\n * A 2D readonly non-empty array of `A`.  @category basic\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type NonEmptyArray2<A> = "
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray",
              "canonicalReference": "effect!NonEmptyArray:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray",
              "canonicalReference": "effect!NonEmptyArray:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/util/Array/transpose.ts",
          "releaseTag": "Public",
          "name": "NonEmptyArray2",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!NonEmptyArray2TypeLambda:type",
          "docComment": "/**\n * A type lambda for 2D non-empty arrays.  @category refold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type NonEmptyArray2TypeLambda = "
            },
            {
              "kind": "Reference",
              "text": "ComposeTypeLambda",
              "canonicalReference": "effect-ts-laws!ComposeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArrayTypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", "
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArrayTypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/types.ts",
          "releaseTag": "Public",
          "name": "NonEmptyArray2TypeLambda",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface",
          "docComment": "/**\n * A type lambda for non-empty arrays.  @category refold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface NonEmptyArrayTypeLambda extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": " "
            }
          ],
          "fileUrlPath": "src/schemes/types.ts",
          "releaseTag": "Public",
          "name": "NonEmptyArrayTypeLambda",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda#type:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "readonly type: "
                },
                {
                  "kind": "Reference",
                  "text": "Array.NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<this['Target']>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": true,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "type",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "extendsTokenRanges": [
            {
              "startIndex": 1,
              "endIndex": 2
            }
          ]
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!nthChild:var",
          "docComment": "/**\n * Return the Nth child tree of a tree or `Option.none()` if index is out-of-bounds or if given tree is a leaf.\n *\n * Negative indexes are handled as offsets from the end of the forest with `-1` being the last child, `-2` the child before it, and so on.\n *\n * @param n - index of requested node in parent forest. Negative indexes are accepted.\n *\n * @param self - Node will be taken from this tree's forest.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns An optional tree.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "nthChild: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(n: number, self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): "
            },
            {
              "kind": "Reference",
              "text": "Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (n: number) => "
            },
            {
              "kind": "Reference",
              "text": "Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n    flip: (n: number) => <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "nthChild",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 20
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!numericMaxFold:var",
          "docComment": "/**\n * Find maximum node value in a level of a numeric tree.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "numericMaxFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "numericMaxFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!numericMinFold:var",
          "docComment": "/**\n * Find minimum node value in a level of a numeric tree.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "numericMinFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "numericMinFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!numericProductFold:var",
          "docComment": "/**\n * Multiply the node values of a single level in a numeric tree.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "numericProductFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "numericProductFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!numericSumFold:var",
          "docComment": "/**\n * Compute a running average for a single level in a numeric tree. Sum the nodes of a single level in a numeric tree.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "numericSumFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "numericSumFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!of:function(1)",
          "docComment": "/**\n * An alias for {@link leaf}.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "of: <A>(value: "
            },
            {
              "kind": "Content",
              "text": "A"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "import(\"../tree/types.js\")."
            },
            {
              "kind": "Reference",
              "text": "Leaf",
              "canonicalReference": "effect-tree!Leaf:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/instances/Monad.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "value",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "of"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!postOrderFold:var",
          "docComment": "/**\n * Collect nodes in depth-first post-order for a single tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "postOrderFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolderK",
              "canonicalReference": "effect-tree!TreeFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArrayTypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/ops/traverse.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "postOrderFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!postOrderValues:var",
          "docComment": "/**\n * Return all tree values in depth-first post-order. Parents appear _after_ their children. For example:\n * ```txt\n * // ┬1\n * // ├┬2\n * // │└┬3\n * // │ └─4\n * // └─5\n * const myTree = branch(\n *   1, [\n *     branch(2, [\n *       branch(3, [\n *         leaf(4),\n *       ]),\n *     ]),\n *     leaf(5),\n *   ]\n * )\n *\n * const myValues = postOrderValues(myTree) // [4, 3, 2, 5, 1]\n * ```\n *\n * @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "postOrderValues: "
            },
            {
              "kind": "Reference",
              "text": "GetNodes",
              "canonicalReference": "effect-tree!GetNodes:type"
            }
          ],
          "fileUrlPath": "src/ops/traverse.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "postOrderValues",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!predicateFold:function(1)",
          "docComment": "/**\n * Fold single level in a tree of type `A` using a predicate of `A` and a boolean monoid.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "predicateFold: (M: "
            },
            {
              "kind": "Reference",
              "text": "Monoid.Monoid",
              "canonicalReference": "@effect/typeclass!Monoid:interface"
            },
            {
              "kind": "Content",
              "text": "<boolean>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "<A>(predicate: "
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, boolean>"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "M",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "predicateFold"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!preOrderFold:var",
          "docComment": "/**\n * Collect nodes in depth-first pre-order for a single tree level.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "preOrderFold: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolderK",
              "canonicalReference": "effect-tree!TreeFolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArrayTypeLambda",
              "canonicalReference": "effect-tree!NonEmptyArrayTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/ops/traverse.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "preOrderFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!preOrderValues:var",
          "docComment": "/**\n * Return all tree values in depth-first pre-order. Parents appear _before_ their children. For example:\n * ```txt\n * // ┬1\n * // ├┬2\n * // │└┬3\n * // │ └─4\n * // └─5\n * const myTree = branch(\n *   1, [\n *     branch(2, [\n *       branch(3, [\n *         leaf(4),\n *       ]),\n *     ]),\n *     leaf(5),\n *   ]\n * )\n * const myValues = preOrderValues(myTree) // [1, 2, 3, 4, 5]\n * ```\n *\n * @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "preOrderValues: "
            },
            {
              "kind": "Reference",
              "text": "GetNodes",
              "canonicalReference": "effect-tree!GetNodes:type"
            }
          ],
          "fileUrlPath": "src/ops/traverse.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "preOrderValues",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!prepend:var",
          "docComment": "/**\n * Prepend a tree to the children of the root node. If `self` is a _leaf_, it is converted into a branch.\n *\n * @param self - The tree to modify.\n *\n * @param child - Child to prepend.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns A new updated tree with the new node prepended.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "prepend: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, child: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(child: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/add.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "prepend",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 14
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!prependAll:var",
          "docComment": "/**\n * Prepend a list of trees to the children of the root node. If `self` is a _leaf_, it is converted into a branch.\n *\n * @param self - The tree to modify.\n *\n * @param children - A non-empty list of trees to prepend to the tree.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns A new updated tree with the new nodes prepended.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "prependAll: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, children: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(children: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/add.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "prependAll",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 14
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!product:var",
          "docComment": "/**\n * Cartesian product of two trees.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "product: "
            },
            {
              "kind": "Reference",
              "text": "SA.SemiApplicative",
              "canonicalReference": "@effect/typeclass!SemiApplicative:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">['product']"
            }
          ],
          "fileUrlPath": "src/instances/Applicative.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "product",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!productAll:var",
          "docComment": "/**\n * Compute the cartesian product of multiple trees into a single tree. Returns a leaf node containing an empty array if the input is empty.\n *\n * @param collection - Cartesian product will be computed on this iterable of trees.\n *\n * @returns The tree that is the cartesian product of all given trees.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "productAll: "
            },
            {
              "kind": "Reference",
              "text": "AP.Applicative",
              "canonicalReference": "@effect/typeclass!Applicative:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">['productAll']"
            }
          ],
          "fileUrlPath": "src/instances/Applicative.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "productAll",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!productMany:function(1)",
          "docComment": "/**\n * @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "productMany: <R, O, E, A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ", collection: "
            },
            {
              "kind": "Reference",
              "text": "Iterable",
              "canonicalReference": "!Iterable:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<[A, ...A[]]>"
            }
          ],
          "fileUrlPath": "src/instances/Applicative.ts",
          "returnTypeTokenRange": {
            "startIndex": 9,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "collection",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 8
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "O",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "productMany"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!reduce:var",
          "docComment": "/**\n * Reduce a tree to a value of type `B` by applying the given reducer repeatedly over each element and the previous result of the reducer.\n *\n * @param self - The tree being reduced.\n *\n * @param initial - The initial value will appear as the _previous_ value in the first iteration of the reducer.\n *\n * @typeParam A - The tree type.\n *\n * @returns - Reduced value of the same type as the given `initial` value.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "reduce: "
            },
            {
              "kind": "Reference",
              "text": "FO.Foldable",
              "canonicalReference": "@effect/typeclass!Foldable:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">['reduce']"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "reduce",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!removeFirstChild:function(1)",
          "docComment": "/**\n * Remove first child of given tree.\n *\n * @param self - The tree from which a node will be removed.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns The tree with on less node.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "removeFirstChild: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/remove.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "removeFirstChild"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!removeForest:function(1)",
          "docComment": "/**\n * Strip a branch from its children and return the new leaf.\n *\n * @param self - The tree from which all nodes will be removed.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns A leaf tree node.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "removeForest: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Leaf",
              "canonicalReference": "effect-tree!Leaf:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/remove.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "removeForest"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!removeLastChild:function(1)",
          "docComment": "/**\n * Remove last child of given tree.\n *\n * @param self - The tree from which a node will be removed.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns The tree with on less node.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "removeLastChild: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            }
          ],
          "fileUrlPath": "src/tree/remove.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "removeLastChild"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!removeNthChild:var",
          "docComment": "/**\n * Removes the Nth direct child of the given tree. If the tree is a branch with a single child then a `Leaf` is returned. If the given index is out-of-bounds, or the given tree is a leaf, it is returned unchanged.\n *\n * @param n - Index in root node forest of node that will be removed.\n *\n * @param self - The tree from which a node will be removed.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns The tree with on less node.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "removeNthChild: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(n: number, self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (n: number) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    flip: (n: number) => <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/remove.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "removeNthChild",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 14
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!removeSlice:function(1)",
          "docComment": "/**\n * Removes `deleteCount` children, starting Nth the direct child of the given tree. If the tree is a branch with a single child then a `Leaf` is returned.\n *\n * If the given index is out-of-bounds, or the given tree is a leaf, it is returned unchanged.\n *\n * If the `deleteCount` is beyond the edge of the list, removes all children from the Nth index.\n *\n * @param n - Index in root node forest.\n *\n * @param deleteCount - Count of nodes to be deleted.\n *\n * @typeParam A - Tree underlying type.\n *\n * @returns The tree with on less node.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "removeSlice: (n: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ", deleteCount: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "EndoK",
              "canonicalReference": "effect-tree!EndoK:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/tree/remove.ts",
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "n",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            },
            {
              "parameterName": "deleteCount",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "isOptional": false
            }
          ],
          "name": "removeSlice"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!replaceEffectFolder:function(1)",
          "docComment": "/**\n * Like {@link replaceFolder} but for _effect folders_.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "replaceEffectFolder: <A, B, E = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ">(φ: "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectFolder",
              "canonicalReference": "effect-tree!TreeEffectFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, B, E, R>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectFolder",
              "canonicalReference": "effect-tree!TreeEffectFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>, E, R>"
            }
          ],
          "fileUrlPath": "src/schemes/fold/replace.ts",
          "returnTypeTokenRange": {
            "startIndex": 8,
            "endIndex": 12
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "φ",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 7
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "name": "replaceEffectFolder"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!replaceFolder:function(1)",
          "docComment": "/**\n * Converts a fold `φ` into one that _replaces_ tree values: every tree node will be replaced with the intermediate value of the fold at the node.\n *\n * For example, to convert the `descendantCount` fold, that folds a tree into a _tree total descendant count_ to one where each node value is the _node total descendant count_:\n * ```ts\n * const replaced = pipe(\n *   tree(42, [leaf(43)]),\n *   self, treeCata(replaceFolder(folds.descendantCount))),\n * )\n * ```\n *\n * @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "replaceFolder: <A, B>(φ: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>>"
            }
          ],
          "fileUrlPath": "src/schemes/fold/replace.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "φ",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "replaceFolder"
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!RunningAverage:interface",
          "docComment": "/**\n * A running average encoded as the _sum_ of all values encountered and the _count_ of all values encountered.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface RunningAverage "
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "releaseTag": "Public",
          "name": "RunningAverage",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "effect-tree!RunningAverage#denominator:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "denominator: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "denominator",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "effect-tree!RunningAverage#numerator:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "numerator: "
                },
                {
                  "kind": "Content",
                  "text": "number"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "numerator",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!RunningAverage:var",
          "docComment": "/**\n * A starting value for a {@link RunningAverage}.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "RunningAverage: "
            },
            {
              "kind": "Reference",
              "text": "RunningAverage",
              "canonicalReference": "effect-tree!RunningAverage:interface"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "RunningAverage",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!sequence:function(1)",
          "docComment": "/**\n * Convert a `Tree<F<A>>` into a `F<Tree<A>>`.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "sequence: <F extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">(F: "
            },
            {
              "kind": "Reference",
              "text": "Applicative.Applicative",
              "canonicalReference": "@effect/typeclass!Applicative:interface"
            },
            {
              "kind": "Content",
              "text": "<F>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "<A, E = unknown, R = unknown, I = never>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, I, R, E, A>>) => "
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, I, R, E, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/instances/Traversable.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 15
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "F",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "F",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "sequence"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!sequenceEffect:function(1)",
          "docComment": "/**\n * Convert a `Tree<Effect<A>>` into an `Effect<Tree<A>>`.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "sequenceEffect: <A, E = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": ", O = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": ">(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<A, E, O>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, E, O>"
            }
          ],
          "fileUrlPath": "src/instances/Traversable.ts",
          "returnTypeTokenRange": {
            "startIndex": 10,
            "endIndex": 14
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 9
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "O",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "name": "sequenceEffect"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!setForest:var",
          "docComment": "/**\n * Set the root node forest to a given forest of the same type.\n *\n * @param self - The tree being changed.\n *\n * @param forest - New forest.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns A new tree where the forest has been replaced by the given forest.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "setForest: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, forest: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>): "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(forest: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    flip: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => (forest: "
            },
            {
              "kind": "Reference",
              "text": "ForestOf",
              "canonicalReference": "effect-tree!ForestOf:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "setForest",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 20
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!setValue:var",
          "docComment": "/**\n * Set the value of a tree root to a given value of the same type.\n *\n * @param self - The tree being changed.\n *\n * @param value - New value for the root node.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns A new tree where the root value has been replaced by the given value.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "setValue: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, value: A): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    <A>(value: A): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "setValue",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 10
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!sliceForest:var",
          "docComment": "/**\n * Get a slice from the forest of the given tree. An empty path will return the given tree.\n *\n * @param self - The tree to query. accepted.\n *\n * @param low - Index of slice start.\n *\n * @param high - Optional length of slice. Default is a single tree node.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns Possibly empty list of trees.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "sliceForest: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, low: number, high?: number): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[];\n    flip: <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => (low: number, high?: number) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[];\n    curry: (low: number, high?: number) => <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[];\n}"
            }
          ],
          "fileUrlPath": "src/tree/data.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "sliceForest",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 14
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!some:var",
          "docComment": "/**\n * True if some nodes in the given boolean tree are true.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "some: "
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<boolean>>"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "some",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!someFold:var",
          "docComment": "/**\n * @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "someFold: "
            },
            {
              "kind": "Reference",
              "text": "BooleanFolder",
              "canonicalReference": "effect-tree!BooleanFolder:type"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "someFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!someOf:var",
          "docComment": "/**\n * True if the given predicate is true for _some_ node or nodes in the given tree.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "someOf: "
            },
            {
              "kind": "Reference",
              "text": "BooleanFold",
              "canonicalReference": "effect-tree!BooleanFold:type"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "someOf",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!structTreeFolds:function(1)",
          "docComment": "/**\n * Create a fold that folds into a struct from a struct of folds.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "structTreeFolds: <const S extends "
            },
            {
              "kind": "Reference",
              "text": "Record",
              "canonicalReference": "!Record:type"
            },
            {
              "kind": "Content",
              "text": "<string, import(\"effect-ts-folds\")."
            },
            {
              "kind": "Reference",
              "text": "Algebra",
              "canonicalReference": "effect-ts-folds!Algebra:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", any>>"
            },
            {
              "kind": "Content",
              "text": ">(struct: "
            },
            {
              "kind": "Content",
              "text": "S"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "<E = unknown, R = unknown, I = never>(fas: "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<E, import(\"effect-ts-folds\")."
            },
            {
              "kind": "Reference",
              "text": "StructReturns",
              "canonicalReference": "effect-ts-folds!StructReturns:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", S, E, R, I>>) => import(\"effect/Types\")."
            },
            {
              "kind": "Reference",
              "text": "Simplify",
              "canonicalReference": "effect!Simplify:type"
            },
            {
              "kind": "Content",
              "text": "<import(\"effect-ts-folds\")."
            },
            {
              "kind": "Reference",
              "text": "StructReturns",
              "canonicalReference": "effect-ts-folds!StructReturns:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", S, E, R, I>>"
            }
          ],
          "fileUrlPath": "src/schemes/fold/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 10,
            "endIndex": 23
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "struct",
              "parameterTypeTokenRange": {
                "startIndex": 8,
                "endIndex": 9
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "S",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "structTreeFolds"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!sum:function(1)",
          "docComment": "/**\n * Sum all node values in a numeric tree.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "sum: (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<number>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "number"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "name": "sum"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!themedTree:var",
          "docComment": "/**\n * Draw a tree as a 2D array of glyphs in the given theme.\n *\n * At the key `unlines` you will find a version that joins output into a string.\n *\n * You can get themes by name using the {@link getTheme | getTheme function}.  @category drawing  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "themedTree: "
            },
            {
              "kind": "Content",
              "text": "{\n    (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<string>, theme: "
            },
            {
              "kind": "Reference",
              "text": "Theme",
              "canonicalReference": "effect-tree!Draw.Theme:interface"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray",
              "canonicalReference": "effect!NonEmptyArray:type"
            },
            {
              "kind": "Content",
              "text": "<string>;\n    (theme: "
            },
            {
              "kind": "Reference",
              "text": "Theme",
              "canonicalReference": "effect-tree!Draw.Theme:interface"
            },
            {
              "kind": "Content",
              "text": "): (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<string>) => "
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray",
              "canonicalReference": "effect!NonEmptyArray:type"
            },
            {
              "kind": "Content",
              "text": "<string>;\n    unlines: (theme: "
            },
            {
              "kind": "Reference",
              "text": "Theme",
              "canonicalReference": "effect-tree!Draw.Theme:interface"
            },
            {
              "kind": "Content",
              "text": ") => (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<string>) => string;\n}"
            }
          ],
          "fileUrlPath": "src/draw/tree/draw.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "themedTree",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 18
          }
        },
        {
          "kind": "Namespace",
          "canonicalReference": "effect-tree!These:namespace",
          "docComment": "",
          "excerptTokens": [],
          "fileUrlPath": "index.ts",
          "releaseTag": "None",
          "name": "These",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These._Both:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "_Both: <A, B>(args: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    readonly left: B;\n    readonly right: A;\n}"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "{\n    readonly _tag: \"Both\";\n    readonly left: B;\n    readonly right: A;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "args",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "B",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "_Both"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These._Left:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "_Left: <A, B>(args: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    readonly left: B;\n}"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "{\n    readonly _tag: \"Left\";\n    readonly left: B;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "args",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "B",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "_Left"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These._Right:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "_Right: <A, B>(args: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    readonly right: A;\n}"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "{\n    readonly _tag: \"Right\";\n    readonly right: A;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "args",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "B",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "_Right"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.$match:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "$match: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, B, C, D, Cases extends {\n        readonly Left: (args: {\n            readonly _tag: \"Left\";\n            readonly left: B;\n        }) => any;\n        readonly Right: (args: {\n            readonly _tag: \"Right\";\n            readonly right: A;\n        }) => any;\n        readonly Both: (args: {\n            readonly _tag: \"Both\";\n            readonly left: B;\n            readonly right: A;\n        }) => any;\n    }>(cases: Cases & { [K in "
                },
                {
                  "kind": "Reference",
                  "text": "Exclude",
                  "canonicalReference": "!Exclude:type"
                },
                {
                  "kind": "Content",
                  "text": "<keyof Cases, \"Left\" | \"Right\" | \"Both\">]: never; }): (self: {\n        readonly _tag: \"Left\";\n        readonly left: B;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: A;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: B;\n        readonly right: A;\n    }) => import(\"effect/Unify\")."
                },
                {
                  "kind": "Reference",
                  "text": "Unify",
                  "canonicalReference": "effect!Unify:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ReturnType",
                  "canonicalReference": "!ReturnType:type"
                },
                {
                  "kind": "Content",
                  "text": "<Cases[\"Left\" | \"Right\" | \"Both\"]>>;\n    <A, B, C, D, Cases extends {\n        readonly Left: (args: {\n            readonly _tag: \"Left\";\n            readonly left: B;\n        }) => any;\n        readonly Right: (args: {\n            readonly _tag: \"Right\";\n            readonly right: A;\n        }) => any;\n        readonly Both: (args: {\n            readonly _tag: \"Both\";\n            readonly left: B;\n            readonly right: A;\n        }) => any;\n    }>(self: {\n        readonly _tag: \"Left\";\n        readonly left: B;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: A;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: B;\n        readonly right: A;\n    }, cases: Cases & { [K in "
                },
                {
                  "kind": "Reference",
                  "text": "Exclude",
                  "canonicalReference": "!Exclude:type"
                },
                {
                  "kind": "Content",
                  "text": "<keyof Cases, \"Left\" | \"Right\" | \"Both\">]: never; }): import(\"effect/Unify\")."
                },
                {
                  "kind": "Reference",
                  "text": "Unify",
                  "canonicalReference": "effect!Unify:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ReturnType",
                  "canonicalReference": "!ReturnType:type"
                },
                {
                  "kind": "Content",
                  "text": "<Cases[\"Left\" | \"Right\" | \"Both\"]>>;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "$match",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.Bicovariant:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Bicovariant: "
                },
                {
                  "kind": "Reference",
                  "text": "BI.Bicovariant",
                  "canonicalReference": "@effect/typeclass!Bicovariant:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TheseTypeLambda",
                  "canonicalReference": "effect-tree!These.TheseTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/util/These/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "Bicovariant",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.bimap:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "bimap: "
                },
                {
                  "kind": "Reference",
                  "text": "BI.Bicovariant",
                  "canonicalReference": "@effect/typeclass!Bicovariant:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TheseTypeLambda",
                  "canonicalReference": "effect-tree!These.TheseTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">['bimap']"
                }
              ],
              "fileUrlPath": "src/util/These/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "bimap",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.both:function(1)",
              "docComment": "/**\n * Build a `Both` from left and right values.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "both: <R, E>(left: "
                },
                {
                  "kind": "Content",
                  "text": "E"
                },
                {
                  "kind": "Content",
                  "text": ", right: "
                },
                {
                  "kind": "Content",
                  "text": "R"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "left",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "right",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "both"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!These.Both:type",
              "docComment": "/**\n * A `These` with both a `right` and a `left`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Both<R, E> = "
                },
                {
                  "kind": "Reference",
                  "text": "TaggedEnum.Value",
                  "canonicalReference": "effect!TaggedEnum.Value:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>, 'Both'>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "name": "Both",
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.Both:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Both: "
                },
                {
                  "kind": "Content",
                  "text": "(<A, B>(args: {\n    readonly left: B;\n    readonly right: A;\n}) => {\n    readonly _tag: \"Both\";\n    readonly left: B;\n    readonly right: A;\n}) & {\n    from: <R, E>(right: R, left: E) => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "Both",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!These.BothSides:interface",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface BothSides<R, E> "
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "BothSides",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!These.BothSides#left:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "left: "
                    },
                    {
                      "kind": "Content",
                      "text": "E"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "left",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!These.BothSides#right:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "right: "
                    },
                    {
                      "kind": "Content",
                      "text": "R"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "right",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.combine:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "combine: <E>(eSemigroup: "
                },
                {
                  "kind": "Reference",
                  "text": "Semigroup.Semigroup",
                  "canonicalReference": "@effect/typeclass!Semigroup:interface"
                },
                {
                  "kind": "Content",
                  "text": "<E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "<R>(rSemigroup: "
                },
                {
                  "kind": "Reference",
                  "text": "Semigroup.Semigroup",
                  "canonicalReference": "@effect/typeclass!Semigroup:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R>) => (self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>, that: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>) => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                }
              ],
              "fileUrlPath": "src/util/These/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 13
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "eSemigroup",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "combine"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.getEquivalence:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getEquivalence: <E>(equalsE: "
                },
                {
                  "kind": "Reference",
                  "text": "Equivalence.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "<R>(equalsR: "
                },
                {
                  "kind": "Reference",
                  "text": "Equivalence.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Equivalence.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>>"
                }
              ],
              "fileUrlPath": "src/util/These/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 11
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "equalsE",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getEquivalence"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.getOrder:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getOrder: <E>(orderE: "
                },
                {
                  "kind": "Reference",
                  "text": "Order.Order",
                  "canonicalReference": "effect!Order:interface"
                },
                {
                  "kind": "Content",
                  "text": "<E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "<R>(orderR: "
                },
                {
                  "kind": "Reference",
                  "text": "Order.Order",
                  "canonicalReference": "effect!Order:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Order.Order",
                  "canonicalReference": "effect!Order:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>>"
                }
              ],
              "fileUrlPath": "src/util/These/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 11
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "orderE",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getOrder"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.getSemigroup:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getSemigroup: <B>(semigroupB: "
                },
                {
                  "kind": "Reference",
                  "text": "Semigroup.Semigroup",
                  "canonicalReference": "@effect/typeclass!Semigroup:interface"
                },
                {
                  "kind": "Content",
                  "text": "<B>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "<A>(semigroupA: "
                },
                {
                  "kind": "Reference",
                  "text": "Semigroup.Semigroup",
                  "canonicalReference": "@effect/typeclass!Semigroup:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Semigroup.Semigroup",
                  "canonicalReference": "@effect/typeclass!Semigroup:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, B>>"
                }
              ],
              "fileUrlPath": "src/util/These/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 11
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "semigroupB",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "B",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getSemigroup"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.isBoth:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isBoth: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <T extends {\n        readonly _tag: \"Left\";\n        readonly left: any;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: any;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: any;\n        readonly right: any;\n    }>(u: T): "
                },
                {
                  "kind": "Reference",
                  "text": "u",
                  "canonicalReference": "effect-tree!~u"
                },
                {
                  "kind": "Content",
                  "text": " is T & {\n        readonly _tag: \"Both\";\n    };\n    (u: unknown): "
                },
                {
                  "kind": "Reference",
                  "text": "u",
                  "canonicalReference": "effect-tree!~u"
                },
                {
                  "kind": "Content",
                  "text": " is {\n        readonly _tag: \"Both\";\n        readonly left: unknown;\n        readonly right: unknown;\n    };\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "isBoth",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.isLeft:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isLeft: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <T extends {\n        readonly _tag: \"Left\";\n        readonly left: any;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: any;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: any;\n        readonly right: any;\n    }>(u: T): "
                },
                {
                  "kind": "Reference",
                  "text": "u",
                  "canonicalReference": "effect-tree!~u"
                },
                {
                  "kind": "Content",
                  "text": " is T & {\n        readonly _tag: \"Left\";\n    };\n    (u: unknown): "
                },
                {
                  "kind": "Reference",
                  "text": "u",
                  "canonicalReference": "effect-tree!~u"
                },
                {
                  "kind": "Content",
                  "text": " is {\n        readonly _tag: \"Left\";\n        readonly left: unknown;\n    };\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "isLeft",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.isRight:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isRight: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <T extends {\n        readonly _tag: \"Left\";\n        readonly left: any;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: any;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: any;\n        readonly right: any;\n    }>(u: T): "
                },
                {
                  "kind": "Reference",
                  "text": "u",
                  "canonicalReference": "effect-tree!~u"
                },
                {
                  "kind": "Content",
                  "text": " is T & {\n        readonly _tag: \"Right\";\n    };\n    (u: unknown): "
                },
                {
                  "kind": "Reference",
                  "text": "u",
                  "canonicalReference": "effect-tree!~u"
                },
                {
                  "kind": "Content",
                  "text": " is {\n        readonly _tag: \"Right\";\n        readonly right: unknown;\n    };\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "isRight",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.isTheseOf:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isTheseOf: <Tag extends "
                },
                {
                  "kind": "Content",
                  "text": "\"Left\" | \"Right\" | \"Both\""
                },
                {
                  "kind": "Content",
                  "text": ">(tag: "
                },
                {
                  "kind": "Content",
                  "text": "Tag"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <T extends {\n        readonly _tag: \"Left\";\n        readonly left: any;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: any;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: any;\n        readonly right: any;\n    }>(u: T): "
                },
                {
                  "kind": "Reference",
                  "text": "u",
                  "canonicalReference": "effect-tree!~u"
                },
                {
                  "kind": "Content",
                  "text": " is T & {\n        readonly _tag: Tag;\n    };\n    (u: unknown): "
                },
                {
                  "kind": "Reference",
                  "text": "u",
                  "canonicalReference": "effect-tree!~u"
                },
                {
                  "kind": "Content",
                  "text": " is "
                },
                {
                  "kind": "Reference",
                  "text": "Extract",
                  "canonicalReference": "!Extract:type"
                },
                {
                  "kind": "Content",
                  "text": "<{\n        readonly _tag: \"Left\";\n        readonly left: unknown;\n    }, {\n        readonly _tag: Tag;\n    }> | "
                },
                {
                  "kind": "Reference",
                  "text": "Extract",
                  "canonicalReference": "!Extract:type"
                },
                {
                  "kind": "Content",
                  "text": "<{\n        readonly _tag: \"Right\";\n        readonly right: unknown;\n    }, {\n        readonly _tag: Tag;\n    }> | "
                },
                {
                  "kind": "Reference",
                  "text": "Extract",
                  "canonicalReference": "!Extract:type"
                },
                {
                  "kind": "Content",
                  "text": "<{\n        readonly _tag: \"Both\";\n        readonly left: unknown;\n        readonly right: unknown;\n    }, {\n        readonly _tag: Tag;\n    }>;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 16
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "tag",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "Tag",
                  "constraintTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "isTheseOf"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.join:function(1)",
              "docComment": "/**\n * Use the given `Semigroup` instance to join the left and right sides of the given `These` into a single value.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "join: <A>(S: "
                },
                {
                  "kind": "Reference",
                  "text": "Semigroup",
                  "canonicalReference": "@effect/typeclass!Semigroup:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(self: {\n    readonly _tag: \"Left\";\n    readonly left: A;\n} | {\n    readonly _tag: \"Right\";\n    readonly right: A;\n} | {\n    readonly _tag: \"Both\";\n    readonly left: A;\n    readonly right: A;\n}) => import(\"effect/Unify\")."
                },
                {
                  "kind": "Reference",
                  "text": "Unify",
                  "canonicalReference": "effect!Unify:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "S",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "join"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.left:function(1)",
              "docComment": "/**\n * Build a `Left` from a left value.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "left: <E>(left: "
                },
                {
                  "kind": "Content",
                  "text": "E"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<never, E>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "left",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "left"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!These.Left:type",
              "docComment": "/**\n * A `These` with only a `left` and no `right`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Left<R, E> = "
                },
                {
                  "kind": "Reference",
                  "text": "TaggedEnum.Value",
                  "canonicalReference": "effect!TaggedEnum.Value:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>, 'Left'>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "name": "Left",
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.Left:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Left: "
                },
                {
                  "kind": "Content",
                  "text": "(<A, B>(args: {\n    readonly left: B;\n}) => {\n    readonly _tag: \"Left\";\n    readonly left: B;\n}) & {\n    from: <R, E>(left: E) => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "Left",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.leftOption:function(1)",
              "docComment": "/**\n * Extract the left value of the given {@link These} as an `Option`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "leftOption: <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<E>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "leftOption"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!These.LeftSide:type",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type LeftSide<E> = "
                },
                {
                  "kind": "Reference",
                  "text": "OneSide",
                  "canonicalReference": "effect-tree!These.OneSide:type"
                },
                {
                  "kind": "Content",
                  "text": "<'left', E>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "name": "LeftSide",
              "typeParameters": [
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.mapLeft:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "mapLeft: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <E, G>(f: (e: E) => G): <R, O, A>(self: {\n        readonly _tag: \"Left\";\n        readonly left: E;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: A;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: E;\n        readonly right: A;\n    }) => {\n        readonly _tag: \"Left\";\n        readonly left: G;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: A;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: G;\n        readonly right: A;\n    };\n    <R, O_1, E, A_1, G_1>(self: {\n        readonly _tag: \"Left\";\n        readonly left: E;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: A_1;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: E;\n        readonly right: A_1;\n    }, f: (e: E) => G_1): {\n        readonly _tag: \"Left\";\n        readonly left: G_1;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: A_1;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: G_1;\n        readonly right: A_1;\n    };\n}"
                }
              ],
              "fileUrlPath": "src/util/These/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "mapLeft",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.mapRight:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "mapRight: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, B>(f: (a: A) => B): <R, O, E>(self: {\n        readonly _tag: \"Left\";\n        readonly left: E;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: A;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: E;\n        readonly right: A;\n    }) => {\n        readonly _tag: \"Left\";\n        readonly left: E;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: B;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: E;\n        readonly right: B;\n    };\n    <R, O, E, A, B>(self: {\n        readonly _tag: \"Left\";\n        readonly left: E;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: A;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: E;\n        readonly right: A;\n    }, f: (a: A) => B): {\n        readonly _tag: \"Left\";\n        readonly left: E;\n    } | {\n        readonly _tag: \"Right\";\n        readonly right: B;\n    } | {\n        readonly _tag: \"Both\";\n        readonly left: E;\n        readonly right: B;\n    };\n}"
                }
              ],
              "fileUrlPath": "src/util/These/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "mapRight",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.match:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "match: <R, E, Result>({ "
                },
                {
                  "kind": "Reference",
                  "text": "Left",
                  "canonicalReference": "effect-tree!~__type#Left"
                },
                {
                  "kind": "Content",
                  "text": ": onLeft, "
                },
                {
                  "kind": "Reference",
                  "text": "Right",
                  "canonicalReference": "effect-tree!~__type#Right"
                },
                {
                  "kind": "Content",
                  "text": ": onRight, "
                },
                {
                  "kind": "Reference",
                  "text": "Both",
                  "canonicalReference": "effect-tree!~__type#Both"
                },
                {
                  "kind": "Content",
                  "text": ": onBoth, }: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    Left: (left: "
                },
                {
                  "kind": "Reference",
                  "text": "Left",
                  "canonicalReference": "effect-tree!These.Left:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>) => Result;\n    Right: (right: "
                },
                {
                  "kind": "Reference",
                  "text": "Right",
                  "canonicalReference": "effect-tree!These.Right:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>) => Result;\n    Both: (both: "
                },
                {
                  "kind": "Reference",
                  "text": "Both",
                  "canonicalReference": "effect-tree!These.Both:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>) => Result;\n}"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>) => import(\"effect/Unify\")."
                },
                {
                  "kind": "Reference",
                  "text": "Unify",
                  "canonicalReference": "effect!Unify:type"
                },
                {
                  "kind": "Content",
                  "text": "<Result>"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 15,
                "endIndex": 20
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ Left: onLeft, Right: onRight, Both: onBoth, }",
                  "parameterTypeTokenRange": {
                    "startIndex": 7,
                    "endIndex": 14
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "Result",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "match"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!These.OneSide:type",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type OneSide<Side extends "
                },
                {
                  "kind": "Content",
                  "text": "'left' | 'right'"
                },
                {
                  "kind": "Content",
                  "text": ", A> = "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<Side, A>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "name": "OneSide",
              "typeParameters": [
                {
                  "typeParameterName": "Side",
                  "constraintTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 3,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.onlyBoth:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "onlyBoth: <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<[R, E]>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "onlyBoth"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.onlyLeft:function(1)",
              "docComment": "/**\n * Extract the left value of the given {@link These} as an `Option`, but only if it is a `Left`. If it is `Both`, `Option.none()` is returned.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "onlyLeft: <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<E>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "onlyLeft"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.onlyOne:function(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "onlyOne: <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Either.Either",
                  "canonicalReference": "effect!Either:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "onlyOne"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.onlyRight:function(1)",
              "docComment": "/**\n * Extract the left value of the given {@link These} as an `Option`, but only if it is a `Left`. If it is `Both`, `Option.none()` is returned.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "onlyRight: <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<R>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "onlyRight"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.pad:function(1)",
              "docComment": "/**\n * Convert a `These` into a pair of right option and left option.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "pad: <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "["
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<R>, "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<E>]"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 9
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "pad"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.right:function(1)",
              "docComment": "/**\n * Build a `Left` from a left value.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "right: <R>(right: "
                },
                {
                  "kind": "Content",
                  "text": "R"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, unknown>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "right",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "right"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!These.Right:type",
              "docComment": "/**\n * A `These` with only a `right` and no `left`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type Right<R, E> = "
                },
                {
                  "kind": "Reference",
                  "text": "TaggedEnum.Value",
                  "canonicalReference": "effect!TaggedEnum.Value:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>, 'Right'>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "name": "Right",
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.Right:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Right: "
                },
                {
                  "kind": "Content",
                  "text": "(<A, B>(args: {\n    readonly right: A;\n}) => {\n    readonly _tag: \"Right\";\n    readonly right: A;\n}) & {\n    from: <R, E>(right: R) => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "Right",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.rightOption:function(1)",
              "docComment": "/**\n * Extract the right value of the given {@link These} as an `Option`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "rightOption: <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<R>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "rightOption"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!These.RightSide:type",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type RightSide<R> = "
                },
                {
                  "kind": "Reference",
                  "text": "OneSide",
                  "canonicalReference": "effect-tree!These.OneSide:type"
                },
                {
                  "kind": "Content",
                  "text": "<'right', R>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "name": "RightSide",
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.setLeft:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "setLeft: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <R, E, D>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>, d: D): "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, D>;\n    <D>(d: D): <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>) => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, D>;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "setLeft",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.setRight:var",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "setRight: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <R, E, S>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>, s: S): "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<S, E>;\n    <S>(s: S): <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>) => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<S, E>;\n}"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "setRight",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.swap:function(1)",
              "docComment": "/**\n * Swap left-right sides of a {@link These}.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "swap: <R, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<E, R>"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "swap"
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!These.These:type",
              "docComment": "/**\n * Just like `Either`, a data type representing a union of a value of the `Left` type and a value of the `Right` type.\n *\n * Unlike `Either`, `These` has a third member in its union, called `Both`, that has both a `Left` value _and_ a `Right` value. Representing, for example, the results of an operation that can succeed partially, returning some errors with its results.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type These<R, E> = "
                },
                {
                  "kind": "Reference",
                  "text": "TaggedEnum",
                  "canonicalReference": "effect!TaggedEnum:type"
                },
                {
                  "kind": "Content",
                  "text": "<{\n    Left: "
                },
                {
                  "kind": "Reference",
                  "text": "LeftSide",
                  "canonicalReference": "effect-tree!These.LeftSide:type"
                },
                {
                  "kind": "Content",
                  "text": "<E>;\n    Right: "
                },
                {
                  "kind": "Reference",
                  "text": "RightSide",
                  "canonicalReference": "effect-tree!These.RightSide:type"
                },
                {
                  "kind": "Content",
                  "text": "<R>;\n    Both: "
                },
                {
                  "kind": "Reference",
                  "text": "BothSides",
                  "canonicalReference": "effect-tree!These.BothSides:interface"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>;\n}>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "name": "These",
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 1,
                "endIndex": 9
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!These.TheseDefinition:interface",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface TheseDefinition extends "
                },
                {
                  "kind": "Reference",
                  "text": "TaggedEnum.WithGenerics",
                  "canonicalReference": "effect!TaggedEnum.WithGenerics:interface"
                },
                {
                  "kind": "Content",
                  "text": "<2>"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "name": "TheseDefinition",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!These.TheseDefinition#taggedEnum:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "readonly taggedEnum: "
                    },
                    {
                      "kind": "Reference",
                      "text": "These",
                      "canonicalReference": "effect-tree!These.These_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<this['A'], this['B']>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": true,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "taggedEnum",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 3
                }
              ]
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!These.TheseTypeLambda:interface",
              "docComment": "/**\n * `Kind<TheseTypeLambda, never, unknown, B, A> = These<A, B>`\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface TheseTypeLambda extends "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.TypeLambda",
                  "canonicalReference": "effect!TypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/util/These/index.ts",
              "releaseTag": "Public",
              "name": "TheseTypeLambda",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!These.TheseTypeLambda#type:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "readonly type: "
                    },
                    {
                      "kind": "Reference",
                      "text": "These",
                      "canonicalReference": "effect-tree!These.These_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<this['Target'], this['Out1']>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": true,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "type",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 2
                }
              ]
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.unzipArray:function(1)",
              "docComment": "/**\n * Unzip a list of `These` into two arrays of possibly different size. The inverse of {@link zipArrays} in the sense that `flow(zipArrays, unzipArray)` is identity.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "unzipArray: <A, B>(self: "
                },
                {
                  "kind": "Content",
                  "text": "readonly "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, B>[]"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "readonly [left: A[], right: B[]]"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 4
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "B",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "unzipArray"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!These.zipArrays:var",
              "docComment": "/**\n * Zip a pair of arrays. In case of arrays that are not of equal size, we do not _crop_ as the default `Array.zip` does. Instead we wrap the results in a {@link These}, which gives us an operation that is pleasantly associative, as well as reversible with no loss of information.\n *\n * If the _left_ array is longer, the result will end in one or more `Left<A,B>`.\n *\n * If the _right_ array is longer, the result will end in one or more `Right<A,B>`.\n *\n * If they are both of equal size, all elements will be of type `Both<A,B>`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "zipArrays: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, B>(left: readonly A[], right: readonly B[]): readonly "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, B>[];\n    <B>(right: readonly B[]): <A>(left: readonly A[]) => readonly "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, B>[];\n}"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "zipArrays",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!These.zipArraysWith:function(1)",
              "docComment": "/**\n * Zip a pair of arrays in an associative fashion without cropping.\n *\n * Missing values will appear as `Left` or `Right`, shared values as `Both`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "zipArraysWith: <R, E, Result>(right: "
                },
                {
                  "kind": "Content",
                  "text": "readonly R[]"
                },
                {
                  "kind": "Content",
                  "text": ", left: "
                },
                {
                  "kind": "Content",
                  "text": "readonly E[]"
                },
                {
                  "kind": "Content",
                  "text": ", f: "
                },
                {
                  "kind": "Content",
                  "text": "(these: "
                },
                {
                  "kind": "Reference",
                  "text": "These",
                  "canonicalReference": "effect-tree!These.These_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<R, E>) => Result"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "readonly Result[]"
                }
              ],
              "fileUrlPath": "src/util/These/ops.ts",
              "returnTypeTokenRange": {
                "startIndex": 9,
                "endIndex": 10
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "right",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "left",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "f",
                  "parameterTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 8
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "Result",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "zipArraysWith"
            }
          ]
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!toRunningAverage:function(1)",
          "docComment": "/**\n * Create a new running average from a single sample.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "toRunningAverage: (numerator: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "RunningAverage",
              "canonicalReference": "effect-tree!RunningAverage:interface"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 4
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "numerator",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "toRunningAverage"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!Traversable:var",
          "docComment": "/**\n * Traversable instance for {@link Tree}.  @category instances\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "Traversable: "
            },
            {
              "kind": "Reference",
              "text": "traversable.Traversable",
              "canonicalReference": "@effect/typeclass!Traversable:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/instances/Traversable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "Traversable",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!traverse:var",
          "docComment": "/**\n * `traverse` for {@link Tree}.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "traverse: "
            },
            {
              "kind": "Reference",
              "text": "traversable.Traversable",
              "canonicalReference": "@effect/typeclass!Traversable:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeTypeLambda",
              "canonicalReference": "effect-tree!TreeTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">['traverse']"
            }
          ],
          "fileUrlPath": "src/instances/Traversable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "traverse",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!traverseEffect:var",
          "docComment": "/**\n * Like {@link traverse} but leaves the result in an effect.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "traverseEffect: "
            },
            {
              "kind": "Content",
              "text": "(<F extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">(F: "
            },
            {
              "kind": "Reference",
              "text": "Applicative.Applicative",
              "canonicalReference": "@effect/typeclass!Applicative:interface"
            },
            {
              "kind": "Content",
              "text": "<F>) => <A, B, E1 = unknown, R1 = unknown, I = never, E2 = never, R2 = never>(f: (a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, I, R1, E1, B>, E2, R2>) => (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, I, R1, E1, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>>, E2, R2>) & {\n    post: <F extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">(F: "
            },
            {
              "kind": "Reference",
              "text": "Applicative.Applicative",
              "canonicalReference": "@effect/typeclass!Applicative:interface"
            },
            {
              "kind": "Content",
              "text": "<F>) => <A, B, E1 = unknown, R1 = unknown, I = never, E2 = never, R2 = never>(f: (a: A) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, I, R1, E1, B>, E2, R2>) => (self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, I, R1, E1, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>>, E2, R2>;\n}"
            }
          ],
          "fileUrlPath": "src/instances/Traversable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "traverseEffect",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 34
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!Tree:type",
          "docComment": "/**\n * A strict Rose tree with nodes carrying a value of type `A`. See the {@link TreeF} type for the _unfixed_ version, where `Tree<A>.unfixed ≡ TreeF<A, Tree<A>>`.\n *\n * The fully expanded version of the type of a _branch_ would look like:\n * ```ts\n * Tree<A> = {\n *   unfixed: {\n *     node: A\n *     forest: NonEmptyArray<Tree<A>>\n *   }\n * }\n * ```\n *\n * @typeParam A - Underlying tree type.  @category basic\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Tree<A> = "
            },
            {
              "kind": "Reference",
              "text": "Fix",
              "canonicalReference": "effect-ts-folds!Fix:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", A>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/tree/types.ts",
          "releaseTag": "Public",
          "name": "Tree",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!tree:var",
          "docComment": "/**\n * Create a new `Tree` from a node value and a possibly empty list of child nodes. If the given forest is missing or empty a {@link Leaf} will be returned, else a {@link Branch}.\n *\n * At the `curried` key you will find a curried version that accepts two argument lists: the first with the optional forest and the second with the required value.\n *\n * At the `flipped` key you will find a flipped curried version that accepts two argument lists: the first with the required value and the second with the optional forest.\n *\n * At the `tupled` key you will find a tupled version that accepts the arguments as a single tuple argument of value and optional forest.\n *\n * @param value - The tree root value.\n *\n * @param forest - A possibly empty or missing list of child nodes, all of the same type as this parent node.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns A new tree with the given value and possibly empty forest.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "tree: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A>(value: A, forest?: readonly "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    curried: <A>(forest: readonly "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]) => (value: A) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    flipped: <A>(value: A) => (forest?: readonly "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[]) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    tupled: <A>(pair: readonly [A, (readonly "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>[])?]) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n}"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "tree",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 18
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!treeAna:function(1)",
          "docComment": "/**\n * Unfold a tree.  @category unfold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "treeAna: <A, B>(ψ: "
            },
            {
              "kind": "Reference",
              "text": "TreeUnfolder",
              "canonicalReference": "effect-tree!TreeUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeUnfold",
              "canonicalReference": "effect-tree!TreeUnfold:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "ψ",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "treeAna"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!treeAnaE:function(1)",
          "docComment": "/**\n * Unfold a tree into an effect.  @category unfold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "treeAnaE: <A, B, E = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": ">(ψ: "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectUnfolder",
              "canonicalReference": "effect-tree!TreeEffectUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, B, E, R>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectUnfold",
              "canonicalReference": "effect-tree!TreeEffectUnfold:type"
            },
            {
              "kind": "Content",
              "text": "<A, B, E, R>"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 8,
            "endIndex": 10
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "ψ",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 7
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "name": "treeAnaE"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!treeCata:function(1)",
          "docComment": "/**\n * Run a {@link TreeFolder}<A, B> on a {@link Tree}<A> to fold into a value of type `B`.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "treeCata: <A, B>(φ: "
            },
            {
              "kind": "Reference",
              "text": "TreeFolder",
              "canonicalReference": "effect-tree!TreeFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFold",
              "canonicalReference": "effect-tree!TreeFold:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            }
          ],
          "fileUrlPath": "src/schemes/fold/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "φ",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "treeCata"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!treeCataEffect:function(1)",
          "docComment": "/**\n * Just like {@link treeCata}, except the folder is _effectful_.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "treeCataEffect: <A, B, E = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ">(φ: "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectFolder",
              "canonicalReference": "effect-tree!TreeEffectFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, B, E, R>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeEffectFold",
              "canonicalReference": "effect-tree!TreeEffectFold:type"
            },
            {
              "kind": "Content",
              "text": "<A, B, E, R>"
            }
          ],
          "fileUrlPath": "src/schemes/fold/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 8,
            "endIndex": 10
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "φ",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 7
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "name": "treeCataEffect"
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeEffectFold:type",
          "docComment": "/**\n * The result type of all effectful folds.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeEffectFold<A, B, E = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<B, E, R>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "name": "TreeEffectFold",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 5,
            "endIndex": 10
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeEffectFolder:type",
          "docComment": "/**\n * Just like {@link TreeFolder} except it folds into an effect. Same type as `EffectAlgebra<TreeFTypeLambda, B, E, R, A>.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeEffectFolder<A, B, E = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "(self: "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<B, E, R>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "name": "TreeEffectFolder",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 5,
            "endIndex": 10
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!TreeEffectFolderOf:interface",
          "docComment": "/**\n * A version of {@link TreeEffectFolder} where the node type is open.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface TreeEffectFolderOf<B, E = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": "> "
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "name": "TreeEffectFolderOf",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "CallSignature",
              "canonicalReference": "effect-tree!TreeEffectFolderOf:call(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "<A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF.TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, B>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "Effect.Effect",
                  "canonicalReference": "effect!Effect:interface"
                },
                {
                  "kind": "Content",
                  "text": "<B, E, R>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ]
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeEffectUnfold:type",
          "docComment": "/**\n * Same type as `EffectUnfold<TreeF.TreeFTypeLambda, B, E, R, A>`.  @category unfold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeEffectUnfold<A, B, E = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "(b: B) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, E, R>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/types.ts",
          "releaseTag": "Public",
          "name": "TreeEffectUnfold",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 5,
            "endIndex": 10
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeEffectUnfolder:type",
          "docComment": "/**\n * Same as {@link TreeUnfolder} except the unfolding function is into an `Effect`.\n *\n * Same type as `EffectCoalgebra<TreeFTypeLambda, B, E, R, A>.  @category unfold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeEffectUnfolder<A, B, E = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "(b: B) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>, E, R>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/types.ts",
          "releaseTag": "Public",
          "name": "TreeEffectUnfolder",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 5,
            "endIndex": 10
          }
        },
        {
          "kind": "Namespace",
          "canonicalReference": "effect-tree!TreeF:namespace",
          "docComment": "",
          "excerptTokens": [],
          "fileUrlPath": "index.ts",
          "releaseTag": "None",
          "name": "TreeF",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!TreeF.BranchF:interface",
              "docComment": "/**\n * A tree with non-empty list of child nodes.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.  @category fold\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface BranchF<A, C> extends "
                },
                {
                  "kind": "Reference",
                  "text": "LeafF",
                  "canonicalReference": "effect-tree!TreeF.LeafF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/treeF/types.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "BranchF",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!TreeF.BranchF#forest:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "forest: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Array.NonEmptyReadonlyArray",
                      "canonicalReference": "effect!NonEmptyReadonlyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<C>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "forest",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 3
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.branchF:var",
              "docComment": "/**\n * Create a branch from its value and a non-empty list of children.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "branchF: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, C>(value: A, forest: "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyReadonlyArray",
                  "canonicalReference": "effect!NonEmptyReadonlyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<C>): "
                },
                {
                  "kind": "Reference",
                  "text": "BranchF",
                  "canonicalReference": "effect-tree!TreeF.BranchF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>;\n    <C>(forest: "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyReadonlyArray",
                  "canonicalReference": "effect!NonEmptyReadonlyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<C>): <A>(value: A) => "
                },
                {
                  "kind": "Reference",
                  "text": "BranchF",
                  "canonicalReference": "effect-tree!TreeF.BranchF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>;\n    tupled: <A, C>([node, forest]: [A, "
                },
                {
                  "kind": "Reference",
                  "text": "Array.NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<C>]) => "
                },
                {
                  "kind": "Reference",
                  "text": "BranchF",
                  "canonicalReference": "effect-tree!TreeF.BranchF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>;\n}"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "branchF",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.Covariant:var",
              "docComment": "/**\n * Covariant instance for {@link TreeF}.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Covariant: "
                },
                {
                  "kind": "Reference",
                  "text": "CO.Covariant",
                  "canonicalReference": "@effect/typeclass!Covariant:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TreeFTypeLambda",
                  "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/treeF/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "Covariant",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.destruct:function(1)",
              "docComment": "/**\n * Deconstruct a tree into its value and its possible empty forest.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.w$lk\n *\n * @typeParam C - The child node type, also called the _carrier type_.\n *\n * @returns A pair of the tree root node value and a possibly empty list of children of the type `C`.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "destruct: <A, B>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, B>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "readonly [A, B[]]"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "B",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "destruct"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.flatMap:var",
              "docComment": "/**\n * @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "flatMap: "
                },
                {
                  "kind": "Reference",
                  "text": "FL.FlatMap",
                  "canonicalReference": "@effect/typeclass!FlatMap:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TreeFTypeLambda",
                  "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">['flatMap']"
                }
              ],
              "fileUrlPath": "src/treeF/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "flatMap",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.FlatMap:var",
              "docComment": "/**\n * FlatMap instance for {@link TreeF}.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "FlatMap: "
                },
                {
                  "kind": "Reference",
                  "text": "FL.FlatMap",
                  "canonicalReference": "@effect/typeclass!FlatMap:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TreeFTypeLambda",
                  "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/treeF/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "FlatMap",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.getBranchForest:function(1)",
              "docComment": "/**\n * Get the non-empty forest of a branch.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.\n *\n * @returns Branch forest.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getBranchForest: <A, C>({ forest, }: "
                },
                {
                  "kind": "Reference",
                  "text": "BranchF",
                  "canonicalReference": "effect-tree!TreeF.BranchF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Array.NonEmptyReadonlyArray",
                  "canonicalReference": "effect!NonEmptyReadonlyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<C>"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ forest, }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getBranchForest"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.getEquivalence:function(1)",
              "docComment": "/**\n * Build an equivalence for {@link TreeF} from an equivalence of the tree type and an equivalence of the carrier type.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getEquivalence: <A>(equalsA: "
                },
                {
                  "kind": "Reference",
                  "text": "Equivalence.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "<C>(equalsC: "
                },
                {
                  "kind": "Reference",
                  "text": "Equivalence.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<C>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Equivalence.Equivalence",
                  "canonicalReference": "effect!Equivalence:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>>"
                }
              ],
              "fileUrlPath": "src/treeF/instances.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 11
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "equalsA",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getEquivalence"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.getForest:function(1)",
              "docComment": "/**\n * Get the value of the root tree forest.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.\n *\n * @returns Root node forest.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getForest: <A, C>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "readonly C[]"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getForest"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.getValue:function(1)",
              "docComment": "/**\n * Get the value of the root tree node.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.\n *\n * @returns Root node value.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getValue: <A, C>({ node }: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "A"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ node }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getValue"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.imap:var",
              "docComment": "/**\n * @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "imap: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, B>(to: (a: A) => B, from: (b: B) => A): <R, O, E>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<E, A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<E, B>;\n    <R, O, E, A, B>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<E, A>, to: (a: A) => B, from: (b: B) => A): "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<E, B>;\n}"
                }
              ],
              "fileUrlPath": "src/treeF/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "imap",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.isBranch:function(1)",
              "docComment": "/**\n * True if the tree has child nodes.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isBranch: <A, C>(treeF: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "treeF",
                  "canonicalReference": "effect-tree!~treeF"
                },
                {
                  "kind": "Content",
                  "text": " is "
                },
                {
                  "kind": "Reference",
                  "text": "BranchF",
                  "canonicalReference": "effect-tree!TreeF.BranchF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "treeF",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "isBranch"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.isLeaf:function(1)",
              "docComment": "/**\n * True if the tree has no children.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isLeaf: <A, C>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "self",
                  "canonicalReference": "effect-tree!~self"
                },
                {
                  "kind": "Content",
                  "text": " is "
                },
                {
                  "kind": "Reference",
                  "text": "LeafF",
                  "canonicalReference": "effect-tree!TreeF.LeafF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "isLeaf"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.leafF:function(1)",
              "docComment": "/**\n * Create a leaf from its value.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "leafF: <A>(value: "
                },
                {
                  "kind": "Content",
                  "text": "A"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "value",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "leafF"
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!TreeF.LeafF:interface",
              "docComment": "/**\n * A tree with no nodes.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.  @category fold\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface LeafF<A> "
                }
              ],
              "fileUrlPath": "src/treeF/types.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "LeafF",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!TreeF.LeafF#node:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "node: "
                    },
                    {
                      "kind": "Content",
                      "text": "A"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "node",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.length:function(1)",
              "docComment": "/**\n * Compute child count for given tree node.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.\n *\n * @returns Numeric length of node forest.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "length: <A, C>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "number"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "length"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.map:var",
              "docComment": "/**\n * @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "map: "
                },
                {
                  "kind": "Reference",
                  "text": "CO.Covariant",
                  "canonicalReference": "@effect/typeclass!Covariant:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TreeFTypeLambda",
                  "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">['map']"
                }
              ],
              "fileUrlPath": "src/treeF/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "map",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.mapValue:var",
              "docComment": "/**\n * Map over the tree node value.\n *\n * @param self - the tree node to map over.\n *\n * @param f - will be used as the mapping function.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam B - New child node type and also result type of the given function.\n *\n * @typeParam C - The child node type, also called the _carrier type_.\n *\n * @returns A tree with the mapped value.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "mapValue: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, B, C>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>, f: (a: A) => B): "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<B, C>;\n    <A, B>(f: (a: A) => B): <C>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>) => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<B, C>;\n}"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "mapValue",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!TreeF.match:function(1)",
              "docComment": "/**\n * Match a `TreeF` to leaves and branches.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.\n *\n * @typeParam R - The result type of the given functions.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "match: <A, C, R>({ onLeaf, onBranch }: "
                },
                {
                  "kind": "Reference",
                  "text": "MatcherF",
                  "canonicalReference": "effect-tree!TreeF.MatcherF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A, C, R>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(treeF: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>) => R"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ onLeaf, onBranch }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "match"
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!TreeF.MatcherF:interface",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface MatcherF<A, C, R> "
                }
              ],
              "fileUrlPath": "src/treeF/types.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "MatcherF",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!TreeF.MatcherF#onBranch:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "onBranch: "
                    },
                    {
                      "kind": "Content",
                      "text": "(node: A, forest: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Array.NonEmptyReadonlyArray",
                      "canonicalReference": "effect!NonEmptyReadonlyArray:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<C>) => R"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "onBranch",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 4
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!TreeF.MatcherF#onLeaf:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "onLeaf: "
                    },
                    {
                      "kind": "Content",
                      "text": "(node: A) => R"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "onLeaf",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.setForest:var",
              "docComment": "/**\n * Set the forest of a tree node.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam B - New child node type.\n *\n * @typeParam C - The child node type, also called the _carrier type_.\n *\n * @returns A tree with the new forest.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "setForest: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, B, C>(forest: "
                },
                {
                  "kind": "Reference",
                  "text": "Array.NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<B>, self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>): "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, B>;\n    <A, C>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>): <B>(forest: "
                },
                {
                  "kind": "Reference",
                  "text": "Array.NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<B>) => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, B>;\n}"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "setForest",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.setValue:var",
              "docComment": "/**\n * Set the value of a tree node.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam B - New underlying type for the tree.\n *\n * @typeParam C - The child node type, also called the _carrier type_.\n *\n * @returns A tree with the new value.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "setValue: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, B, C>(value: B, self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>): "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<B, C>;\n    <A, C>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>): <B>(value: B) => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<B, C>;\n}"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "setValue",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.Traversable:var",
              "docComment": "/**\n * Traversable instance for {@link TreeF}.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "Traversable: "
                },
                {
                  "kind": "Reference",
                  "text": "TA.Traversable",
                  "canonicalReference": "@effect/typeclass!Traversable:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TreeFTypeLambda",
                  "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/treeF/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "Traversable",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.traverse:var",
              "docComment": "/**\n * @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "traverse: "
                },
                {
                  "kind": "Reference",
                  "text": "TA.Traversable",
                  "canonicalReference": "@effect/typeclass!Traversable:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "TreeFTypeLambda",
                  "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">['traverse']"
                }
              ],
              "fileUrlPath": "src/treeF/instances.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "traverse",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!TreeF.TreeF:type",
              "docComment": "/**\n * The non-recursive tree type where the child type is left as open. Used by the recursion schemes. A tree is either a leaf or a branch.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.  @category fold\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type TreeF<A, C = "
                },
                {
                  "kind": "Content",
                  "text": "unknown"
                },
                {
                  "kind": "Content",
                  "text": "> = "
                },
                {
                  "kind": "Reference",
                  "text": "LeafF",
                  "canonicalReference": "effect-tree!TreeF.LeafF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A> | "
                },
                {
                  "kind": "Reference",
                  "text": "BranchF",
                  "canonicalReference": "effect-tree!TreeF.BranchF:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/treeF/types.ts",
              "releaseTag": "Public",
              "name": "TreeF",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "C",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 3,
                "endIndex": 7
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.treeF:var",
              "docComment": "/**\n * Create a new `TreeF` from a node value and a possibly empty list of child nodes.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "treeF: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, C>(value: A, forest: readonly C[]): "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>;\n    <C>(forest: readonly C[]): <A>(value: A) => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>;\n    flip: {\n        <A, C>(forest: readonly C[], value: A): "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>;\n        <A>(value: A): <C>(forest: readonly C[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>;\n    };\n}"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "treeF",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface",
              "docComment": "/**\n * Type lambda for the `TreeF<A, C>` type. `Kind<TreeFTypeLambda, never, unknown, A, C> = TreeF<A, C>`  @category fold\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface TreeFTypeLambda extends "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.TypeLambda",
                  "canonicalReference": "effect!TypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/treeF/types.ts",
              "releaseTag": "Public",
              "name": "TreeFTypeLambda",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda#type:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "readonly type: "
                    },
                    {
                      "kind": "Reference",
                      "text": "TreeF",
                      "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<this['Out1'], this['Target']>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": true,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "type",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 2
                }
              ]
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!TreeF.withForest:var",
              "docComment": "/**\n * A flipped version of {@link treeF}.\n *\n * @typeParam A - The underlying type of the tree. For example, in a numeric tree it would be `number`.\n *\n * @typeParam C - The child node type, also called the _carrier type_.  @category fold  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "withForest: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A, C>(forest: C[], value: A): "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>;\n    <A>(value: A): <C>(forest: C[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, C>;\n}"
                }
              ],
              "fileUrlPath": "src/treeF/index.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "withForest",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            }
          ]
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeFold:type",
          "docComment": "/**\n * The result type of all folds.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeFold<A, B> = "
            },
            {
              "kind": "Content",
              "text": "(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => B"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "name": "TreeFold",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeFolder:type",
          "docComment": "/**\n * Type of a function that folds a single level of the tree. Same type as: `(self: TreeF.TreeF<A, B>) => B`.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeFolder<A, B> = "
            },
            {
              "kind": "Reference",
              "text": "Algebra",
              "canonicalReference": "effect-ts-folds!Algebra:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", B, A>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "name": "TreeFolder",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!TreeFolderK:interface",
          "docComment": "/**\n * A tree folder for a type of kind `* → *`, where the type parameter is inferred. The type lambda `F` will be used to build the actual folder type.\n *\n * For example consider the function `MyFolder` which happens to be a tree folder with a carrier type of `Option<A>`:\n * ```ts\n * type MyFolder = <A>(treeF: TreeF<Option<A>>) => Option<A>\n * ```\n *\n * Its type can be written using `TreeAlgebraK` without mentioning the free parameter `A`:\n * ```ts\n * type MyFolder = TreeFolderK<OptionTypeLambda>\n * ```\n *\n * @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface TreeFolderK<F extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": "> "
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "F",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "TreeFolderK",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "CallSignature",
              "canonicalReference": "effect-tree!TreeFolderK:call(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "<A, E = "
                },
                {
                  "kind": "Content",
                  "text": "undefined"
                },
                {
                  "kind": "Content",
                  "text": ", R = "
                },
                {
                  "kind": "Content",
                  "text": "undefined"
                },
                {
                  "kind": "Content",
                  "text": ", I = "
                },
                {
                  "kind": "Content",
                  "text": "never"
                },
                {
                  "kind": "Content",
                  "text": ">(t: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF.TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.Kind",
                  "canonicalReference": "effect!Kind:type"
                },
                {
                  "kind": "Content",
                  "text": "<F, E, R, I, A>>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.Kind",
                  "canonicalReference": "effect!Kind:type"
                },
                {
                  "kind": "Content",
                  "text": "<F, E, R, I, A>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "returnTypeTokenRange": {
                "startIndex": 12,
                "endIndex": 14
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "t",
                  "parameterTypeTokenRange": {
                    "startIndex": 7,
                    "endIndex": 11
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  }
                },
                {
                  "typeParameterName": "I",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 6
                  }
                }
              ]
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!TreeFolderOf:interface",
          "docComment": "/**\n * Also: `Folder<TreeF.TreeFTypeLambda, IdentityTypeLambda, B>`. Same as {@link TreeFolder} except the type parameter `B` is given.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface TreeFolderOf<B> "
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "TreeFolderOf",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "CallSignature",
              "canonicalReference": "effect-tree!TreeFolderOf:call(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "<A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF.TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, B>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Content",
                  "text": "B"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "self",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ]
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeFoldOf:type",
          "docComment": "/**\n * Same as {@link TreeFold} except the `A` type parameter is open.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeFoldOf<B> = "
            },
            {
              "kind": "Content",
              "text": "<A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => B"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "name": "TreeFoldOf",
          "typeParameters": [
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!treeHylo:function(1)",
          "docComment": "/**\n * Fuse a fold and unfold into a single scheme to avoid traversing the tree more than once.  @category refold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "treeHylo: <A, B, E = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": ", I = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ">(ψ: "
            },
            {
              "kind": "Content",
              "text": "import(\"effect-ts-folds\")."
            },
            {
              "kind": "Reference",
              "text": "Coalgebra",
              "canonicalReference": "effect-ts-folds!Coalgebra:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", A, E, R, I>"
            },
            {
              "kind": "Content",
              "text": ", φ: "
            },
            {
              "kind": "Content",
              "text": "import(\"effect-ts-folds\")."
            },
            {
              "kind": "Reference",
              "text": "Algebra",
              "canonicalReference": "effect-ts-folds!Algebra:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", B, E, R, I>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(a: A) => B"
            }
          ],
          "fileUrlPath": "src/schemes/refold.ts",
          "returnTypeTokenRange": {
            "startIndex": 19,
            "endIndex": 20
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "ψ",
              "parameterTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 12
              },
              "isOptional": false
            },
            {
              "parameterName": "φ",
              "parameterTypeTokenRange": {
                "startIndex": 13,
                "endIndex": 18
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            },
            {
              "typeParameterName": "I",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              }
            }
          ],
          "name": "treeHylo"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!treeK:function(1)",
          "docComment": "/**\n * Like the {@link tree} constructor, creates a new tree from its node and forest, except both are inside some data type whose applicative is given in the first argument.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "treeK: <F extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">(F: "
            },
            {
              "kind": "Reference",
              "text": "Applicative.Applicative",
              "canonicalReference": "@effect/typeclass!Applicative:interface"
            },
            {
              "kind": "Content",
              "text": "<F>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "{\n    <A, E = unknown, O = unknown, R = never>(value: "
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, R, O, E, A>, forest: "
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, R, O, E, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>[]): "
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, R, O, E, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n    <A, E_1 = unknown, O_1 = unknown, R_1 = never>(forest: "
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, R_1, O_1, E_1, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>[]): (value: "
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, R_1, O_1, E_1, A>) => "
            },
            {
              "kind": "Reference",
              "text": "HKT.Kind",
              "canonicalReference": "effect!Kind:type"
            },
            {
              "kind": "Content",
              "text": "<F, R_1, O_1, E_1, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n}"
            }
          ],
          "fileUrlPath": "src/instances/Traversable.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 27
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "F",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "F",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "treeK"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!treePara:function(1)",
          "docComment": "/**\n * Run a {@link TreeProductFolder}<A, B> on a {@link Tree}<A> to fold into a value of type `B`. Just like {@link treeCata} except the folder function gets all previous computed values.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "treePara: <A, B>(φ: "
            },
            {
              "kind": "Reference",
              "text": "TreeProductFolder",
              "canonicalReference": "effect-tree!TreeProductFolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeFold",
              "canonicalReference": "effect-tree!TreeFold:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            }
          ],
          "fileUrlPath": "src/schemes/fold/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "φ",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "treePara"
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeProductFolder:type",
          "docComment": "/**\n * The type of the function `(self: TreeF.TreeF<B, [Tree<T>, A]>) => A`.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeProductFolder<A, B> = "
            },
            {
              "kind": "Reference",
              "text": "RAlgebra",
              "canonicalReference": "effect-ts-folds!RAlgebra:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", B, A>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "name": "TreeProductFolder",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!TreeProductFolderK:interface",
          "docComment": "/**\n * Same {@link TreeFolderK} but for `RAlgebra`s.  @category fold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface TreeProductFolderK<F extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": "> "
            }
          ],
          "fileUrlPath": "src/schemes/fold/types.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "F",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "TreeProductFolderK",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "CallSignature",
              "canonicalReference": "effect-tree!TreeProductFolderK:call(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "<A, E = "
                },
                {
                  "kind": "Content",
                  "text": "unknown"
                },
                {
                  "kind": "Content",
                  "text": ", R = "
                },
                {
                  "kind": "Content",
                  "text": "unknown"
                },
                {
                  "kind": "Content",
                  "text": ", I = "
                },
                {
                  "kind": "Content",
                  "text": "never"
                },
                {
                  "kind": "Content",
                  "text": ">(t: "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF.TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, ["
                },
                {
                  "kind": "Reference",
                  "text": "Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>, "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.Kind",
                  "canonicalReference": "effect!Kind:type"
                },
                {
                  "kind": "Content",
                  "text": "<F, I, R, E, A>]>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.Kind",
                  "canonicalReference": "effect!Kind:type"
                },
                {
                  "kind": "Content",
                  "text": "<F, I, R, E, A>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "returnTypeTokenRange": {
                "startIndex": 14,
                "endIndex": 16
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "t",
                  "parameterTypeTokenRange": {
                    "startIndex": 7,
                    "endIndex": 13
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  }
                },
                {
                  "typeParameterName": "I",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 6
                  }
                }
              ]
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!TreeTypeLambda:interface",
          "docComment": "/**\n * Type lambda for the `Tree<A>` type.\n * ```txt\n * Kind<TreeTypeLambda, unknown, unknown, unknown, A> ≡ TreeF<A, Tree<A>>\n * ```\n *\n * @category basic\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface TreeTypeLambda extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": " "
            }
          ],
          "fileUrlPath": "src/tree/types.ts",
          "releaseTag": "Public",
          "name": "TreeTypeLambda",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "effect-tree!TreeTypeLambda#type:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "readonly type: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<this['Target']>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": true,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "type",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "extendsTokenRanges": [
            {
              "startIndex": 1,
              "endIndex": 2
            }
          ]
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeUnfold:type",
          "docComment": "/**\n * The result type of all unfolding schemes.  @category unfold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeUnfold<A, B> = "
            },
            {
              "kind": "Content",
              "text": "(b: B) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/types.ts",
          "releaseTag": "Public",
          "name": "TreeUnfold",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeUnfolder:type",
          "docComment": "/**\n * Type of a function that unfolds a single value of type `B` into a non-recursive tree with a node of type `A` and a forest of type `B`.\n *\n * Same type as [Coalgebra](https://github.com/middle-ages/effect-ts-folds/blob/main/src/unfold/unfolds.ts#L26).  @category unfold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeUnfolder<A, B> = "
            },
            {
              "kind": "Content",
              "text": "(b: B) => "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/types.ts",
          "releaseTag": "Public",
          "name": "TreeUnfolder",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!TreeUnfolderK:interface",
          "docComment": "/**\n * The opposite of {@link TreeFolderK}.  @category unfold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface TreeUnfolderK<F extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": "> "
            }
          ],
          "fileUrlPath": "src/schemes/unfold/types.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "F",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "TreeUnfolderK",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "CallSignature",
              "canonicalReference": "effect-tree!TreeUnfolderK:call(1)",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "<A, E = "
                },
                {
                  "kind": "Content",
                  "text": "undefined"
                },
                {
                  "kind": "Content",
                  "text": ", R = "
                },
                {
                  "kind": "Content",
                  "text": "undefined"
                },
                {
                  "kind": "Content",
                  "text": ", I = "
                },
                {
                  "kind": "Content",
                  "text": "never"
                },
                {
                  "kind": "Content",
                  "text": ">(fa: "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.Kind",
                  "canonicalReference": "effect!Kind:type"
                },
                {
                  "kind": "Content",
                  "text": "<F, I, R, E, A>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "TreeF.TreeF",
                  "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
                },
                {
                  "kind": "Content",
                  "text": "<A, "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.Kind",
                  "canonicalReference": "effect!Kind:type"
                },
                {
                  "kind": "Content",
                  "text": "<F, I, R, E, A>>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "returnTypeTokenRange": {
                "startIndex": 10,
                "endIndex": 14
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "fa",
                  "parameterTypeTokenRange": {
                    "startIndex": 7,
                    "endIndex": 9
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                },
                {
                  "typeParameterName": "E",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  }
                },
                {
                  "typeParameterName": "R",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 4
                  }
                },
                {
                  "typeParameterName": "I",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 5,
                    "endIndex": 6
                  }
                }
              ]
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "effect-tree!TreeUnfolderOf:type",
          "docComment": "/**\n * Same as {@link TreeUnfolder} except the `B` type parameter is left open.  @category unfold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TreeUnfolderOf<A> = "
            },
            {
              "kind": "Content",
              "text": "<B>(b: B) => "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/types.ts",
          "releaseTag": "Public",
          "name": "TreeUnfolderOf",
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!unfixBranch:function(1)",
          "docComment": "/**\n * Like {@link unfixTree} but exclusively for branches.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "unfixBranch: <A>(branchF: "
            },
            {
              "kind": "Reference",
              "text": "Branch",
              "canonicalReference": "effect-tree!Branch:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "BranchF",
              "canonicalReference": "effect-tree!TreeF.BranchF:interface"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "branchF",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "unfixBranch"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!unfixTree:function(1)",
          "docComment": "/**\n * Convert the recursive version of the tree to a non-recursive {@link TreeF} version with children of type `Tree<A>`.  @category basic  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "unfixTree: <A>(fixed: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>"
            }
          ],
          "fileUrlPath": "src/tree/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "fixed",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "unfixTree"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!unfold:function(1)",
          "docComment": "/**\n * The simplest unfold: unfold a tree as long as the given function of type `(parent: A) ⇒ A[]` keeps producing new child nodes.  @category unfold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "unfold: <A>(unfolder: "
            },
            {
              "kind": "Content",
              "text": "(parent: A) => A[]"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeUnfold",
              "canonicalReference": "effect-tree!TreeUnfold:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>"
            }
          ],
          "fileUrlPath": "src/schemes/unfold/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "unfolder",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "unfold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!unfoldLevelTree:function(1)",
          "docComment": "/**\n * Unfold a perfectly balanced tree from the given settings.\n *\n * In a _level tree_, the value of every node is its depth. This, for example, is a _level tree_:\n * ```txt\n * ┬1\n * ├─2\n * ├─2\n * ├┬2\n * │├─3\n * │└─3\n * └─2\n * ```\n *\n * @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "unfoldLevelTree: (settings: "
            },
            {
              "kind": "Reference",
              "text": "LevelTreeSettings",
              "canonicalReference": "effect-tree!LevelTreeSettings:interface"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "TreeUnfold",
              "canonicalReference": "effect-tree!TreeUnfold:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>"
            }
          ],
          "fileUrlPath": "src/ops/levels.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "settings",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "unfoldLevelTree"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!unfolds:var",
          "docComment": "/**\n * All unfolds in a single place.  @category unfold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "unfolds: "
            },
            {
              "kind": "Content",
              "text": "{\n    annotateDepth: <A>([tree, previousDepth]: [import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, number]) => import(\"./treeF.js\")."
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<readonly [A, number], [import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, number]>;\n    annotateLevelLabels: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeUnfolder",
              "canonicalReference": "effect-tree!TreeUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<string, [string, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<string>]>;\n    byParent: <A>(unfolder: (parent: A) => A[]) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeUnfolder",
              "canonicalReference": "effect-tree!TreeUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, A>;\n    cropDepth: <A>([depth, self]: readonly [number, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>]) => import(\"./treeF.js\")."
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, readonly [number, import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>]>;\n    levelTree: ({ depth, degree, }: import(\"#ops\")."
            },
            {
              "kind": "Reference",
              "text": "LevelTreeSettings",
              "canonicalReference": "effect-tree!LevelTreeSettings:interface"
            },
            {
              "kind": "Content",
              "text": ") => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeUnfolder",
              "canonicalReference": "effect-tree!TreeUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<number, number>;\n    paths: <A>(order: import(\"effect/Order\")."
            },
            {
              "kind": "Reference",
              "text": "Order",
              "canonicalReference": "effect!Order:interface"
            },
            {
              "kind": "Content",
              "text": "<A>) => import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeUnfolder",
              "canonicalReference": "effect-tree!TreeUnfolder:type"
            },
            {
              "kind": "Content",
              "text": "<A, import(\"./util/Array.js\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray2",
              "canonicalReference": "effect-tree!NonEmptyArray2:type"
            },
            {
              "kind": "Content",
              "text": "<A>>;\n    edges: import(\"#tree\")."
            },
            {
              "kind": "Reference",
              "text": "TreeUnfolderK",
              "canonicalReference": "effect-tree!TreeUnfolderK:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Edges.EdgeMapTypeLambda",
              "canonicalReference": "effect-tree!Codec.Edges.EdgeMapTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ">;\n    arrays: <A>(a: "
            },
            {
              "kind": "Reference",
              "text": "Arrays.TreeArray",
              "canonicalReference": "effect-tree!Codec.Arrays.TreeArray:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => import(\"./treeF.js\")."
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<A>;\n    indented: ([[value, depth], second, ...tail]: import(\"effect/Array\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray",
              "canonicalReference": "effect!NonEmptyArray:type"
            },
            {
              "kind": "Content",
              "text": "<[string, number]>) => import(\"./treeF.js\")."
            },
            {
              "kind": "Reference",
              "text": "TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<string, import(\"effect/Array\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray",
              "canonicalReference": "effect!NonEmptyArray:type"
            },
            {
              "kind": "Content",
              "text": "<[string, number]>>;\n}"
            }
          ],
          "fileUrlPath": "src/unfolds.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "unfolds",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 44
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!unzip:function(1)",
          "docComment": "/**\n * Unzip a tree of `[A, B]` into a pair of congruent trees of types `A` and `B`.\n * ```ts\n * const zippedTree: Tree<[string, number]> = tree(\n *   ['a', 1],\n *   [leaf(['b', 2])],\n * )\n *\n * const [left, right] = unzip(zippedTree)\n * //  left = branch('a', [leaf('b')])\n * // right = branch( 1 , [leaf( 2 )])\n * ```\n *\n * @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "unzip: <A, B>(t: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<[A, B]>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "["
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>]"
            }
          ],
          "fileUrlPath": "src/ops/zip.ts",
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "t",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "unzip"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!unzipFold:function(1)",
          "docComment": "/**\n * Unzip a single level in a tree of `[A, B]` into a pair of trees of types `A` and `B`.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "unzipFold: <A, B>(t: "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<[A, B], ["
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>]>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "["
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>]"
            }
          ],
          "fileUrlPath": "src/ops/zip.ts",
          "returnTypeTokenRange": {
            "startIndex": 8,
            "endIndex": 13
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "t",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 7
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "unzipFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!unzipThese:function(1)",
          "docComment": "/**\n * Unzip a tree of {@link These} into a pair of optional trees.\n *\n * See also {@link zipThese} for the opposite operation.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "unzipThese: <A, B>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "["
            },
            {
              "kind": "Reference",
              "text": "Option.Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>>, "
            },
            {
              "kind": "Reference",
              "text": "Option.Option",
              "canonicalReference": "effect!Option:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>>]"
            }
          ],
          "fileUrlPath": "src/ops/zipThese.ts",
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 15
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "unzipThese"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!unzipTheseFold:function(1)",
          "docComment": "/**\n * Unzip a single level in a tree of `These<A, B>` into a pair of potentially non-congruent optional trees of type `A` and `B`.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "unzipTheseFold: <A, B>(self: "
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeF",
              "canonicalReference": "effect-tree!TreeF.TreeF_2:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>, "
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>>>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>>"
            }
          ],
          "fileUrlPath": "src/ops/zipThese.ts",
          "returnTypeTokenRange": {
            "startIndex": 12,
            "endIndex": 18
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 11
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "unzipTheseFold"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!updateRunningAverage:function(1)",
          "docComment": "/**\n * Update the running average with a new value.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "updateRunningAverage: (newValue: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Function.EndoOf",
              "canonicalReference": "effect-tree!EndoOf:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "RunningAverage",
              "canonicalReference": "effect-tree!RunningAverage:interface"
            },
            {
              "kind": "Content",
              "text": ">"
            }
          ],
          "fileUrlPath": "src/ops/numeric.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "newValue",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "updateRunningAverage"
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!withOrdinal:var",
          "docComment": "/**\n * Annotate tree nodes with their post-order depth-first ordinal.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "withOrdinal: "
            },
            {
              "kind": "Content",
              "text": "{\n    (initialize?: number): <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<[A, number]>;\n    pre(initialize: number): <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<[A, number]>;\n}"
            }
          ],
          "fileUrlPath": "src/ops/ordinal.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "withOrdinal",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 10
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "effect-tree!WithTreeLambda:interface",
          "docComment": "/**\n * Type lambda for `[T, Tree<A>]`  @category refold\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface WithTreeLambda<T> extends "
            },
            {
              "kind": "Reference",
              "text": "HKT.TypeLambda",
              "canonicalReference": "effect!TypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": " "
            }
          ],
          "fileUrlPath": "src/schemes/types.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "WithTreeLambda",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "effect-tree!WithTreeLambda#type:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "readonly type: "
                },
                {
                  "kind": "Content",
                  "text": "[T, "
                },
                {
                  "kind": "Reference",
                  "text": "Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<this['Target']>]"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": true,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "type",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            }
          ],
          "extendsTokenRanges": [
            {
              "startIndex": 1,
              "endIndex": 2
            }
          ]
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!xor:var",
          "docComment": "/**\n * Fold with `xor` over a boolean tree.  @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "xor: "
            },
            {
              "kind": "Reference",
              "text": "Predicate",
              "canonicalReference": "effect!Predicate:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<boolean>>"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "xor",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!xorFold:var",
          "docComment": "/**\n * @category instances  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "xorFold: "
            },
            {
              "kind": "Reference",
              "text": "BooleanFolder",
              "canonicalReference": "effect-tree!BooleanFolder:type"
            }
          ],
          "fileUrlPath": "src/instances/Foldable.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "xorFold",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!zip:var",
          "docComment": "/**\n * Zip a pair of trees of types `A` and `B` into a single tree of `[A, B]`.\n *\n * If their shapes do not match, the result will include only the intersection. Any nodes not on the shape of the intersection of the two trees will be discarded.\n *\n * See {@link zipThese} for a zip that does not crop and is therefore pleasantly associative.\n * ```ts\n * // Zip two trees of identical shape\n * const left: Tree<string> = branch('a', [branch('b', [of('c')])]),\n *         right: Tree<number> = branch( 1 , [branch( 2 , [of( 3 )])])\n *\n * const zippedTree: Tree<[string, number]> = zip(left, right)\n * // zippedTree = branch(\n * //   ['a', 1],\n * //   [branch(['b', 2], [of(['c', 3])])],\n * // )\n *\n * // Zipping trees of different shapes crops to intersection\n * const left: Tree<string> = branch('a', [branch('b', [of('c')])]),\n *         right: Tree<number> = leaf( 1 )\n * const zippedTree: Tree<[string, number]> = pipe(right, zip(left))\n * // zippedTree = leaf(['a', 1])\n * ```\n *\n * @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "zip: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A, B>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, that: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<[A, B]>;\n    <B>(that: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>): <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<[A, B]>;\n}"
            }
          ],
          "fileUrlPath": "src/ops/zip.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "zip",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 14
          }
        },
        {
          "kind": "Namespace",
          "canonicalReference": "effect-tree!Zipper:namespace",
          "docComment": "",
          "excerptTokens": [],
          "fileUrlPath": "index.ts",
          "releaseTag": "None",
          "name": "Zipper",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.append:var",
              "docComment": "/**\n * Append the given node as the last child of the given focus.\n *\n * At the keys `move` and `unsafeMove` you will find versions where the focus has been _moved_ to the newly appended node.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns A function that takes a zipper and returns an updated zipper where the focus node has been replaced.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "append: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(that: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    tryMove<A>(that: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>): (zipper: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    move<A>(that: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/modify.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "append",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 22
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.at:var",
              "docComment": "/**\n * Navigate from a node to its Nth child or throw an exception if the given index is beyond the last tree in the forest of the focused node. Unsafe version of {@link tryAt}.\n *\n * Negative indexes are handled as offsets from the final tree in the forest so that focusing on index `-1` focuses on the last tree in the forest, `-2` on the tree before that and so on.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - Index of child that will be the new zipper focus.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "at: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n    (n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "at",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.depthFirst:var",
              "docComment": "/**\n * Navigate from a node to the next node in a depth-first pre-order traversal, where parents are visited before their children, and both are visited before the next sibling of the parent. For example:\n * ```txt\n * For the tree:\n *                   ┌─┐\n *                   │1│\n *              ╭────┴─┴─────╮\n *            ┌─┴─┐        ┌─┴─┐\n *            │1.1│        │1.2│\n *          ╭─┴───┴╮      ╭┴───┴─╮\n *       ┌──┴──┐┌──┴──┐┌──┴──┐┌──┴──┐\n *       │1.1.1││1.1.2││1.2.1││1.2.2│\n *       └─────┘└─────┘└─────┘└─────┘\n *\n *      depthFirst ┊ result of\n *     called on...┊ navigation\n *     ┈┈┈┈┈┈┈┈┈┈┈┈┼┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈\n *            “1”  ┊ “1.1”\n *          “1.1”  ┊ “1.2”\n *          “1.2”  ┊ “1.1.1”\n *        “1.1.1”  ┊ “1.1.2”\n *        “1.2.1”  ┊ “1.2.2”\n *        “1.2.2”  ┊ Exception thrown\n * ```\n *\n * Returns `Option.none` when the final node in the traversal has been reached.\n *\n * This is the unsafe version of {@link tryDepthFirst}.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "depthFirst: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/zipper/depthFirst.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "depthFirst",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.end:var",
              "docComment": "/**\n * Navigate from a node to its last sibling, sending the zipper to the end of the focus forest. If the node is the only one in the forest or the focus is already at the end, the zipper is returned unchanged.\n *\n * See {@link rewind} for the opposite navigation: jumping to the _beginning_ of the focus forest.\n *\n * This is like {@link last} except it will remain on the same tree level.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "end: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "end",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.fromLevel:function(1)",
              "docComment": "/**\n * Rebuild a level of the tree.  @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export declare function fromLevel<A>(focus: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ", { lefts, rights, parent }: "
                },
                {
                  "kind": "Reference",
                  "text": "ZipperLevel",
                  "canonicalReference": "effect-tree!Zipper.ZipperLevel:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 9
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "focus",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "{ lefts, rights, parent }",
                  "parameterTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 6
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "fromLevel"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.fromTree:function(1)",
              "docComment": "/**\n * Create a new zipper focused on the root node of the given tree.\n *\n * @param focus - The tree at the focus of the new zipper.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns A new zipper focused on the given tree root node.  @category zipper\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "fromTree: <A>(focus: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "focus",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "fromTree"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.getDepth:function(1)",
              "docComment": "/**\n * Get the depth of the zipper, where a zipper focused on the root node gets a depth of `0`.\n *\n * @param zipper - Zipper to be queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns Integer depth of the zipper.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getDepth: <A>({ levels }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "number"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ levels }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getDepth"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.getFocus:function(1)",
              "docComment": "/**\n * Get the current focus of the zipper.\n *\n * @param zipper - Zipper to be queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns The focus of the zipper.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getFocus: <A>({ focus }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ focus }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getFocus"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.getForest:function(1)",
              "docComment": "/**\n * Get the forest of the tree node under focus. Result could be an empty list if the focused node is a {@link Leaf}.\n *\n * @param self - The tree being queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns A possibly empty list of trees.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getForest: <A>({ focus }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "readonly "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>[]"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 7
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ focus }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getForest"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.getLefts:function(1)",
              "docComment": "/**\n * Get the nodes to the left of the focus node.\n *\n * @param zipper - Zipper to be queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns Possibly empty list of trees.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getLefts: <A>({ lefts }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>[]"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ lefts }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getLefts"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.getRights:function(1)",
              "docComment": "/**\n * Get the nodes to the left of the focus node.\n *\n * @param zipper - Zipper to be queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns Possibly empty list of trees.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getRights: <A>({ rights }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>[]"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ rights }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getRights"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.getValue:function(1)",
              "docComment": "/**\n * Get the value of the tree node under focus.\n *\n * @param zipper - Zipper to be queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns Value of the focus node.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "getValue: <A>({ focus }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "A"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ focus }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "getValue"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.hasLefts:function(1)",
              "docComment": "/**\n * True if there are trees to the _left_ of the focus, false if focused node is head in its forest.\n *\n * @param zipper - Zipper to be queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns True if there are trees to the _left_ of the focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "hasLefts: <A>({ lefts }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "boolean"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ lefts }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "hasLefts"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.hasRights:function(1)",
              "docComment": "/**\n * True if there are trees to the _right_ of the focus, false if focused node is last in its forest.\n *\n * @param zipper - Zipper to be queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns True if there are trees to the _right_ of the focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "hasRights: <A>({ rights }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "boolean"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ rights }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "hasRights"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.head:var",
              "docComment": "/**\n * Navigate from a node to its first child or throw an exception if the focused node is a {@link Leaf}. Unsafe version of {@link tryHead}.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "head: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "head",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.headN:var",
              "docComment": "/**\n * Navigate from a node to its first child N times to reach the Nth level of the tree, or throw an exception if there is a leaf on the path from root to its Nth 1st child down.\n *\n * When `n` is zero, the zipper is returned unchanged.\n *\n * Will throw an exception on negative indexes.\n *\n * Unsafe version of {@link tryHeadN}.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - Number of tree levels to descend.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "headN: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n    (n: number): <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "headN",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.isLeaf:function(1)",
              "docComment": "/**\n * True if the zipper is currently focused on a leaf.\n *\n * @param zipper - Zipper to be queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns True if zipper is at leaf else false.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isLeaf: <A>({ focus }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "boolean"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ focus }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "isLeaf"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.isRoot:function(1)",
              "docComment": "/**\n * True if the zipper is currently focused on the tree root node.\n *\n * @param zipper - Zipper to be queried.\n *\n * @typeParam A - Underlying tree type.\n *\n * @returns True if zipper is at root else false.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "isRoot: <A>({ parent }: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "boolean"
                }
              ],
              "fileUrlPath": "src/zipper/data.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "{ parent }",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "isRoot"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.last:var",
              "docComment": "/**\n * Navigate from a node to its last child or throw an exception if the focused node is a {@link Leaf}. Unsafe version of {@link tryLast}.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "last: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "last",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.lastN:var",
              "docComment": "/**\n * Navigate from a node to its last child N times to reach the Nth level of the tree, or throw an exception if there is a leaf on the path from root to its Nth last child down.\n *\n * When `n` is zero, the zipper is returned unchanged.\n *\n * Will throw an exception on negative indexes.\n *\n * Unsafe version of {@link tryLastN}.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - Number of tree levels to descend.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "lastN: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n    (n: number): <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "lastN",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.next:var",
              "docComment": "/**\n * Navigate from a node to its next sibling or throw an exception if the focused node is the last node in its forest. Unsafe version of {@link tryNext}.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "next: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "next",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.nextN:var",
              "docComment": "/**\n * Navigate from a node to its next sibling N times to reach the Nth sibling right of the focus, or throw an exception if there are less than N trees to the _right_ of the focus.\n *\n * When `n` is zero, the zipper is returned unchanged.\n *\n * Will throw an exception on negative indexes.\n *\n * Unsafe version of {@link tryPreviousN}.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - Number of siblings to skip to the right.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "nextN: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n    (n: number): <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "nextN",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface",
              "docComment": "/**\n * Type of function that takes a zipper and returns an option of a zipper. See {@link OptionalZipperOf} for a version that fixes the type parameter.  @category zipper\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface OptionalZipper "
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "releaseTag": "Public",
              "name": "OptionalZipper",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "CallSignature",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:call(1)",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "<A>(zipper: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Zipper",
                      "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": "): "
                    },
                    {
                      "kind": "Reference",
                      "text": "Option.Option",
                      "canonicalReference": "effect!Option:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Zipper",
                      "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "zipper",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ],
                  "typeParameters": [
                    {
                      "typeParameterName": "A",
                      "constraintTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      },
                      "defaultTypeTokenRange": {
                        "startIndex": 0,
                        "endIndex": 0
                      }
                    }
                  ]
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Zipper.OptionalZipperOf:interface",
              "docComment": "/**\n * Just like {@link OptionalZipper} except the type parameter `A` is fixed.  @category zipper\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface OptionalZipperOf<A> "
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "OptionalZipperOf",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "CallSignature",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipperOf:call(1)",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "(zipper: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Zipper",
                      "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": "): "
                    },
                    {
                      "kind": "Reference",
                      "text": "Option.Option",
                      "canonicalReference": "effect!Option:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<"
                    },
                    {
                      "kind": "Reference",
                      "text": "Zipper",
                      "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "returnTypeTokenRange": {
                    "startIndex": 4,
                    "endIndex": 8
                  },
                  "releaseTag": "Public",
                  "overloadIndex": 1,
                  "parameters": [
                    {
                      "parameterName": "zipper",
                      "parameterTypeTokenRange": {
                        "startIndex": 1,
                        "endIndex": 3
                      },
                      "isOptional": false
                    }
                  ]
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.prepend:var",
              "docComment": "/**\n * Insert the given node as the first child of the given focus.\n *\n * At the keys `move` and `tryMove` you will find versions where the focus has been _moved_ to the newly inserted node.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns A function that takes a zipper and returns an updated zipper where the focus node has been replaced.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "prepend: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(that: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    tryMove<A>(that: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>): (zipper: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    move<A>(that: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/modify.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "prepend",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 22
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.previous:var",
              "docComment": "/**\n * Navigate from a node to its previous sibling or throw an exception if the focused node is the forest head. Unsafe version of {@link tryPrevious}.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "previous: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "previous",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.previousN:var",
              "docComment": "/**\n * Navigate from a node to its previous sibling N times to reach the Nth sibling left of the focus, or throw an exception if the focus index is less than N.\n *\n * When `n` is zero, the zipper is returned unchanged.\n *\n * Will throw an exception on negative indexes.\n *\n * Unsafe version of {@link tryPreviousN}.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - Number of siblings to skip to the left.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "previousN: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n    (n: number): <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "previousN",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.pushSelf:function(1)",
              "docComment": "/**\n * Push the zipper itself into its own level stack. Helpful when navigating _down_.  @category internal\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export declare function pushSelf<A>(zipper: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Content",
                  "text": "{\n    levels: "
                },
                {
                  "kind": "Reference",
                  "text": "NonEmptyArray",
                  "canonicalReference": "effect!NonEmptyArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperLevel",
                  "canonicalReference": "effect-tree!Zipper.ZipperLevel:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    parent: "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n}"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 11
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "zipper",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "pushSelf"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.remove:var",
              "docComment": "/**\n * Remove the current focused tree node from the tree, and return the zipper focused on the _next_ sibling. In case none exists focuses _up_ on the parent of the removed node.\n *\n * If the zipper is focused on tree root returns `Option.none()`.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns A zipper without the previously focused node focused on next node, or failing that, on the parent node. If the zipper is focused on the tree root returns `Option.none()`.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "remove: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                }
              ],
              "fileUrlPath": "src/zipper/modify.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "remove",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.repeat:var",
              "docComment": "/**\n * Repeat the given navigation operator N times and return the final result or throw and exception if the operator fails along the way. Unsafe version of {@link tryRepeat}.\n *\n * @param self - The zipper that will be navigated.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "repeat: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number, nav: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>;\n    (n: number, nav: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/repeat.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "repeat",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.repeatUntil:function(1)",
              "docComment": "/**\n * Repeat the given navigation function of type `Zipper<A> ⇒ Option<Zipper<A>>` on the focus node iteratively, updating the focus node with the result until the focus node meets the given predicate or the navigation terminates by returning `Option.none`, for example when reaching the last element of a forest with the {@link tryNext} navigation, or the final depth-first node of the tree with {@link tryDepthFirst} navigation.\n *\n * If the predicate matched, then the zipper is returned pointing at the matching tree node. If it did not, returns `Option.none`.\n *\n * If a cycle in navigation is detected a runtime exception is thrown. Cycles are detected by checking no node is visited twice, so if your navigation does this it will throw a runtime exception even if there are no actual cycles in the navigation. Keep your navigation pointing one way, for example _depth first_, to avoid creating cycles.\n *\n * See {@link repeatUntilValue} for a version that matches on the focused tree node _value_ instead of the focused tree node.\n *\n * @param navigation - A function that takes a zipper and returns either an updated zipper focused on a different tree node, or `Option.none`.\n *\n * @param predicate - Will be matched against every tree node reached by the navigation.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper if the search criteria matched an element along the navigation given, else `Option.none`.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "repeatUntil: <A>(navigation: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                },
                {
                  "kind": "Content",
                  "text": ", predicate: "
                },
                {
                  "kind": "Reference",
                  "text": "Predicate.Predicate",
                  "canonicalReference": "effect!Predicate:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Content",
                  "text": "(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>"
                }
              ],
              "fileUrlPath": "src/zipper/repeat.ts",
              "returnTypeTokenRange": {
                "startIndex": 8,
                "endIndex": 15
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "navigation",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "predicate",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 7
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "repeatUntil"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.repeatUntilValue:function(1)",
              "docComment": "/**\n * Repeat the given navigation function of type `Zipper<A> ⇒ Option<Zipper<A>>` on the focus node iteratively, updating the focus node with the result until the focus node _value_ meets the given predicate or the navigation terminates by returning `Option.none`, for example when reaching the last element of a forest with the {@link tryNext} navigation, or the final depth-first node of the tree with {@link tryDepthFirst} navigation.\n *\n * If the predicate matched, then the zipper is returned pointing at the matching tree node. If it did not, returns `Option.none`.\n *\n * If a cycle in navigation is detected a runtime exception is thrown. Cycles are detected by checking no node is visited twice, so if your navigation does this it will throw a runtime exception even if there are no actual cycles in the navigation. Keep your navigation pointing one way, for example _depth first_, to avoid creating cycles.\n *\n * See {@link repeatUntil} for a version that matches on the focused tree node and not just its value which allows you, for example, to test the node children.\n *\n * @param navigation - A function that takes a zipper and returns either an updated zipper focused on a different tree node, or `Option.none`.\n *\n * @param predicate - Will be matched against every tree node reached by the navigation.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper if the search criteria matched an element along the navigation given, else `Option.none`.\n *\n * @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "repeatUntilValue: <A>(navigation: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                },
                {
                  "kind": "Content",
                  "text": ", predicate: "
                },
                {
                  "kind": "Reference",
                  "text": "Predicate.Predicate",
                  "canonicalReference": "effect!Predicate:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipperOf",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipperOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                }
              ],
              "fileUrlPath": "src/zipper/repeat.ts",
              "returnTypeTokenRange": {
                "startIndex": 6,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "navigation",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 2
                  },
                  "isOptional": false
                },
                {
                  "parameterName": "predicate",
                  "parameterTypeTokenRange": {
                    "startIndex": 3,
                    "endIndex": 5
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "repeatUntilValue"
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.replace:function(1)",
              "docComment": "/**\n * Replace the focus tree node of the zipper with the given tree node.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns A function that takes a zipper and returns an updated zipper where the focus node has been replaced.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "replace: <A>(that: "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "EndoOf",
                  "canonicalReference": "effect-tree!EndoOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>"
                }
              ],
              "fileUrlPath": "src/zipper/modify.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 8
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "that",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "replace"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.rewind:var",
              "docComment": "/**\n * Navigate from a node to its 1st sibling, rewinding the zipper to the head of the focus forest. If the node is the only one in the forest or the focus is already at the head, the zipper is returned unchanged.\n *\n * See {@link end} for the opposite navigation: jumping to the _end_ of the focus forest.\n *\n * This is like {@link head} except it will remain on the same tree level.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "rewind: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "rewind",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.root:var",
              "docComment": "/**\n * Navigate from any node to the root node.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at the root node of the tree.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "root: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "root",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Function",
              "canonicalReference": "effect-tree!Zipper.toTree:function(1)",
              "docComment": "/**\n * Convert a zipper back into a tree.\n *\n * @param zipper - The zipper that will be converted into a tree.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns The tree encoded by the zipper.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toTree: <A>(zipper: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": ") => "
                },
                {
                  "kind": "Reference",
                  "text": "Tree.Tree",
                  "canonicalReference": "effect-tree!Tree:type"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "returnTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "releaseTag": "Public",
              "overloadIndex": 1,
              "parameters": [
                {
                  "parameterName": "zipper",
                  "parameterTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "isOptional": false
                }
              ],
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "toTree"
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryAt:var",
              "docComment": "/**\n * Navigate from a node to its Nth child or return `Option.none` if it has no Nth child.\n *\n * Negative indexes are handled as offsets from the final tree in the forest so that focusing on index `-1` focuses on the last tree in the forest, `-2` on the tree before that and so on.\n *\n * See {@link at} for an unsafe version.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - Index of child that will be the new zipper focus.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if the node is a leaf or the given index is out-of-bounds.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryAt: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    (n: number): <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryAt",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryDepthFirst:var",
              "docComment": "/**\n * Navigate from a node to the next node in a depth-first pre-order traversal: parents are visited before their children, and both are visited before the next sibling of the parent. For example:\n * ```txt\n * For the tree:\n *                   ┌─┐\n *                   │1│\n *              ╭────┴─┴─────╮\n *            ┌─┴─┐        ┌─┴─┐\n *            │1.1│        │1.2│\n *          ╭─┴───┴╮      ╭┴───┴─╮\n *       ┌──┴──┐┌──┴──┐┌──┴──┐┌──┴──┐\n *       │1.1.1││1.1.2││1.2.1││1.2.2│\n *       └─────┘└─────┘└─────┘└─────┘\n *\n *     tryDepthFirst ┊ result of\n *       called on...┊ navigation\n *     ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┼┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈\n *              “1”  ┊ some(“1.1”)\n *            “1.1”  ┊ some(“1.2”)\n *          “1.1.1”  ┊ some(“1.1.2”)\n *          “1.1.2”  ┊ some(“1.2”)\n *            “1.2”  ┊ some(“1.2.1”)\n *          “1.2.1”  ┊ some(“1.2.2”)\n *          “1.2.2”  ┊ none()\n * ```\n *\n * Returns `Option.none` when the final node in the traversal has been reached.\n *\n * See {@link depthFirst} for an unsafe version.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if there is no next node in the depth-first traversal.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryDepthFirst: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                }
              ],
              "fileUrlPath": "src/zipper/depthFirst.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryDepthFirst",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryHead:var",
              "docComment": "/**\n * Navigate from a node to its first child or return `Option.none` if the zipper is focused on a leaf.\n *\n * See {@link head} for an unsafe version.\n *\n * This is like {@link rewind} except it will descend one tree level.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if there is no first child.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryHead: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryHead",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryHeadN:var",
              "docComment": "/**\n * Navigate from a node to its first child N times to reach the Nth level of the tree, or return `Option.none` if there is a leaf on the path from root to its Nth 1st child down.\n *\n * When `n` is zero, the zipper is returned unchanged.\n *\n * Will return `Option.none` if given negative indexes.\n *\n * See {@link headN} for an unsafe version.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - Number of tree levels to descend.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if the path to the Nth level is not valid.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryHeadN: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    (n: number): <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryHeadN",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryLast:var",
              "docComment": "/**\n * Navigate from a node to its last child or return `Option.none` if the zipper is focused on a leaf.\n *\n * See {@link last} for an unsafe version.\n *\n * This is like {@link end} except it will descend one tree level.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if there is no last child.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryLast: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryLast",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryLastN:var",
              "docComment": "/**\n * Navigate from a node to its last child N times to reach the Nth level of the tree, or return `Option.none` if there is a leaf on the path from root to its Nth 1st child down.\n *\n * When `n` is zero, the zipper is returned unchanged.\n *\n * Will return `Option.none` if given negative indexes.\n *\n * See {@link lastN} for an unsafe version.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - Number of tree levels to descend.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if the path to the Nth level is not valid.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryLastN: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    (n: number): <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryLastN",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryNext:var",
              "docComment": "/**\n * Navigate from a node to its next sibling or return `Option.none` if the focused node is the last node in its forest.\n *\n * See {@link next} for an unsafe version.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if there is no next sibling.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryNext: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryNext",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryNextN:var",
              "docComment": "/**\n * Navigate from a node to its next sibling N times to reach the Nth sibling right of the focus, or return `Option.none` if there are less than N trees to the _right_ of the focus.\n *\n * When `n` is zero, the zipper is returned unchanged.\n *\n * Will return `Option.none` if given negative indexes.\n *\n * See {@link nextN} for an unsafe version.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - Number of siblings to skip to the left.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if `next` cannot be repeated N times.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryNextN: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    (n: number): <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryNextN",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryPrevious:var",
              "docComment": "/**\n * Navigate from a node to its previous sibling or return `Option.none` if the focused node is the head node in its forest.\n *\n * See {@link previous} for an unsafe version.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if there is no previous sibling.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryPrevious: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryPrevious",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryPreviousN:var",
              "docComment": "/**\n * Navigate from a node to its previous sibling N times to reach the Nth sibling left of the focus, or return `Option.none` if the focus index is less than N.\n *\n * When `n` is zero, the zipper is returned unchanged.\n *\n * Will return `Option.none` if given negative indexes.\n *\n * See {@link previousN} for an unsafe version.\n *\n * @param n - Number of siblings to skip to the left.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if `previous` cannot be repeated N times.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryPreviousN: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number): "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    (n: number): <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>) => "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n}"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryPreviousN",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryRepeat:var",
              "docComment": "/**\n * Repeat the given navigation operator N times and return the final result or `Option.none` if the operator fails along the way.\n *\n * See {@link repeat} for an unsafe version.\n *\n * @param self - The zipper that will be navigated.\n *\n * @param n - How many times to apply the given navigation. No matter the navigation repeated, if `n=0` the given zipper will be returned unchanged.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if the navigation failed because the path is invalid.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryRepeat: "
                },
                {
                  "kind": "Content",
                  "text": "{\n    <A>(self: "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>, n: number, nav: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "Option.Option",
                  "canonicalReference": "effect!Option:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>>;\n    (n: number, nav: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                },
                {
                  "kind": "Content",
                  "text": "): "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                },
                {
                  "kind": "Content",
                  "text": ";\n}"
                }
              ],
              "fileUrlPath": "src/zipper/repeat.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryRepeat",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 14
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.tryUp:var",
              "docComment": "/**\n * Navigate from a node to its parent or return `Option.none()` if the tree is focused on a root node.\n *\n * See {@link up} for an unsafe version.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus or `Option.none()` if zipper focus is on root node.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "tryUp: "
                },
                {
                  "kind": "Reference",
                  "text": "OptionalZipper",
                  "canonicalReference": "effect-tree!Zipper.OptionalZipper:interface"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "tryUp",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "Variable",
              "canonicalReference": "effect-tree!Zipper.up:var",
              "docComment": "/**\n * Navigate from a node to its parent or throw an exception if the focused node is a tree root. Unsafe version of {@link tryUp}.\n *\n * @typeParam A - The underlying type of the tree.\n *\n * @returns An updated zipper pointing at a new focus.  @category zipper  @function\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "up: "
                },
                {
                  "kind": "Reference",
                  "text": "EndoK",
                  "canonicalReference": "effect-tree!EndoK:interface"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ZipperTypeLambda",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": ">"
                }
              ],
              "fileUrlPath": "src/zipper/navigate.ts",
              "isReadonly": true,
              "releaseTag": "Public",
              "name": "up",
              "variableTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Zipper.Zipper:interface",
              "docComment": "/**\n * A zipper encodes a location with a tree, allowing for efficient navigation\n *\n * @typeParam A - The underlying type of the tree. and update of immutable trees.  @category zipper\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface Zipper<A> extends "
                },
                {
                  "kind": "Reference",
                  "text": "ZipperLevel",
                  "canonicalReference": "effect-tree!Zipper.ZipperLevel:interface"
                },
                {
                  "kind": "Content",
                  "text": "<A>"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "Zipper",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Zipper.Zipper#focus:member",
                  "docComment": "/**\n * Tree node that is the current focus.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "focus: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree.Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "focus",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Zipper.Zipper#levels:member",
                  "docComment": "/**\n * Everything required to rebuild all levels of the tree _above_ this one. At the root level of a tree this array will be empty, when focused on any of the children of the root node it will hold a single level, and so on. The number of levels found is the depth of the zipper.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "levels: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ZipperLevel",
                      "canonicalReference": "effect-tree!Zipper.ZipperLevel:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>[]"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "levels",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 3
                }
              ]
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Zipper.ZipperLevel:interface",
              "docComment": "/**\n * Everything required to rebuild a level of the tree and all below it. To recreate the level we add the focus node between the `lefts` and the `rights` then add this forest to the parent value to get a tree.\n *\n * @typeParam A - The underlying type of the tree.  @category zipper\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface ZipperLevel<A> "
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "releaseTag": "Public",
              "typeParameters": [
                {
                  "typeParameterName": "A",
                  "constraintTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "name": "ZipperLevel",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Zipper.ZipperLevel#lefts:member",
                  "docComment": "/**\n * All children of the parent that are _to the left_ of the focus node.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "lefts: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree.Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>[]"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "lefts",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Zipper.ZipperLevel#parent:member",
                  "docComment": "/**\n * Parent node _value_ of the focus node at the level we are encoding. All nodes have a parent except the root node.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "parent: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Option.Option",
                      "canonicalReference": "effect!Option:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "parent",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                },
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Zipper.ZipperLevel#rights:member",
                  "docComment": "/**\n * All children of the parent that are _to the right_ of the focus node.\n */\n",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "rights: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Tree.Tree",
                      "canonicalReference": "effect-tree!Tree:type"
                    },
                    {
                      "kind": "Content",
                      "text": "<A>[]"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": false,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "rights",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": []
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Zipper.ZipperLevelTypeLambda:interface",
              "docComment": "/**\n * Type lambda for the `ZipperLevel<A>` type. `Kind<ZipperLevelTypeLambda, never, unknown, unknown, A> ≡ ZipperLevel<A>`  @category zipper\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface ZipperLevelTypeLambda extends "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.TypeLambda",
                  "canonicalReference": "effect!TypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "releaseTag": "Public",
              "name": "ZipperLevelTypeLambda",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Zipper.ZipperLevelTypeLambda#type:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "readonly type: "
                    },
                    {
                      "kind": "Reference",
                      "text": "ZipperLevel",
                      "canonicalReference": "effect-tree!Zipper.ZipperLevel:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<this['Target']>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": true,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "type",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 2
                }
              ]
            },
            {
              "kind": "TypeAlias",
              "canonicalReference": "effect-tree!Zipper.ZipperType:type",
              "docComment": "/**\n * Extract the underlying type `A` of the zipper.  @category zipper\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export type ZipperType<Z extends "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<any>"
                },
                {
                  "kind": "Content",
                  "text": "> = "
                },
                {
                  "kind": "Content",
                  "text": "Z extends "
                },
                {
                  "kind": "Reference",
                  "text": "Zipper",
                  "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                },
                {
                  "kind": "Content",
                  "text": "<infer A> ? A : never"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "releaseTag": "Public",
              "name": "ZipperType",
              "typeParameters": [
                {
                  "typeParameterName": "Z",
                  "constraintTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  },
                  "defaultTypeTokenRange": {
                    "startIndex": 0,
                    "endIndex": 0
                  }
                }
              ],
              "typeTokenRange": {
                "startIndex": 4,
                "endIndex": 7
              }
            },
            {
              "kind": "Interface",
              "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda:interface",
              "docComment": "/**\n * Type lambda for the `Zipper<A>` type. `Kind<ZipperTypeLambda, never, unknown, unknown, A> ≡ Zipper<A>`  @category zipper\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "export interface ZipperTypeLambda extends "
                },
                {
                  "kind": "Reference",
                  "text": "HKT.TypeLambda",
                  "canonicalReference": "effect!TypeLambda:interface"
                },
                {
                  "kind": "Content",
                  "text": " "
                }
              ],
              "fileUrlPath": "src/zipper/index.ts",
              "releaseTag": "Public",
              "name": "ZipperTypeLambda",
              "preserveMemberOrder": false,
              "members": [
                {
                  "kind": "PropertySignature",
                  "canonicalReference": "effect-tree!Zipper.ZipperTypeLambda#type:member",
                  "docComment": "",
                  "excerptTokens": [
                    {
                      "kind": "Content",
                      "text": "readonly type: "
                    },
                    {
                      "kind": "Reference",
                      "text": "Zipper",
                      "canonicalReference": "effect-tree!Zipper.Zipper_2:interface"
                    },
                    {
                      "kind": "Content",
                      "text": "<this['Target']>"
                    },
                    {
                      "kind": "Content",
                      "text": ";"
                    }
                  ],
                  "isReadonly": true,
                  "isOptional": false,
                  "releaseTag": "Public",
                  "name": "type",
                  "propertyTypeTokenRange": {
                    "startIndex": 1,
                    "endIndex": 3
                  }
                }
              ],
              "extendsTokenRanges": [
                {
                  "startIndex": 1,
                  "endIndex": 2
                }
              ]
            }
          ]
        },
        {
          "kind": "Variable",
          "canonicalReference": "effect-tree!zipThese:var",
          "docComment": "/**\n * Like {@link zip}, except does not crop to the shortest/shallowest branch of the zipped pair. Instead it _stretches_ the tree to the longest/deepest branch of the zipper pair, and is thus associative.\n *\n * To account for subtrees where only one of the sides is available, the tree is returned not as a `Tree<[A, B]>`, but instead as a `Tree<These<A, B>>`. See {@link These | the These API} for more information.\n *\n * See also:\n *\n * 1. {@link unzipThese} for the opposite operation. 2. {@link zipTheseWith} to run a function on the partial pair.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "zipThese: "
            },
            {
              "kind": "Content",
              "text": "{\n    <A, B>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, that: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>): "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>>;\n    <B>(that: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>): <A>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>>;\n}"
            }
          ],
          "fileUrlPath": "src/ops/zipThese.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "zipThese",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 18
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!zipTheseWith:function(1)",
          "docComment": "/**\n * Just like {@link zipThese} except the given function will be given the {@link These} value for the pair. If both are present, the function will receive a {@link Both}. Otherwise it will receive either a {@link Left} or a {@link Right}.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "zipTheseWith: <A, B, C>(f: "
            },
            {
              "kind": "Content",
              "text": "(these: "
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>) => C"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "((self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, that: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>) => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<C>)"
            }
          ],
          "fileUrlPath": "src/ops/zipThese.ts",
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 12
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "f",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "C",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "zipTheseWith"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!zipTheseWithEffect:function(1)",
          "docComment": "/**\n * Just like {@link zipThese} except the result is in an effect.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "zipTheseWithEffect: <A, B, C>(f: "
            },
            {
              "kind": "Content",
              "text": "(these: "
            },
            {
              "kind": "Reference",
              "text": "These",
              "canonicalReference": "effect-tree!These.These_2:type"
            },
            {
              "kind": "Content",
              "text": "<A, B>) => C"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, that: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<C>>"
            }
          ],
          "fileUrlPath": "src/ops/zipThese.ts",
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 14
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "f",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "C",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "zipTheseWithEffect"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!zipTreeFolds:function(1)",
          "docComment": "/**\n * Zip a pair of folds to create a single fold. It will fold into a pair of the result of the zipped folds.  @category fold  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "zipTreeFolds: <const Targets extends "
            },
            {
              "kind": "Content",
              "text": "import(\"effect/Array\")."
            },
            {
              "kind": "Reference",
              "text": "NonEmptyArray",
              "canonicalReference": "effect!NonEmptyArray:type"
            },
            {
              "kind": "Content",
              "text": "<unknown>"
            },
            {
              "kind": "Content",
              "text": ", E = "
            },
            {
              "kind": "Content",
              "text": "unknown"
            },
            {
              "kind": "Content",
              "text": ", R = "
            },
            {
              "kind": "Content",
              "text": "never"
            },
            {
              "kind": "Content",
              "text": ">(...[head, ...tail]: "
            },
            {
              "kind": "Content",
              "text": "import(\"effect-ts-folds\")."
            },
            {
              "kind": "Reference",
              "text": "TupledAlgebras",
              "canonicalReference": "effect-ts-folds!TupledAlgebras:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", Targets, E, R>"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "import(\"effect-ts-folds\")."
            },
            {
              "kind": "Reference",
              "text": "Algebra",
              "canonicalReference": "effect-ts-folds!Algebra:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TreeF.TreeFTypeLambda",
              "canonicalReference": "effect-tree!TreeF.TreeFTypeLambda:interface"
            },
            {
              "kind": "Content",
              "text": ", Targets, E, R>"
            }
          ],
          "fileUrlPath": "src/schemes/fold/index.ts",
          "returnTypeTokenRange": {
            "startIndex": 15,
            "endIndex": 20
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "[head, ...tail]",
              "parameterTypeTokenRange": {
                "startIndex": 9,
                "endIndex": 14
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "Targets",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "E",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 8
              }
            }
          ],
          "name": "zipTreeFolds"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!zipWith:function(1)",
          "docComment": "/**\n * Zip a pair of trees cropping to the smallest degree and depth, and apply the given function.\n *\n * Returns the smallest matching tree of pairs, one taken from each tree at the same position, and run the given function on this pair, returning a tree of its results.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "zipWith: <A, B, C>(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>"
            },
            {
              "kind": "Content",
              "text": ", that: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>"
            },
            {
              "kind": "Content",
              "text": ", f: "
            },
            {
              "kind": "Content",
              "text": "(a: A, b: B) => C"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<C>"
            }
          ],
          "fileUrlPath": "src/ops/zip.ts",
          "returnTypeTokenRange": {
            "startIndex": 9,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "self",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "that",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "isOptional": false
            },
            {
              "parameterName": "f",
              "parameterTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 8
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "C",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "zipWith"
        },
        {
          "kind": "Function",
          "canonicalReference": "effect-tree!zipWithEffect:function(1)",
          "docComment": "/**\n * Just like {@link zipWith} except the given function returns its result in an `Effect`.  @category ops  @function\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "zipWithEffect: <A, B, C>(f: "
            },
            {
              "kind": "Content",
              "text": "(self: A, that: B) => C"
            },
            {
              "kind": "Content",
              "text": ") => "
            },
            {
              "kind": "Content",
              "text": "(self: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<A>, that: "
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<B>) => "
            },
            {
              "kind": "Reference",
              "text": "Effect.Effect",
              "canonicalReference": "effect!Effect:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Tree",
              "canonicalReference": "effect-tree!Tree:type"
            },
            {
              "kind": "Content",
              "text": "<C>>"
            }
          ],
          "fileUrlPath": "src/ops/zip.ts",
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 12
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "f",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "A",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "B",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "C",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "zipWithEffect"
        }
      ]
    }
  ]
}
