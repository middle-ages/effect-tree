## API Report File for "effect-tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Algebra } from 'effect-ts-folds';
import { Applicative as Applicative_2 } from '@effect/typeclass';
import { Array as Array_2 } from 'effect';
import { Bicovariant } from '@effect/typeclass';
import { Coalgebra } from 'effect-ts-folds';
import type { ComposeTypeLambda } from 'effect-ts-laws';
import { Covariant as Covariant_2 } from '@effect/typeclass';
import { Effect } from 'effect';
import { Effect as Effect_2 } from 'effect/Effect';
import { Either } from 'effect';
import { Equivalence } from 'effect';
import { Equivalence as Equivalence_2 } from 'effect/Equivalence';
import * as fc from 'fast-check';
import { default as fc_2 } from 'fast-check';
import { Fix } from 'effect-ts-folds';
import { FlatMap } from '@effect/typeclass';
import { Foldable as Foldable_2 } from '@effect/typeclass';
import type { FunctionN } from 'effect/Function';
import { HashMap } from 'effect';
import { HashSet } from 'effect';
import { HKT } from 'effect';
import type { Isomorphism } from 'effect-ts-laws/typeclass';
import type { LazyArg } from 'effect/Function';
import { Monad as Monad_2 } from '@effect/typeclass';
import { Monoid } from '@effect/typeclass';
import { Monoid as Monoid_2 } from '@effect/typeclass/Monoid';
import { NonEmptyArray } from 'effect/Array';
import { NonEmptyReadonlyArray } from 'effect/Array';
import { Option } from 'effect/Option';
import { Option as Option_2 } from 'effect';
import { Order } from 'effect';
import { Order as Order_3 } from 'effect/Order';
import { Predicate } from 'effect';
import { Predicate as Predicate_2 } from 'effect/Predicate';
import { RAlgebra } from 'effect-ts-folds';
import { ReadonlyArray as ReadonlyArray_2 } from 'effect/Array';
import { Ref } from 'effect';
import { SemiApplicative } from '@effect/typeclass';
import type { Semigroup } from '@effect/typeclass/Semigroup';
import { Semigroup as Semigroup_2 } from '@effect/typeclass';
import { Simplify } from 'effect/Types';
import { StructReturns } from 'effect-ts-folds';
import { TaggedEnum } from 'effect/Data';
import { Traversable as Traversable_2 } from '@effect/typeclass';
import { TupledAlgebras } from 'effect-ts-folds';
import { Unify } from 'effect/Unify';

// @public (undocumented)
const $match: {
    <A, B, C, D, Cases extends {
        readonly Left: (args: {
            readonly _tag: "Left";
            readonly left: B;
        }) => any;
        readonly Right: (args: {
            readonly _tag: "Right";
            readonly right: A;
        }) => any;
        readonly Both: (args: {
            readonly _tag: "Both";
            readonly left: B;
            readonly right: A;
        }) => any;
    }>(cases: Cases & { [K in Exclude<keyof Cases, "Left" | "Right" | "Both">]: never; }): (self: {
        readonly _tag: "Left";
        readonly left: B;
    } | {
        readonly _tag: "Right";
        readonly right: A;
    } | {
        readonly _tag: "Both";
        readonly left: B;
        readonly right: A;
    }) => Unify<ReturnType<Cases["Left" | "Right" | "Both"]>>;
    <A, B, C, D, Cases extends {
        readonly Left: (args: {
            readonly _tag: "Left";
            readonly left: B;
        }) => any;
        readonly Right: (args: {
            readonly _tag: "Right";
            readonly right: A;
        }) => any;
        readonly Both: (args: {
            readonly _tag: "Both";
            readonly left: B;
            readonly right: A;
        }) => any;
    }>(self: {
        readonly _tag: "Left";
        readonly left: B;
    } | {
        readonly _tag: "Right";
        readonly right: A;
    } | {
        readonly _tag: "Both";
        readonly left: B;
        readonly right: A;
    }, cases: Cases & { [K in Exclude<keyof Cases, "Left" | "Right" | "Both">]: never; }): Unify<ReturnType<Cases["Left" | "Right" | "Both"]>>;
};

// @public
const above: {
    (hAlign?: HorizontalAlignment): ColumnOp;
} & ColumnOps;

// @public
const addBorder: {
    (self: Part_2, set: BorderSet): Part_2;
    curried: (set: BorderSet) => EndoOf<Part_2>;
};

// Warning: (ae-forgotten-export) The symbol "Array_3" needs to be exported by the entry point index.d.ts
//
// @public
const addBorders: (([head, ...tail]: Array_3.NonEmptyArray<BorderSet>) => EndoOf<Part_2>) & {
    rest: (sets_0: BorderSet, ...sets: BorderSet[]) => EndoOf<Part_2>;
};

// @public
export const addLevelLabels: (self: Tree<string>) => Tree<string>;

// @public (undocumented)
const addPadHeight: ({ pad: { top, bottom } }: Padded) => (height: number) => number;

// @public (undocumented)
const addPadSize: (padded: Padded) => (width: number, height: number) => [width: number, height: number];

// @public (undocumented)
const addPadWidth: ({ pad: { left, right } }: Padded) => (width: number) => number;

// @public
function addSpacingAfter(label: string): (theme: Theme) => Array_3.NonEmptyArray<string>;

// @public
const after: {
    (vAlign?: VerticalAlignment): (hAlign?: HorizontalAlignment) => BuildPart;
} & BuildAlignedPart;

// @public
interface Aligned extends HorizontallyAligned, VerticallyAligned {
}

// @public
const AlignedArbitrary: fc_2.Arbitrary<Aligned>;

// @public
const AlignedEquivalence: Equivalence.Equivalence<Aligned>;

// @public
const alignHorizontally: (hStruts: HStruts, hAlign: HorizontalAlignment, useLeftRound?: boolean) => EndoOf<string[]>;

// @public
type Alignment = HorizontalAlignment | VerticalAlignment;

// @public
const alignVertically: {
    (vStruts: VStruts, vAlign: VerticalAlignment, alignOrthogonal: Function_2.EndoOf<string[]>, useTopRound?: boolean): EndoOf<Array_3.NonEmptyArray<string[]>>;
    useTopRound(vStruts: VStruts, vAlign: VerticalAlignment, alignOrthogonal: Function_2.EndoOf<string[]>): Function_2.EndoOf<[string[], ...string[][]]>;
};

// @public
const allCodesAt: (nodeCount: number) => NonEmptyArray<number[]>;

// @public
export const allLeaves: GetNodes;

// @public
export const allLeavesFold: TreeFolderK<NonEmptyArrayTypeLambda>;

// @public
const allTreesAt: (nodeCount: number) => Tree<number>[];

// @public
export const annotateDepth: <A>(self: Tree<A>) => Tree<readonly [A, number]>;

// Warning: (ae-forgotten-export) The symbol "TreeF_3" needs to be exported by the entry point index.d.ts
//
// @public
export const annotateDepthUnfold: <A>([tree, previousDepth]: [Tree<A>, number]) => TreeF_3.TreeF<readonly [A, number], [Tree<A>, number]>;

// @public
export const annotateEffectFolder: <A, B, E = never, R = never>(φ: TreeEffectFolder<A, B, E, R>) => (self: TreeF_3.TreeF<A, Tree<[A, B]>>) => Effect.Effect<Tree<[A, B]>, E, R>;

// @public
export const annotateEffectUnfolder: <A, B, E = never, R = never>(ψ: TreeEffectUnfolder<A, Tree<B>, E, R>) => TreeEffectUnfolder<[B, A], [Tree<B>, A], E, R>;

// @public
export const annotateFolder: <A, B>(φ: TreeFolder<A, B>) => TreeFolder<A, Tree<[A, B]>>;

// @public
export const annotateLevelLabelsUnfold: TreeUnfolder<string, [
string,
Tree<string>
]>;

// @public
export const annotateOrdinalUnfold: (counter: Ref.Ref<number>) => <A, E = never, R = never>(pair: [Tree<A>, number]) => Effect_2<TreeF_2<[A, number], [Tree<A>, number]>, E, R>;

// @public
export const append: {
    <A>(self: Tree<A>, child: Tree<A>): Branch<A>;
    <A>(child: Tree<A>): (self: Tree<A>) => Branch<A>;
};

// @public
const append_3: {
    <A>(that: Tree_3.Tree<A>): EndoOf<Zipper_2<A>>;
    tryMove<A>(that: Tree_3.Tree<A>): (zipper: Zipper_2<A>) => Option_2.Option<Zipper_2<A>>;
    move<A>(that: Tree_3.Tree<A>): EndoOf<Zipper_2<A>>;
};

// @public
export const appendAll: {
    <A>(self: Tree<A>, children: Tree<A>[]): Tree<A>;
    <A>(children: Tree<A>[]): (self: Tree<A>) => Tree<A>;
};

// @public
export const Applicative: Applicative_2.Applicative<TreeTypeLambda>;

declare namespace Arbitrary {
    export {
        TreeF_4 as TreeF,
        Tree_2 as Tree,
        PartF,
        Part,
        voidArbitrary,
        nonEmptyArrayArbitrary,
        codePointArbitrary,
        upperCaseArbitrary,
        lowerCaseArbitrary,
        letterArbitrary,
        tinyLettersArbitrary,
        tinyLetterStringArbitrary,
        tinyNonEmptyLettersArbitrary,
        tinyNonEmptyLetterStringArbitrary
    }
}

// @public
const Arbitrary_2: (options?: {
    maxDepth?: number;
}) => fc.Arbitrary<Part_2>;

// @public
interface ArbitraryOptions {
    branchBias: number;
    maxChildren: number;
    maxDepth: number;
    onlyBranches: boolean;
}

declare namespace Arrays {
    export {
        decodeUnfold,
        decode_2 as decode,
        unsafeEncodeFold,
        encode_2 as encode,
        TreeArray,
        TreeArrayLambda,
        NonArrayType,
        ValidArrayTree,
        EncodeFolder
    }
}

// @public
const ArraysIsomorphism: <A>(order: Order.Order<A>) => TreeIsomorphism<A, Array_3.NonEmptyArray2<A>>;

// @public
export const asOrdinal: {
    (initialize: number): (self: Tree<any>) => Tree<number>;
    pre(initialize: number): (self: Tree<any>) => Tree<number>;
};

// @public
export const asOrdinalBranch: {
    (initialize: number): (self: Branch<any>) => Branch<number>;
    pre(initialize: number): <A>(self: Branch<A>) => Branch<number>;
};

// @public
const at: {
    <A>(self: Zipper_2<A>, n: number): Zipper_2<A>;
    (n: number): EndoK<ZipperTypeLambda>;
};

// @public
export const average: (self: Tree<number>) => number;

// @public
export const averageFold: TreeFolder<RunningAverage, RunningAverage>;

// @public
type Axis = (typeof axis)[number];

// @public
const axis: readonly ["horizontal", "vertical"];

// @public
type AxisDirected<H, V> = Record<HorizontalDirection, H> & Record<VerticalDirection, V>;

// @public
const axisDirections: {
    readonly horizontal: readonly ["left", "right"];
    readonly vertical: readonly ["top", "bottom"];
};

// @public
type AxisString<A extends Axis> = A extends 'horizontal' ? string : string[];

// @public
interface BaseDraw<A, Out> {
    // (undocumented)
    (self: Tree<A>): Out;
}

// @public
interface BaseStrut<A extends Axis> {
    // (undocumented)
    axis: A;
    // (undocumented)
    body: NonEmptyArray<string>;
    // (undocumented)
    prefix: AxisString<A>;
    // (undocumented)
    suffix: AxisString<A>;
}

// @public
const before: {
    (vAlign?: VerticalAlignment): (hAlign?: HorizontalAlignment) => BuildPart;
} & BuildAlignedPart;

// @public
const below: {
    (hAlign?: HorizontalAlignment): ColumnOp;
} & ColumnOps;

// @public
const biasedOneOf: <A>(a: fc_2.Arbitrary<A>, branch: fc_2.Arbitrary<Branch<A>>) => ({ branchBias }: ArbitraryOptions) => fc_2.Arbitrary<Tree<A>>;

// @public (undocumented)
const Bicovariant_2: Bicovariant.Bicovariant<TheseTypeLambda>;

// @public (undocumented)
const bimap: Bicovariant.Bicovariant<TheseTypeLambda>['bimap'];

// @public
export const binaryTree: {
    (depth: number): Tree<number>;
    string: (depth: number) => Tree<string>;
};

// @public
export type BooleanFold = <A>(predicate: Predicate_2<A>) => TreeFold<A, boolean>;

// @public
export type BooleanFolder = <A>(predicate: Predicate_2<A>) => TreeFolder<A, boolean>;

// @public
const borderBottom: Bordered & {
    corners: Bordered;
};

// @public
interface Bordered {
    // (undocumented)
    (set: BorderSet): EndoOf<Part_2>;
}

// @public
const borderLeft: Bordered;

// @public
const borderRight: Bordered;

// @public
interface BorderSet {
    // (undocumented)
    elbows: ElbowSet;
    // (undocumented)
    lines: LineSet;
}

// @public
const borderSet: (name: BorderSetName) => BorderSet;

// @public
type BorderSetName = (typeof borderSetNames)[number];

// @public
const borderSetNames: readonly ["ascii", "beveled", "dashed", "dashedWide", "dotted", "double", "halfSolid", "halfSolidFar", "halfSolidNear", "hDouble", "hThick", "near", "solid", "space", "thick", "thickDashed", "thickDashedWide", "thickDotted", "thin", "vDouble", "vThick"];

// @public
type BorderSets = Record<BorderSetName, BorderSet>;

// @public
const borderTop: Bordered & {
    corners: Bordered;
};

// @public
type Both<R, E> = TaggedEnum.Value<These_2<R, E>, 'Both'>;

// @public (undocumented)
const Both: (<A, B>(args: {
    readonly left: B;
    readonly right: A;
}) => {
    readonly _tag: "Both";
    readonly left: B;
    readonly right: A;
}) & {
    from: <R, E>(right: R, left: E) => These_2<R, E>;
};

// @public (undocumented)
const _Both: <A, B>(args: {
    readonly left: B;
    readonly right: A;
}) => {
    readonly _tag: "Both";
    readonly left: B;
    readonly right: A;
};

// @public
const both: <R, E>(left: E, right: R) => These_2<R, E>;

// @public (undocumented)
interface BothSides<R, E> {
    // (undocumented)
    left: E;
    // (undocumented)
    right: R;
}

// @public
const bottomElbowsDirections: readonly ["bottomRight", "bottomLeft"];

// @public
export const bottomSubtrees: <A>(self: Tree<A>) => NonEmptyArray<Tree<A>>;

// @public
export const bottomSubtreesFold: TreeProductFolderK<ForestTypeLambda>;

// @public
const box: {
    (part: Part_2, settings?: Partial<BoxSettings>): Part_2;
    (settings?: Partial<BoxSettings>): EndoOf<Part_2>;
};

// @public (undocumented)
interface BoxSettings {
    // (undocumented)
    border: BorderSet;
    // (undocumented)
    margin: DirectedPad;
    // (undocumented)
    padding: DirectedPad;
}

// @public
export type Branch<A> = Record<'unfixed', BranchF<A, Tree<A>>>;

// @public
export const branch: {
    <A>(value: A, forest: ForestOf<A>): Branch<A>;
    <A>(forest: ForestOf<A>): (value: A) => Branch<A>;
    flipped: <A>(value: A) => (forest: ForestOf<A>) => Branch<A>;
    tupled: <A>(valueAndForest: [value: A, forest: ForestOf<A>]) => Branch<A>;
};

// @public
interface BranchF<A, C> extends LeafF<A> {
    // (undocumented)
    forest: Array_2.NonEmptyReadonlyArray<C>;
}

// @public
const branchF: {
    <A, C>(value: A, forest: NonEmptyReadonlyArray<C>): BranchF<A, C>;
    <C>(forest: NonEmptyReadonlyArray<C>): <A>(value: A) => BranchF<A, C>;
    tupled: <A, C>([node, forest]: [A, Array_2.NonEmptyArray<C>]) => BranchF<A, C>;
};

// @public
type BranchIsomorphism<A, B> = Isomorphism.Isomorphism<Branch<A>, B>;

// @public
const branchLabel: (label: string) => ThemedPart;

// @public
export const breadthOrderValues: GetNodes;

// @public (undocumented)
type BuildAlignedPart = Record<VerticalAlignment, Record<HorizontalAlignment, BuildPart>>;

// @public (undocumented)
type BuildAlignedRow = Record<VerticalAlignment, Record<HorizontalAlignment, BuildRow>>;

// @public (undocumented)
interface BuildPart {
    // (undocumented)
    (part: Part_2, struts?: Partial<Struts>): EndoOf<Part_2>;
}

// @public (undocumented)
interface BuildRow {
    // (undocumented)
    (cells: readonly Part_2[], struts?: Partial<Struts>): Part_2;
}

// @public
const bulletRoles: readonly ["rootBullet", "branchBullet", "leafBullet"];

// @public
export const byParentUnfold: <A>(unfolder: (parent: A) => A[]) => TreeUnfolder<A, A>;

// @public
type ChildToParent<A> = EdgeMap<A>['toParent'];

declare namespace Codec {
    export {
        Indented,
        Arrays,
        Edges,
        Paths,
        Prufer,
        TreeIsomorphism,
        BranchIsomorphism,
        EdgeListIsomorphism,
        ArraysIsomorphism,
        PruferIsomorphism,
        IndentedIsomorphism
    }
}

// @public
const codeCount: (nodeCount: number) => number;

// @public
const codePointArbitrary: (min: number, max: number) => fc_2.Arbitrary<string>;

// @public
type Column = {
    unfixed: ColumnF<Part_2>;
} & Fix<PartFTypeLambda>;

// @public
const Column: (hAlign: HorizontallyAligned) => ((cells: Part_2[]) => Column);

// @public
const column: ((hAlign?: HorizontalAlignment) => (cells: Part_2[], left?: HStrut, right?: HStrut) => Part_2) & Record<HorizontalAlignment, (cells: Part_2[], left?: HStrut, right?: HStrut) => Part_2>;

// @public
type ColumnF<A> = TaggedEnum.Value<PartF_3<A>, 'ColumnF'>;

// @public
const ColumnF: <A>(args: {
    readonly cells: A[];
    readonly hAlign: HorizontalAlignment;
    readonly left: HStrut;
    readonly right: HStrut;
}) => {
    readonly _tag: "ColumnF";
    readonly cells: A[];
    readonly hAlign: HorizontalAlignment;
    readonly left: HStrut;
    readonly right: HStrut;
};

// @public
const columnF: (hAligned: HorizontallyAligned) => <A>(cells: A[]) => ColumnF<A>;

// @public
interface ColumnFData<A> extends HorizontallyAligned {
    // (undocumented)
    cells: A[];
}

// @public
interface ColumnOp {
    // (undocumented)
    (that: Part_2, left?: HStrut, right?: HStrut): EndoOf<Part_2>;
}

// @public
type ColumnOps = Record<HorizontalAlignment, ColumnOp>;

// @public (undocumented)
const combine: <E>(eSemigroup: Semigroup_2.Semigroup<E>) => <R>(rSemigroup: Semigroup_2.Semigroup<R>) => (self: These_2<R, E>, that: These_2<R, E>) => These_2<R, E>;

// @public (undocumented)
const computeNodeCount: (code: number[]) => number;

// @public (undocumented)
const computePadHeight: ({ pad: { top, bottom } }: Padded) => number;

// @public (undocumented)
const computePadSize: (padded: Padded) => [width: number, height: number];

// @public (undocumented)
const computePadWidth: ({ pad: { left, right } }: Padded) => number;

// @public
export const computeRunningAverage: ({ numerator, denominator, }: RunningAverage) => number;

// @public
type CornerDirection = (typeof elbowDirections)[number];

// @public
type Cornered<A> = Record<CornerDirection, A>;

// @public
export const countOf: <A>(predicate: Predicate.Predicate<A>) => TreeFold<A, number>;

// @public
export const countOfFold: <A>(predicate: Predicate.Predicate<A>) => TreeFolder<A, number>;

// @public
export const Covariant: Covariant_2.Covariant<TreeTypeLambda>;

// @public
const Covariant_3: Covariant_2.Covariant<TreeFTypeLambda>;

// @public
const Covariant_4: Covariant_2.Covariant<PartFTypeLambda>;

// @public
export const cropDepth: (depth: number) => <A>(self: Tree<A>) => Tree<A>;

// @public
export const cropDepthUnfold: <A>([depth, self]: readonly [number, Tree<A>]) => TreeF_3.TreeF<A, readonly [number, Tree<A>]>;

// @public
const cross: (name: CrossName) => string;

// @public
type Crosses = Record<CrossName, string>;

// @public
type CrossName = (typeof crossNames)[number];

// @public
const crossNames: readonly ["ascii", "double", "hDouble", "hThick", "solid", "space", "thick", "thin", "vDouble", "vThick", "vThickBottom", "vThickLeft", "vThickRight", "vThickTop", "vThinBottom", "vThinLeft", "vThinRight", "vThinTop"];

// @public
const decode: (lines: Array_3.NonEmptyArray<string>) => Tree<string>;

// @public
const decode_2: <A>(ta: TreeArray<A>) => Tree<A>;

// @public
const decode_3: <A>(edges: EdgeList<A>) => Branch<A>;

// @public
const decode_4: <A>(order: Order.Order<A>) => (pathList: NonEmptyArray2<A>) => Tree<A>;

// @public
const decode_5: (code: number[]) => Branch<number>;

// @public
const decodeIndentedUnfold: ([[value, depth], second, ...tail]: Array_3.NonEmptyArray<[string, number]>) => TreeF_3.TreeF<string, Array_3.NonEmptyArray<[string, number]>>;

// @public
const decodeMap: <A>(map: EdgeMap<A>) => Branch<A>;

// @public
const decodeUnfold: <A>(a: TreeArray<A>) => TreeF_3.TreeF<A>;

// @public
const decodeUnfold_2: TreeUnfolderK<EdgeMapTypeLambda>;

// @public
const decrementIndents: (decrement?: number) => EndoOf<Theme>;

// @public
const decrementSpacing: (decrement?: number) => EndoOf<Theme>;

// @public (undocumented)
const defaultHStrut: HStrut;

// @public
const defaultNumberedOptions: NumberedArbitraryOptions;

// @public
const defaultOptions: ArbitraryOptions;

// @public
const defaultTheme: Theme;

// @public (undocumented)
const defaultVStrut: VStrut;

// @public
export const degreeFold: TreeFolderOf<number>;

// @public
const depthFirst: EndoK<ZipperTypeLambda>;

// @public
export const descendantCountFold: TreeFolderOf<number>;

// @public
export const destruct: <A>(self: Tree<A>) => readonly [A, readonly Tree<A>[]];

// @public
const destruct_2: <A, B>(self: TreeF_2<A, B>) => readonly [A, B[]];

// @public
export const destructBranch: <A>({ unfixed: { node, forest }, }: Branch<A>) => [A, Array_3.NonEmptyReadonlyArray<Tree<A>>];

// @public
type Directed<A> = Record<Direction, A>;

// @public
type DirectedPad = Directed<number>;

// @public
type Direction = (typeof directions)[number];

// @public
const directions: readonly ["top", "right", "bottom", "left"];

declare namespace Draw {
    export {
        PartF_2 as PartF,
        show,
        showFold,
        axisDirections,
        topElbowDirections,
        bottomElbowsDirections,
        elbowDirections,
        axis,
        directions,
        Axis,
        HorizontalDirection,
        VerticalDirection,
        Direction,
        Directed,
        AxisDirected,
        AxisString,
        replaceElbow,
        elbowSetNames,
        ElbowSetName,
        ElbowSets,
        elbowSet,
        replaceLine,
        lineSetNames,
        LineSetName,
        LineSets,
        lineSet,
        replaceBorderLine,
        replaceBorderElbow,
        borderSetNames,
        BorderSetName,
        BorderSets,
        borderSet,
        CornerDirection,
        Cornered,
        ElbowSet,
        LineSet,
        TeeSet,
        BorderSet,
        crossNames,
        CrossName,
        Crosses,
        cross,
        replaceTee,
        teeSetNames,
        TeeSetName,
        TeeSets,
        teeSet,
        glyphGroups,
        HStrut,
        VStrut,
        HStruts,
        VStruts,
        BaseStrut,
        Struts,
        isHStrut,
        isVStrut,
        defaultHStrut,
        defaultVStrut,
        normalizeStruts,
        StrutEquivalence,
        showHStrut,
        showVStrut,
        showStrut,
        showHStruts,
        showVStruts,
        showStruts,
        HStrutsEquivalence,
        VStrutsEquivalence,
        StrutsEquivalence,
        leafLabel,
        branchLabel,
        headBranch,
        tailBranch,
        enrichedDraw,
        BaseDraw,
        StringDraw,
        UnlinesDraw,
        EnrichedDraw,
        DrawTree,
        themedTree,
        drawTree,
        treeLayout,
        noIndentThemes,
        indentedThemes,
        themeNames,
        ThemeName,
        ThemeMap,
        Theme,
        Themed,
        ThemedPart,
        defaultTheme,
        getTheme,
        mapThemes,
        addSpacingAfter,
        formatNodes,
        prefixGlyph,
        suffixGlyph,
        indentGlyph,
        indentGlyphPart,
        GlyphRole,
        GlyphSet,
        GlyphSetName,
        bulletRoles,
        glyphRoles,
        glyphSetNames,
        glyphSet,
        modIndents,
        modSpacing,
        modFormatter,
        getGlyph,
        getGlyphPart,
        getIndents,
        getSpacing,
        getFormatter,
        setFormatter,
        setIndents,
        setSpacing,
        incrementIndents,
        decrementIndents,
        incrementSpacing,
        decrementSpacing,
        fillSpacing,
        horizontalAlignments,
        verticalAlignments,
        HorizontalAlignment,
        VerticalAlignment,
        Alignment,
        VerticallyAligned,
        HorizontallyAligned,
        Aligned,
        matchHorizontal,
        matchVertical,
        mapHorizontalAlignments,
        mapVerticalAlignments,
        forHorizontalAlignments,
        forVerticalAlignments,
        showAlignment,
        showAlignments,
        HorizontalEquivalence,
        VerticalEquivalence,
        AlignedEquivalence,
        alignHorizontally,
        alignVertically,
        empty,
        text,
        isEmptyPart,
        isText,
        isRow,
        isColumn,
        getText,
        prefixText,
        suffixText,
        matchPart,
        BuildRow,
        BuildPart,
        BuildAlignedRow,
        BuildAlignedPart,
        row,
        before,
        after,
        ColumnOp,
        ColumnOps,
        column,
        below,
        above,
        Empty,
        Text,
        Row,
        Column,
        Part_2 as Part,
        fixPart,
        unfixPart,
        unfixRow,
        unfixColumn,
        drawPart,
        PartFolder,
        partCata,
        showPartAlgebra,
        showPart,
        BoxSettings,
        box,
        emptyTextPart,
        joinText,
        stackText,
        repeatText,
        hIndent,
        vIndent,
        hSpace,
        vSpace,
        spacePad,
        Bordered,
        borderTop,
        borderRight,
        borderBottom,
        borderLeft,
        hBorders,
        vBorders,
        addBorder,
        addBorders,
        DirectedPad,
        Padded,
        normalizePad,
        normalizePadded,
        computePadWidth,
        computePadHeight,
        addPadWidth,
        addPadHeight,
        computePadSize,
        addPadSize,
        padding,
        noPadding,
        setBoxNodesFormatter
    }
}

// @public
const drawPart: {
    (part: Part_2): string[];
    unlines: (part: Part_2) => string;
};

// @public
interface DrawTree extends EnrichedDraw, Record<ThemeName, EnrichedDraw> {
}

// @public
export const drawTree: DrawTree;

// @public
export const drill: {
    <A>(path: number[], self: Tree<A>): Option<Tree<A>>;
    <A>(self: Tree<A>): (path: number[]) => Option<Tree<A>>;
    flip: (path: number[]) => <A>(self: Tree<A>) => Option<Tree<A>>;
};

// @public
type EdgeList<A> = NonEmptyArray<TreeEdge<A>>;

// @public
const EdgeListIsomorphism: <A>() => TreeIsomorphism<A, EdgeList<A>>;

// @public
interface EdgeListTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: EdgeList<this['Target']>;
}

// @public
interface EdgeMap<A> {
    roots: HashSet.HashSet<A>;
    toChildren: HashMap.HashMap<A, A[]>;
    toParent: HashMap.HashMap<A, A>;
}

// @public
interface EdgeMapTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: EdgeMap<this['Target']>;
}

declare namespace Edges {
    export {
        decodeUnfold_2 as decodeUnfold,
        decodeMap,
        decode_3 as decode,
        encodeFold,
        encode_3 as encode,
        index,
        indexParents,
        rootTreeEdge,
        setParent,
        getMapChildren,
        setMapRoot,
        getEdgeEquivalence,
        getEdgeListEquivalence,
        sortEdgeList,
        numeric,
        TreeEdge,
        EdgeList,
        EdgeMap,
        RootsMap,
        ChildToParent,
        ParentToChildren,
        TreeEdgeTypeLambda,
        EdgeListTypeLambda,
        EdgeMapTypeLambda
    }
}

// @public
const elbowDirections: readonly ["topLeft", "topRight", "bottomRight", "bottomLeft"];

// @public
type ElbowSet = Cornered<string>;

// @public
const elbowSet: (name: ElbowSetName) => ElbowSet;

// @public
type ElbowSetName = (typeof elbowSetNames)[number];

// @public
const elbowSetNames: readonly ["ascii", "diagonal", "double", "halfSolid", "halfSolidNear", "halfSolidFar", "hDouble", "hThick", "round", "solid", "space", "thick", "thin", "vDouble", "vThick"];

// @public
type ElbowSets = Record<ElbowSetName, ElbowSet>;

// @public
type Empty = {
    unfixed: EmptyF;
} & Fix<PartFTypeLambda>;

// @public
const empty: Empty;

// @public
type EmptyF = TaggedEnum.Value<PartF_3<unknown>, 'EmptyF'>;

// @public
const EmptyF: <A>(args: void) => {
    readonly _tag: "EmptyF";
};

// @public
const emptyF: EmptyF;

// @public
const EmptyPartFArbitrary: fc_2.Arbitrary<PartF_2.EmptyF>;

// @public
const emptyTextPart: Text;

// @public
const encode: {
    (self: Tree<string>, indent?: number): Array_3.NonEmptyArray<string>;
    curried: (indent?: number) => (self: Tree<string>) => Array_3.NonEmptyArray<string>;
};

// @public
const encode_2: <A>(tree: ValidArrayTree<A>) => TreeArray<A>;

// @public
const encode_3: <A>(tree: Tree<A>) => EdgeList<A>;

// @public
const encode_4: <A>(tree: Tree<A>) => NonEmptyArray2<A>;

// Warning: (ae-forgotten-export) The symbol "Order_2" needs to be exported by the entry point index.d.ts
//
// @public
const encode_5: <A>(order: Order_2.Order<A>) => ((self: Branch<A>) => A[]);

// @public
const encodeFold: TreeFolderK<EdgeListTypeLambda>;

// @public
type EncodeFolder<A> = TreeFolder<A, TreeArray<A>>;

// @public
const end: EndoK<ZipperTypeLambda>;

// @public
export interface Endo {
    // (undocumented)
    <A>(a: A): A;
}

// @public
export interface EndoK<F extends HKT.TypeLambda> {
    // (undocumented)
    <A>(a: HKT.Kind<F, never, unknown, unknown, A>): typeof a;
}

// @public
export interface EndoOf<A> {
    // (undocumented)
    (a: A): A;
}

// @public
interface EnrichedDraw extends UnlinesDraw<string> {
    // (undocumented)
    number: UnlinesDraw<number>;
}

// @public
function enrichedDraw(themeName: ThemeName): EnrichedDraw;

// @public
const equalsFail: Effect.Effect<void, undefined>;

// @public
const equalsSuccess: Effect.Effect<void, undefined>;

// @public
export const eqv: Predicate_2<Tree<boolean>>;

// @public
export const eqvFold: BooleanFolder;

// @public
export const every: Predicate_2<Tree<boolean>>;

// @public
export const everyFold: BooleanFolder;

// @public
export const everyOf: BooleanFold;

// @public
const fillSpacing: ({ spacing }: Theme) => string[];

// @public
export const filterLeaves: <A>(predicate: Predicate.Predicate<A>) => (self: Tree<A>) => Tree<A>;

// @public
export const filterLeavesFold: <A>(predicate: Predicate.Predicate<A>) => TreeFolder<A, Tree<A>>;

// @public
export const filterMinimumLeaf: <A>(order: Order.Order<A>) => (t: Tree<A>) => [filtered: Tree<A>, minLeaf: A, maybeParent: Option_2.Option<A>];

// @public
export const filterNodes: <A>(predicate: Predicate.Predicate<Tree<A>>) => (self: Tree<A>) => Tree<A>;

// @public
export const filterNodesFold: <A>(predicate: Predicate.Predicate<Tree<A>>) => TreeFolder<A, Tree<A>>;

// @public
export const firstChild: <A>(self: Branch<A>) => Tree<A>;

// @public
export const fixBranch: <A>(branchF: BranchF<A, Tree<A>>) => Branch<A>;

// @public
const fixPart: <Type extends Part_2>(unfixed: PartF_3<Part_2>) => Type;

// @public
export const
/**
* Convert the non-recursive version of the tree with children of type
* `Tree<A>` into the recursive {@link Tree} type.
* @category basic
* @function
*/
fixTree: <A>(treeF: TreeF_2<A, Tree<A>>) => Tree<A>;

// @public
export const flap: {
    <A, B>(self: Tree<(a: A) => B>): (a: A) => Tree<B>;
    <A, B>(a: A, self: Tree<(a: A) => B>): Tree<B>;
};

// @public
export const flatMap: FlatMap.FlatMap<TreeTypeLambda>['flatMap'];

// @public
const FlatMap_2: FlatMap.FlatMap<TreeFTypeLambda>;

// @public
const flatMap_2: FlatMap.FlatMap<TreeFTypeLambda>['flatMap'];

// @public
export const flatMapEffect: {
    <A, B, E = unknown, R = never>(self: Tree<A>, f: (a: A) => Effect.Effect<Tree<B>, E, R>): Effect.Effect<Tree<B>, E, R>;
    <A, B, E = unknown, R = never>(f: (a: A) => Effect.Effect<Tree<B>, E, R>): (self: Tree<A>) => Effect.Effect<Tree<B>, E, R>;
    pre: <A, B, E = unknown, R = never>(f: (a: A) => Effect.Effect<Tree<B>, E, R>) => (self: Tree<A>) => Effect.Effect<Tree<B>, E, R>;
};

// @public
export const flatten: <A>(self: Tree<Tree<A>>) => Tree<A>;

// @public
export const flattenEffect: <A>(self: Tree<Tree<A>>) => Effect.Effect<Tree<A>>;

// @public
export const flattenFold: <A>(self: TreeF_3.TreeF<Tree<A>, Tree<A>>) => Tree<A>;

// @public
export const Foldable: Foldable_2.Foldable<TreeTypeLambda>;

// @public
export const foldMap: <A>(M: Monoid.Monoid<A>) => TreeFold<A, A>;

// @public
export const folds: {
    allLeaves: TreeFolderK<NonEmptyArrayTypeLambda>;
    arrays: TreeFolderK<Arrays.TreeArrayLambda>;
    boolean: (M: Monoid_2<boolean>) => <A>(predicate: Predicate_2<A>) => TreeFolder<A, boolean>;
    countOf: <A>(predicate: Predicate_2<A>) => TreeFolder<A, number>;
    degree: TreeFolderOf<number>;
    descendantCount: TreeFolderOf<number>;
    edges: TreeFolderK<Edges.EdgeListTypeLambda>;
    eqv: BooleanFolder;
    every: BooleanFolder;
    filterLeaves: <A>(predicate: Predicate_2<A>) => TreeFolder<A, Tree<A>>;
    filterNodes: <A>(predicate: Predicate_2<Tree<A>>) => TreeFolder<A, Tree<A>>;
    flatten: <A>(self: TreeF_2<Tree<A>, Tree<A>>) => Tree<A>;
    growLeaves: <A>(grow: TreeUnfold<A, A>) => TreeFolder<A, Tree<A>>;
    includes: <A>(equals: Equivalence_2<A>) => ((needle: A) => TreeFolder<A, boolean>);
    levels: <A>(self: TreeF_2<A, NonEmptyArray2<A>>) => NonEmptyArray2<A>;
    maximumDegree: TreeFolderOf<number>;
    maximumHeight: TreeFolderOf<number>;
    monoid: <A>(M: Monoid_2<A>) => TreeFolder<A, A>;
    nodeOrdinalFold: TreeFolderOf<number>;
    numericMax: TreeFolder<number, number>;
    numericMin: TreeFolder<number, number>;
    numericProduct: TreeFolder<number, number>;
    numericSum: TreeFolder<number, number>;
    paths: TreeFolderK<NonEmptyArray2TypeLambda>;
    postOrder: TreeFolderK<NonEmptyArrayTypeLambda>;
    predicate: (M: Monoid_2<boolean>) => <A>(predicate: Predicate_2<A>) => TreeFolder<A, boolean>;
    preOrder: TreeFolderK<NonEmptyArrayTypeLambda>;
    some: BooleanFolder;
    unzip: <A, B>(t: TreeF_2<[A, B], [Tree<A>, Tree<B>]>) => [Tree<A>, Tree<B>];
    unzipTheseFold: <A, B>(self: TreeF_2<These_2<A, B>, These_2<Tree<A>, Tree<B>>>) => These_2<Tree<A>, Tree<B>>;
    xor: BooleanFolder;
};

// @public
export type ForestOf<A> = NonEmptyReadonlyArray<Tree<A>>;

// @public
export type ForestTypeLambda = ComposeTypeLambda<NonEmptyArrayTypeLambda, TreeTypeLambda>;

// @public
const forHorizontalAlignments: <R>(f: (align: HorizontalAlignment, n: number) => R) => Record<HorizontalAlignment, R>;

// @public
const formatNodes: ({ formatter }: Theme) => EndoOf<Tree<string>>;

// @public
const forVerticalAlignments: <R>(f: (align: VerticalAlignment, n: number) => R) => Record<VerticalAlignment, R>;

// @public
export const from: <A>(value: A, ...forest: Tree<A>[]) => Tree<A>;

// @public
function fromLevel<A>(focus: Tree_3.Tree<A>, { lefts, rights, parent }: ZipperLevel<A>): Tree_3.Tree<A>;

// @public
const fromOrdinal: (n: number, nodeCount: number) => number[];

// @public
const fromTree: <A>(focus: Tree_3.Tree<A>) => Zipper_2<A>;

// @public
interface GetArbitrary<A> {
    // (undocumented)
    (options: RuntimeOptions): fc_2.Arbitrary<Tree<A>>;
}

// @public
const getArbitrary: <A>(a: fc.Arbitrary<A>) => <C>(c: fc.Arbitrary<C>) => fc.Arbitrary<TreeF_2<A, C>>;

// @public
const getArbitrary_2: <A>(a: fc_2.Arbitrary<A>, rawOptions?: Partial<ArbitraryOptions>) => fc_2.Arbitrary<Tree_3.Tree<A>>;

// @public
const getArbitrary_3: <A>(a: fc_2.Arbitrary<A>) => fc_2.Arbitrary<PartF_2.PartF<A>>;

// @public
export const getBranchForest: <A>(self: Branch<A>) => ForestOf<A>;

// @public
const getBranchForest_2: <A, C>({ forest, }: BranchF<A, C>) => Array_2.NonEmptyReadonlyArray<C>;

// @public
const getColumnFArbitrary: <A>(a: fc_2.Arbitrary<A>) => fc_2.Arbitrary<PartF_2.ColumnF<A>>;

// @public
const getColumnFEqualsE: <A>(equalsA: (self: A, that: A) => Effect.Effect<void, undefined>) => ((self: ColumnF<A>, that: ColumnF<A>) => Effect.Effect<void, undefined>);

// @public
const getDepth: <A>({ levels }: Zipper_2<A>) => number;

// @public
const getEdgeEquivalence: <A>(equalsA: Equivalence.Equivalence<A>) => Equivalence.Equivalence<TreeEdge<A>>;

// @public
const getEdgeListEquivalence: <A>(equalsA: Equivalence.Equivalence<A>) => Equivalence.Equivalence<EdgeList<A>>;

// @public
export const getEquivalence: <A>(equalsA: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Tree<A>>;

// @public
const getEquivalence_2: <A>(equalsA: Equivalence.Equivalence<A>) => <C>(equalsC: Equivalence.Equivalence<C>) => Equivalence.Equivalence<TreeF_2<A, C>>;

// @public (undocumented)
const getEquivalence_3: <E>(equalsE: Equivalence.Equivalence<E>) => <R>(equalsR: Equivalence.Equivalence<R>) => Equivalence.Equivalence<These_2<R, E>>;

// @public
const getEquivalence_4: <A>(equalsA: Equivalence.Equivalence<A>) => Equivalence.Equivalence<PartF_3<A>>;

// @public
export const getEquivalenceEffect: <A>(equalsA: Equivalence.Equivalence<A>) => (self: Tree<A>, that: Tree<A>) => Effect.Effect<void, undefined>;

// @public
const getFirstCodeFor: (nodeCount: number) => number[];

// @public
const getFocus: <A>({ focus }: Zipper_2<A>) => Tree_3.Tree<A>;

// @public
export const getForest: <A>(self: Tree<A>) => readonly Tree<A>[];

// @public
const getForest_2: <A, C>(self: TreeF_2<A, C>) => readonly C[];

// @public
const getForest_3: <A>({ focus }: Zipper_2<A>) => readonly Tree_3.Tree<A>[];

// @public
const getFormatter: ({ formatter }: Theme) => EndoOf<string>;

// @public
const getGlyph: {
    (role: GlyphRole, theme: Theme): string;
    (theme: Theme): (role: GlyphRole) => string;
};

// @public
const getGlyphPart: {
    (role: GlyphRole, theme: Theme): Part_2;
    (theme: Theme): (role: GlyphRole) => Part_2;
};

// @public
const getIndents: ({ indents }: Theme) => number;

// @public
const getLastCodeFor: (n: number) => number[];

// @public
const getLefts: <A>({ lefts }: Zipper_2<A>) => Tree_3.Tree<A>[];

// @public
const getMapChildren: <A>({ roots, toChildren, }: EdgeMap<A>) => [A, A[]];

// @public
export const getMonoid: <A>(F: Monoid.Monoid<A>) => Monoid.Monoid<Tree<A>>;

// @public
export type GetNodes = <A>(self: Tree<A>) => Array_2.NonEmptyArray<A>;

// @public
const getNthTree: (ordinal: number, nodeCount: number) => Tree<number>;

// @public
const getNumberedArbitrary: (options?: Partial<NumberedArbitraryOptions>) => fc_2.Arbitrary<Tree<number>>;

// @public
const getNumberedBranchArbitrary: (options?: Partial<NumberedArbitraryOptions>) => fc_2.Arbitrary<Branch<number>>;

// @public
export const getOrder: <A>(orderA: Order_2.Order<A>) => Order_2.Order<Tree<A>>;

// @public (undocumented)
const getOrder_2: <E>(orderE: Order.Order<E>) => <R>(orderR: Order.Order<R>) => Order.Order<These_2<R, E>>;

// @public
const getRights: <A>({ rights }: Zipper_2<A>) => Tree_3.Tree<A>[];

// @public
const getRowFArbitrary: <A>(a: fc_2.Arbitrary<A>) => fc_2.Arbitrary<PartF_2.RowF<A>>;

// @public
const getRowFEqualsE: <A>(equalsA: (self: A, that: A) => Effect.Effect<void, undefined>) => ((self: RowF<A>, that: RowF<A>) => Effect.Effect<void, undefined>);

// @public
export const getSemigroup: <A>(F: Semigroup_2.Semigroup<A>) => Semigroup_2.Semigroup<Tree<A>>;

// @public (undocumented)
const getSemigroup_2: <B>(semigroupB: Semigroup_2.Semigroup<B>) => <A>(semigroupA: Semigroup_2.Semigroup<A>) => Semigroup_2.Semigroup<These_2<A, B>>;

// @public
const getSpacing: ({ spacing }: Theme) => number;

// @public
const getStringArbitrary: (options?: Partial<NumberedArbitraryOptions>) => fc_2.Arbitrary<Tree<string>>;

// @public
const getText: (text: Text) => string;

// @public
const getTheme: (name: ThemeName) => Theme;

// @public
export const getValue: <A>(self: Tree<A>) => A;

// @public
const getValue_2: <A, C>({ node }: TreeF_2<A, C>) => A;

// @public
const getValue_3: <A>({ focus }: Zipper_2<A>) => A;

// @public
const glyphGroups: (name: TeeSetName & LineSetName & ElbowSetName & CrossName) => {
    tees: TeeSet;
    lines: LineSet;
    elbows: ElbowSet;
    cross: string;
};

// @public
type GlyphRole = (typeof glyphRoles)[number];

// @public
const glyphRoles: readonly ["elbow", "hLine", "indent", "rightTee", "space", "tee", "vLine", "rootBullet", "branchBullet", "leafBullet"];

// @public
type GlyphSet = Record<GlyphRole, string>;

// @public
const glyphSet: (name: GlyphSetName) => GlyphSet;

// @public
type GlyphSetName = (typeof glyphSetNames)[number];

// @public
const glyphSetNames: readonly ["ascii", "bullets", "double", "hDouble", "hThick", "round", "space", "thick", "thin", "unix", "unixRound", "vDouble", "vThick"];

// @public
export const growLeaves: <A>(grow: TreeUnfold<A, A>) => TreeFold<A, Tree<A>>;

// @public
export const growLeavesFold: <A>(grow: TreeUnfold<A, A>) => TreeFolder<A, Tree<A>>;

// @public
const hasLefts: <A>({ lefts }: Zipper_2<A>) => boolean;

// @public
const hasRights: <A>({ rights }: Zipper_2<A>) => boolean;

// @public
const hBorders: Bordered;

// @public
const head: EndoK<ZipperTypeLambda>;

// Warning: (ae-forgotten-export) The symbol "Part_3" needs to be exported by the entry point index.d.ts
//
// @public
const headBranch: (theme: Theme) => EndoOf<Part_3.Part>;

// @public
const headN: {
    <A>(self: Zipper_2<A>, n: number): Zipper_2<A>;
    (n: number): <A>(self: Zipper_2<A>) => Zipper_2<A>;
};

// @public
const hIndent: {
    (repeat: number, indent?: string): Part_2;
    (indent?: string): (repeat: number) => Part_2;
};

// @public
type HorizontalAlignment = (typeof horizontalAlignments)[number];

// @public
const horizontalAlignments: readonly ["left", "center", "right"];

// @public
const HorizontalArbitrary: fc_2.Arbitrary<HorizontallyAligned>;

// @public
type HorizontalDirection = 'left' | 'right';

// @public
const HorizontalEquivalence: Equivalence.Equivalence<HorizontallyAligned>;

// @public
interface HorizontallyAligned extends HStruts {
    // (undocumented)
    hAlign: HorizontalAlignment;
}

// @public
const hSpace: ((fillLeft?: string, fillRight?: string) => (padLeft?: number, padRight?: number) => EndoOf<Part_2>) & {
    left: (fillLeft?: string, padLeft?: number) => EndoOf<Part_2>;
    right: (fillRight?: string, padRight?: number) => EndoOf<Part_2>;
};

// @public
type HStrut = BaseStrut<'horizontal'>;

// @public
const HStrut: {
    (body?: NonEmptyArray<string>, prefix?: string, suffix?: string): HStrut;
    space: HStrut;
    fill({ prefix, body, suffix }: HStrut): (available: number) => string;
};

// @public
type HStruts = Record<HorizontalDirection, HStrut>;

// @public
const HStruts: {
    (left: HStrut, right?: HStrut): HStruts;
    space: HStruts;
    fill({ left, right }: HStruts): (availableLeft: number, availableRight: number) => EndoOf<string>;
};

// @public
const HStrutsEquivalence: Equivalence.Equivalence<HStruts>;

// @public
export const imap: {
    <A, B>(to: (a: A) => B, from: (b: B) => A): <R, O, E>(self: Tree<A>) => Tree<B>;
    <R, O, E, A, B>(self: Tree<A>, to: (a: A) => B, from: (b: B) => A): Tree<B>;
};

// @public
const imap_2: {
    <A, B>(to: (a: A) => B, from: (b: B) => A): <R, O, E>(self: TreeF_2<E, A>) => TreeF_2<E, B>;
    <R, O, E, A, B>(self: TreeF_2<E, A>, to: (a: A) => B, from: (b: B) => A): TreeF_2<E, B>;
};

// @public
const imap_3: {
    <A, B>(to: (a: A) => B, from: (b: B) => A): <R, O, E>(self: {
        readonly _tag: "EmptyF";
    } | {
        readonly _tag: "TextF";
        readonly show: string;
    } | {
        readonly _tag: "RowF";
        readonly cells: A[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
        readonly vAlign: VerticalAlignment;
        readonly top: VStrut;
        readonly bottom: VStrut;
    } | {
        readonly _tag: "ColumnF";
        readonly cells: A[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
    }) => {
        readonly _tag: "EmptyF";
    } | {
        readonly _tag: "TextF";
        readonly show: string;
    } | {
        readonly _tag: "RowF";
        readonly cells: B[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
        readonly vAlign: VerticalAlignment;
        readonly top: VStrut;
        readonly bottom: VStrut;
    } | {
        readonly _tag: "ColumnF";
        readonly cells: B[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
    };
    <R, O, E, A, B>(self: {
        readonly _tag: "EmptyF";
    } | {
        readonly _tag: "TextF";
        readonly show: string;
    } | {
        readonly _tag: "RowF";
        readonly cells: A[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
        readonly vAlign: VerticalAlignment;
        readonly top: VStrut;
        readonly bottom: VStrut;
    } | {
        readonly _tag: "ColumnF";
        readonly cells: A[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
    }, to: (a: A) => B, from: (b: B) => A): {
        readonly _tag: "EmptyF";
    } | {
        readonly _tag: "TextF";
        readonly show: string;
    } | {
        readonly _tag: "RowF";
        readonly cells: B[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
        readonly vAlign: VerticalAlignment;
        readonly top: VStrut;
        readonly bottom: VStrut;
    } | {
        readonly _tag: "ColumnF";
        readonly cells: B[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
    };
};

// @public
export const includes: <A>(equals: Equivalence.Equivalence<A>) => ((a: A) => Predicate.Predicate<Tree<A>>);

// @public
export const includesFold: <A>(equals: Equivalence.Equivalence<A>) => ((needle: A) => TreeFolder<A, boolean>);

// @public
const incrementIndents: (increment?: number) => EndoOf<Theme>;

// @public
const incrementSpacing: (increment?: number) => EndoOf<Theme>;

declare namespace Indented {
    export {
        encode,
        decode,
        decodeIndentedUnfold
    }
}

// @public
const IndentedIsomorphism: (indent: number) => TreeIsomorphism<string, NonEmptyArray<string>>;

// @public
const indentedThemes: readonly ["ascii", "bullets", "space"];

// @public
const indentGlyph: (theme: Theme) => (prefixRole: GlyphRole, indentRole: GlyphRole) => string;

// @public
const indentGlyphPart: (prefixRole: GlyphRole, indentRole: GlyphRole) => ThemedPart;

// @public
const index: <A>(self: Tree<A>) => EdgeMap<A>;

// @public
const indexParents: <A>(edges: EdgeList<A>) => EdgeMap<A>;

// @public
export const insertAllAt: {
    <A>(self: Tree<A>, n: number, children: ForestOf<A>): Branch<A>;
    <A>(n: number, children: ForestOf<A>): (self: Tree<A>) => Branch<A>;
};

// @public
export const insertAt: {
    <A>(self: Tree<A>, child: Tree<A>, n: number): Branch<A>;
    <A>(child: Tree<A>): (self: Tree<A>, n: number) => Branch<A>;
};

// @public
const isAtMaxDepth: Predicate.Predicate<RuntimeOptions>;

// @public (undocumented)
const isBoth: {
    <T extends {
        readonly _tag: "Left";
        readonly left: any;
    } | {
        readonly _tag: "Right";
        readonly right: any;
    } | {
        readonly _tag: "Both";
        readonly left: any;
        readonly right: any;
    }>(u: T): u is T & {
        readonly _tag: "Both";
    };
    (u: unknown): u is {
        readonly _tag: "Both";
        readonly left: unknown;
        readonly right: unknown;
    };
};

// @public
export const isBranch: <A>(self: Tree<A>) => self is Branch<A>;

// @public
const isBranch_2: <A, C>(treeF: TreeF_2<A, C>) => treeF is BranchF<A, C>;

// @public
const isColumn: (self: Part_2) => self is Column;

// @public
const isColumnF: <A>(self: PartF_3<A>) => self is ColumnF<A>;

// @public
const isEmptyF: <A>(self: PartF_3<A>) => self is EmptyF;

// @public
const isEmptyPart: (self: Part_2) => self is Empty;

// @public
const isFirstCode: Predicate.Predicate<number[]>;

// @public
const isHStrut: (strut: BaseStrut<Axis>) => strut is HStrut;

// @public
const isLastCode: Predicate.Predicate<number[]>;

// @public
export const isLeaf: <A>(self: Tree<A>) => self is Leaf<A>;

// @public
const isLeaf_2: <A, C>(self: TreeF_2<A, C>) => self is LeafF<A>;

// @public
const isLeaf_3: <A>({ focus }: Zipper_2<A>) => boolean;

// @public (undocumented)
const isLeft: {
    <T extends {
        readonly _tag: "Left";
        readonly left: any;
    } | {
        readonly _tag: "Right";
        readonly right: any;
    } | {
        readonly _tag: "Both";
        readonly left: any;
        readonly right: any;
    }>(u: T): u is T & {
        readonly _tag: "Left";
    };
    (u: unknown): u is {
        readonly _tag: "Left";
        readonly left: unknown;
    };
};

// @public
const isPartFOf: <Tag extends "EmptyF" | "TextF" | "RowF" | "ColumnF">(tag: Tag) => {
    <T extends {
        readonly _tag: "EmptyF";
    } | {
        readonly _tag: "TextF";
        readonly show: string;
    } | {
        readonly _tag: "RowF";
        readonly cells: any[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
        readonly vAlign: VerticalAlignment;
        readonly top: VStrut;
        readonly bottom: VStrut;
    } | {
        readonly _tag: "ColumnF";
        readonly cells: any[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
    }>(u: T): u is T & {
        readonly _tag: Tag;
    };
    (u: unknown): u is Extract<{
        readonly _tag: "EmptyF";
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "TextF";
        readonly show: string;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "RowF";
        readonly cells: unknown[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
        readonly vAlign: VerticalAlignment;
        readonly top: VStrut;
        readonly bottom: VStrut;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "ColumnF";
        readonly cells: unknown[];
        readonly hAlign: HorizontalAlignment;
        readonly left: HStrut;
        readonly right: HStrut;
    }, {
        readonly _tag: Tag;
    }>;
};

// @public (undocumented)
const isRight: {
    <T extends {
        readonly _tag: "Left";
        readonly left: any;
    } | {
        readonly _tag: "Right";
        readonly right: any;
    } | {
        readonly _tag: "Both";
        readonly left: any;
        readonly right: any;
    }>(u: T): u is T & {
        readonly _tag: "Right";
    };
    (u: unknown): u is {
        readonly _tag: "Right";
        readonly right: unknown;
    };
};

// @public
const isRoot: <A>({ parent }: Zipper_2<A>) => boolean;

// @public
const isRow: (self: Part_2) => self is Row;

// @public
const isRowF: <A>(self: PartF_3<A>) => self is RowF<A>;

// @public
const isText: (self: Part_2) => self is Text;

// @public
const isTextF: <A>(self: PartF_3<A>) => self is TextF;

// @public (undocumented)
const isTheseOf: <Tag extends "Left" | "Right" | "Both">(tag: Tag) => {
    <T extends {
        readonly _tag: "Left";
        readonly left: any;
    } | {
        readonly _tag: "Right";
        readonly right: any;
    } | {
        readonly _tag: "Both";
        readonly left: any;
        readonly right: any;
    }>(u: T): u is T & {
        readonly _tag: Tag;
    };
    (u: unknown): u is Extract<{
        readonly _tag: "Left";
        readonly left: unknown;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "Right";
        readonly right: unknown;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "Both";
        readonly left: unknown;
        readonly right: unknown;
    }, {
        readonly _tag: Tag;
    }>;
};

// @public
const isValidPathList: <A>(equals: Equivalence.Equivalence<A>) => Predicate.Predicate<NonEmptyArray2<A>>;

// @public
const isVStrut: (strut: BaseStrut<Axis>) => strut is VStrut;

// @public
const join: <A>(S: Semigroup<A>) => (self: {
    readonly _tag: "Left";
    readonly left: A;
} | {
    readonly _tag: "Right";
    readonly right: A;
} | {
    readonly _tag: "Both";
    readonly left: A;
    readonly right: A;
}) => Unify<A>;

// @public
const joinText: {
    (xs: string[], separator?: string): Part_2;
    (separator?: string): (xs: string[]) => Part_2;
};

// @public
const labeledTreeCount: (n: number) => number;

// @public
const last: EndoK<ZipperTypeLambda>;

// @public
export const lastChild: <A>(self: Branch<A>) => Tree<A>;

// @public
const lastN: {
    <A>(self: Zipper_2<A>, n: number): Zipper_2<A>;
    (n: number): <A>(self: Zipper_2<A>) => Zipper_2<A>;
};

// @public
export type Leaf<A> = Record<'unfixed', LeafF<A>>;

// @public
export const leaf: <A>(value: A) => Leaf<A>;

// @public
interface LeafF<A> {
    // (undocumented)
    node: A;
}

// @public
const leafF: <A>(value: A) => TreeF_2<A>;

// @public
const leafLabel: (label: string) => ThemedPart;

// @public
type Left<R, E> = TaggedEnum.Value<These_2<R, E>, 'Left'>;

// @public (undocumented)
const Left: (<A, B>(args: {
    readonly left: B;
}) => {
    readonly _tag: "Left";
    readonly left: B;
}) & {
    from: <R, E>(left: E) => These_2<R, E>;
};

// @public (undocumented)
const _Left: <A, B>(args: {
    readonly left: B;
}) => {
    readonly _tag: "Left";
    readonly left: B;
};

// @public
const left: <E>(left: E) => These_2<never, E>;

// @public
const leftOption: <R, E>(self: These_2<R, E>) => Option_2.Option<E>;

// @public (undocumented)
type LeftSide<E> = OneSide<'left', E>;

// @public
export const length: <A>(self: Tree<A>) => number;

// @public
const length_2: <A, C>(self: TreeF_2<A, C>) => number;

// @public
const letterArbitrary: fc_2.Arbitrary<string>;

// @public
export const levels: <A>(self: Tree<A>) => NonEmptyArray2<A>;

// @public
export const levelsFold: <A>(self: TreeF_3.TreeF<A, NonEmptyArray2<A>>) => NonEmptyArray2<A>;

// @public
export interface LevelTreeSettings {
    degree?: (depth: number) => number;
    depth: number;
}

// @public
export const levelTreeUnfold: ({ depth, degree, }: LevelTreeSettings) => TreeUnfolder<number, number>;

// @public
type LineSet = Directed<string>;

// @public
const lineSet: (name: LineSetName) => LineSet;

// @public
type LineSetName = (typeof lineSetNames)[number];

// @public
const lineSetNames: readonly ["ascii", "dashed", "dashedWide", "dotted", "double", "halfSolid", "halfSolidNear", "halfSolidFar", "hDouble", "hThick", "near", "solid", "space", "thick", "thickDashed", "thickDashedWide", "thickDotted", "thin", "vDouble", "vThick"];

// @public
type LineSets = Record<LineSetName, LineSet>;

// @public
const lowerCaseArbitrary: fc_2.Arbitrary<string>;

// @public
export const map: Covariant_2.Covariant<TreeTypeLambda>['map'];

// @public
const map_2: Covariant_2.Covariant<TreeFTypeLambda>['map'];

// @public
const map_3: Covariant_2.Covariant<PartFTypeLambda>['map'];

// @public
export const mapEffect: {
    <A, B, E = unknown, R = never>(self: Tree<A>, f: (a: A) => Effect.Effect<B, E, R>): Effect.Effect<Tree<B>, E, R>;
    <A, B, E = unknown, R = never>(f: (a: A) => Effect.Effect<B, E, R>): (self: Tree<A>) => Effect.Effect<Tree<B>, E, R>;
    pre: <A, B, E = unknown, R = never>(f: (a: A) => Effect.Effect<B, E, R>) => (self: Tree<A>) => Effect.Effect<Tree<B>, E, R>;
};

// @public
const mapHorizontalAlignments: <A>(f: (align: HorizontalAlignment, n: number) => A) => [A, A, A];

// @public (undocumented)
const mapLeft: {
    <E, G>(f: (e: E) => G): <R, O, A>(self: {
        readonly _tag: "Left";
        readonly left: E;
    } | {
        readonly _tag: "Right";
        readonly right: A;
    } | {
        readonly _tag: "Both";
        readonly left: E;
        readonly right: A;
    }) => {
        readonly _tag: "Left";
        readonly left: G;
    } | {
        readonly _tag: "Right";
        readonly right: A;
    } | {
        readonly _tag: "Both";
        readonly left: G;
        readonly right: A;
    };
    <R, O_1, E, A_1, G_1>(self: {
        readonly _tag: "Left";
        readonly left: E;
    } | {
        readonly _tag: "Right";
        readonly right: A_1;
    } | {
        readonly _tag: "Both";
        readonly left: E;
        readonly right: A_1;
    }, f: (e: E) => G_1): {
        readonly _tag: "Left";
        readonly left: G_1;
    } | {
        readonly _tag: "Right";
        readonly right: A_1;
    } | {
        readonly _tag: "Both";
        readonly left: G_1;
        readonly right: A_1;
    };
};

// @public (undocumented)
const mapRight: {
    <A, B>(f: (a: A) => B): <R, O, E>(self: {
        readonly _tag: "Left";
        readonly left: E;
    } | {
        readonly _tag: "Right";
        readonly right: A;
    } | {
        readonly _tag: "Both";
        readonly left: E;
        readonly right: A;
    }) => {
        readonly _tag: "Left";
        readonly left: E;
    } | {
        readonly _tag: "Right";
        readonly right: B;
    } | {
        readonly _tag: "Both";
        readonly left: E;
        readonly right: B;
    };
    <R, O, E, A, B>(self: {
        readonly _tag: "Left";
        readonly left: E;
    } | {
        readonly _tag: "Right";
        readonly right: A;
    } | {
        readonly _tag: "Both";
        readonly left: E;
        readonly right: A;
    }, f: (a: A) => B): {
        readonly _tag: "Left";
        readonly left: E;
    } | {
        readonly _tag: "Right";
        readonly right: B;
    } | {
        readonly _tag: "Both";
        readonly left: E;
        readonly right: B;
    };
};

// @public
const mapThemes: <A>(f: (theme: Theme, name: ThemeName) => A) => Record<ThemeName, A>;

// @public
const mapValue: {
    <A, B, C>(self: TreeF_2<A, C>, f: (a: A) => B): TreeF_2<B, C>;
    <A, B>(f: (a: A) => B): <C>(self: TreeF_2<A, C>) => TreeF_2<B, C>;
};

// @public
const mapVerticalAlignments: <A>(f: (align: VerticalAlignment, n: number) => A) => [A, A, A];

// @public
export const match: <A, R>({ onLeaf, onBranch }: Matcher<A, R>) => ((self: Tree<A>) => R);

// @public
const match_2: <A, C, R>({ onLeaf, onBranch }: MatcherF<A, C, R>) => (treeF: TreeF_2<A, C>) => R;

// @public (undocumented)
const match_3: <R, E, Result>({ Left: onLeft, Right: onRight, Both: onBoth, }: {
    Left: (left: Left<R, E>) => Result;
    Right: (right: Right<R, E>) => Result;
    Both: (both: Both<R, E>) => Result;
}) => (self: These_2<R, E>) => Unify<Result>;

// @public
export interface Matcher<A, R> {
    // (undocumented)
    onBranch: (node: A, forest: ForestOf<A>) => R;
    // (undocumented)
    onLeaf: (node: A) => R;
}

// @public (undocumented)
interface MatcherF<A, C, R> {
    // (undocumented)
    onBranch: (node: A, forest: Array_2.NonEmptyReadonlyArray<C>) => R;
    // (undocumented)
    onLeaf: (node: A) => R;
}

// @public
const matchHorizontal: <R>(onLeft: LazyArg<R>, onCenter: LazyArg<R>, onRight: LazyArg<R>) => (o: HorizontalAlignment) => R;

// @public
const matchPart: <R>(onEmpty: R, onText: (s: string) => R, onRow: (r: Row) => R, onColumn: (c: Column) => R) => ((p: Part_2) => R);

// @public
const matchPartF: <A, R>(empty: R, text: (s: string) => R, row: (row: RowF<A>) => R, column: (column: ColumnF<A>) => R) => ((part: PartF_3<A>) => R);

// @public
const matchVertical: <R>(onTop: LazyArg<R>, onMiddle: LazyArg<R>, onBottom: LazyArg<R>) => (o: VerticalAlignment) => R;

// @public
export const max: (tree: Tree<number>) => number;

// @public
export const maximumDegreeFold: TreeFolderOf<number>;

// @public
export const maximumHeightFold: TreeFolderOf<number>;

// @public
export const maximumLeaf: <A>(Order: Order.Order<A>) => (tree: Tree<A>) => A;

// @public
export const maximumLeafAndParent: <A>(Order: Order.Order<A>) => ((self: Tree<A>) => readonly [A, Option_2.Option<A>]);

// @public
export const maximumLeafAndParentFold: typeof minimumLeafParentFold;

// @public
export const maximumLeafFold: <A>(Order: Order.Order<A>) => TreeFolder<A, A>;

// @public
export const maximumNode: <A>(Order: Order.Order<A>) => (tree: Tree<A>) => A;

// @public
export const maximumNodeDegree: TreeFoldOf<number>;

// @public
export const maximumNodeFold: <A>(Order: Order.Order<A>) => TreeFolder<A, A>;

// @public
export const maximumNodeHeight: TreeFoldOf<number>;

// @public
export const min: (tree: Tree<number>) => number;

// @public
export const minimumLeaf: <A>(Order: Order.Order<A>) => (tree: Tree<A>) => A;

// @public
export const minimumLeafAndParent: <A>(Order: Order.Order<A>) => ((self: Tree<A>) => readonly [A, Option_2.Option<A>]);

// @public
export const minimumLeafFold: <A>(Order: Order.Order<A>) => TreeFolder<A, A>;

// @public
export const minimumLeafParentFold: <A>(o: Order.Order<A>) => TreeFolder<A, readonly [A, Option_2.Option<A>]>;

// @public
export const minimumNode: <A>(Order: Order.Order<A>) => (tree: Tree<A>) => A;

// @public
export const minimumNodeFold: <A>(Order: Order.Order<A>) => TreeFolder<A, A>;

// @public
export const modBranch: {
    <A>(self: Tree<A>, f: (branch: Branch<A>) => Tree<A>): Tree<A>;
    <A>(f: (branch: Branch<A>) => Tree<A>): (self: Tree<A>) => Tree<A>;
};

// @public
export const modBranchForest: <A>(f: (a: ForestOf<A>) => ForestOf<A>) => ((self: Branch<A>) => Branch<A>);

// @public
export const modForest: {
    <A>(self: Tree<A>, f: EndoOf<readonly Tree<A>[]>): Tree<A>;
    <A>(f: EndoOf<readonly Tree<A>[]>): (self: Tree<A>) => Tree<A>;
};

// @public
function modFormatter(f: EndoOf<EndoOf<string>>): EndoOf<Theme>;

// @public
function modIndents(f: EndoOf<number>): EndoOf<Theme>;

// @public
function modSpacing(f: EndoOf<number>): EndoOf<Theme>;

// @public
export const modValue: {
    <A>(self: Tree<A>, f: (a: A) => A): Tree<A>;
    <A>(f: (a: A) => A): (self: Tree<A>) => Tree<A>;
};

// @public
export const Monad: Monad_2.Monad<TreeTypeLambda>;

// @public
export const MonoidAverage: Monoid.Monoid<RunningAverage>;

// @public
export const monoidFold: <A>(M: Monoid.Monoid<A>) => TreeFolder<A, A>;

// @public
export const multiply: (tree: Tree<number>) => number;

// @public
export const nAryTree: {
    ({ degree, depth, }: {
        degree: number;
        depth: number;
    }): Tree<number>;
    string: (a_0: {
        degree: number;
        depth: number;
    }) => Tree<string>;
};

// @public
const next: EndoK<ZipperTypeLambda>;

// @public
const nextCode: EndoOf<number[]>;

// @public
const nextCodeWrap: EndoOf<number[]>;

// @public
const nextDepth: Function_2.EndoOf<RuntimeOptions>;

// @public
const nextN: {
    <A>(self: Zipper_2<A>, n: number): Zipper_2<A>;
    (n: number): <A>(self: Zipper_2<A>) => Zipper_2<A>;
};

// @public
const nextTree: EndoOf<Branch<number>>;

// @public
const nextTreeWrap: EndoOf<Branch<number>>;

// @public
export const nodeCount: TreeFoldOf<number>;

// @public
export const nodeCountAtLeast: (atLeast: number) => <A>(self: Tree<A>) => boolean;

// @public
export const nodeCountAtLeastFold: (atLeast: number) => TreeEffectFolderOf<number, void>;

// @public
export const nodeOrdinalFold: (counter: Ref.Ref<number>) => <A, E = never, R = never>(_: Effect_2<TreeF_2<A, number>>) => Effect_2<number, E, R>;

// @public
export const nodeOrdinalUnfold: (counter: Ref.Ref<number>) => <A, E = never, R = never>(self: Tree<A>) => Effect_2<TreeF_2<number, Tree<A>>, E, R>;

// @public
const noIndentThemes: readonly ["thin", "thick", "hThick", "vThick", "unix", "unixRound", "round", "double", "hDouble", "vDouble"];

// @public
type NonArrayType<A> = A extends unknown[] ? [never, 'Cannot encode a tree of arrays as an array tree'] : A extends readonly unknown[] ? [never, 'Cannot encode a tree of readonly arrays as an array tree'] : A;

// @public
export type NonEmptyArray2<A> = NonEmptyArray<NonEmptyArray<A>>;

// @public
export type NonEmptyArray2TypeLambda = ComposeTypeLambda<NonEmptyArrayTypeLambda, NonEmptyArrayTypeLambda>;

// @public
const nonEmptyArrayArbitrary: <T>(arb: fc_2.Arbitrary<T>, options?: Partial<{
    minLength: number;
    maxLength: number;
}>) => fc_2.Arbitrary<NonEmptyArray<T>>;

// @public
export interface NonEmptyArrayTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: Array_2.NonEmptyArray<this['Target']>;
}

// @public (undocumented)
const noPadding: DirectedPad;

// @public
const normalizeOptions: ({ onlyBranches, ...options }?: Partial<ArbitraryOptions>) => ArbitraryOptions;

// @public
const normalizePad: (padded?: Partial<DirectedPad>) => DirectedPad;

// @public
const normalizePadded: (padded?: Partial<{
    pad?: Partial<DirectedPad>;
    padStruts?: Partial<Struts>;
}>) => Padded;

// @public
const normalizeStruts: (struts?: Partial<Struts>) => Struts;

// @public
export const nthChild: {
    <A>(n: number, self: Tree<A>): Option<Tree<A>>;
    <A>(self: Tree<A>): (n: number) => Option<Tree<A>>;
    flip: (n: number) => <A>(self: Tree<A>) => Option<Tree<A>>;
};

// @public
interface NumberedArbitraryOptions extends ArbitraryOptions {
    initialize: number;
}

// @public
const numeric: (edges: EdgeList<number>) => NonEmptyArray<[number, number]>;

// @public
export const numericMaxFold: TreeFolder<number, number>;

// @public
export const numericMinFold: TreeFolder<number, number>;

// @public
export const numericProductFold: TreeFolder<number, number>;

// @public
export const numericSumFold: TreeFolder<number, number>;

// @public
export const of: <A>(value: A) => Leaf<A>;

// @public (undocumented)
type OneSide<Side extends 'left' | 'right', A> = Record<Side, A>;

// @public (undocumented)
const onlyBoth: <R, E>(self: These_2<R, E>) => Option_2.Option<[R, E]>;

// @public
const onlyLeft: <R, E>(self: These_2<R, E>) => Option_2.Option<E>;

// @public (undocumented)
const onlyOne: <R, E>(self: These_2<R, E>) => Option_2.Option<Either.Either<R, E>>;

// @public
const onlyRight: <R, E>(self: These_2<R, E>) => Option_2.Option<R>;

// @public
interface OptionalZipper {
    // (undocumented)
    <A>(zipper: Zipper_2<A>): Option_2.Option<Zipper_2<A>>;
}

// @public
interface OptionalZipperOf<A> {
    // (undocumented)
    (zipper: Zipper_2<A>): Option_2.Option<Zipper_2<A>>;
}

// @public
const pad: <R, E>(self: These_2<R, E>) => [Option_2.Option<R>, Option_2.Option<E>];

// @public
interface Padded {
    pad: DirectedPad;
    padStruts: Struts;
}

// @public (undocumented)
const padding: (top: number, right?: number, bottom?: number, left?: number) => DirectedPad;

// @public
type ParentToChildren<A> = EdgeMap<A>['toChildren'];

declare namespace Part {
    export {
        Arbitrary_2 as Arbitrary
    }
}

// @public
type Part_2 = Empty | Text | Row | Column;

// @public
const partCata: <A>(folder: PartFolder<A>) => ((part: Part_2) => A);

declare namespace PartF {
    export {
        HorizontalArbitrary,
        VerticalArbitrary,
        AlignedArbitrary,
        getArbitrary_3 as getArbitrary,
        EmptyPartFArbitrary,
        TextFPArtArbitrary,
        getColumnFArbitrary,
        getRowFArbitrary
    }
}

declare namespace PartF_2 {
    export {
        emptyF,
        textF,
        rowF,
        columnF,
        map_3 as map,
        imap_3 as imap,
        traverse_3 as traverse,
        Covariant_4 as Covariant,
        Traversable_4 as Traversable,
        ColumnFData,
        RowFData,
        PartF_3 as PartF,
        EmptyF,
        TextF,
        RowF,
        ColumnF,
        PartFTypeLambda,
        PartFDefinition,
        isPartFOf,
        isEmptyF,
        isTextF,
        isRowF,
        isColumnF,
        matchPartF,
        getEquivalence_4 as getEquivalence,
        getRowFEqualsE,
        getColumnFEqualsE,
        equalsSuccess,
        equalsFail
    }
}

// @public
type PartF_3<A> = TaggedEnum<{
    EmptyF: {};
    TextF: {
        show: string;
    };
    RowF: RowFData<A>;
    ColumnF: ColumnFData<A>;
}>;

// @public
interface PartFDefinition extends TaggedEnum.WithGenerics<1> {
    // (undocumented)
    readonly taggedEnum: PartF_3<this['A']>;
}

// @public
type PartFolder<A> = Algebra<PartFTypeLambda, A>;

// @public
interface PartFTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: PartF_3<this['Target']>;
}

// @public
const pathListFold: TreeFolderK<NonEmptyArray2TypeLambda>;

// @public
const pathListUnfold: <A>(order: Order.Order<A>) => TreeUnfolder<A, NonEmptyArray2<A>>;

declare namespace Paths {
    export {
        encode_4 as encode,
        decode_4 as decode,
        pathListFold,
        pathListUnfold,
        isValidPathList
    }
}

// @public
export const postOrderFold: TreeFolderK<NonEmptyArrayTypeLambda>;

// @public
export const postOrderValues: GetNodes;

// @public
export const predicateFold: (M: Monoid.Monoid<boolean>) => <A>(predicate: Predicate_2<A>) => TreeFolder<A, boolean>;

// @public
const prefixGlyph: (theme: Theme) => (role: GlyphRole) => EndoOf<string>;

// @public
const prefixText: (prefix: Text) => EndoOf<Text>;

// @public
export const preOrderFold: TreeFolderK<NonEmptyArrayTypeLambda>;

// @public
export const preOrderValues: GetNodes;

// @public
export const prepend: {
    <A>(self: Tree<A>, child: Tree<A>): Branch<A>;
    <A>(child: Tree<A>): (self: Tree<A>) => Branch<A>;
};

// @public
const prepend_3: {
    <A>(that: Tree_3.Tree<A>): EndoOf<Zipper_2<A>>;
    tryMove<A>(that: Tree_3.Tree<A>): (zipper: Zipper_2<A>) => Option_2.Option<Zipper_2<A>>;
    move<A>(that: Tree_3.Tree<A>): EndoOf<Zipper_2<A>>;
};

// @public
export const prependAll: {
    <A>(self: Tree<A>, children: Tree<A>[]): Tree<A>;
    <A>(children: Tree<A>[]): (self: Tree<A>) => Tree<A>;
};

// @public
const previous: EndoK<ZipperTypeLambda>;

// @public
const previousCode: EndoOf<number[]>;

// @public
const previousCodeWrap: EndoOf<number[]>;

// @public
const previousN: {
    <A>(self: Zipper_2<A>, n: number): Zipper_2<A>;
    (n: number): <A>(self: Zipper_2<A>) => Zipper_2<A>;
};

// @public
const previousTree: EndoOf<Branch<number>>;

// @public
const previousTreeWrap: EndoOf<Branch<number>>;

// @public
export const product: SemiApplicative.SemiApplicative<TreeTypeLambda>['product'];

// @public
export const productAll: Applicative_2.Applicative<TreeTypeLambda>['productAll'];

// @public
export const productMany: <R, O, E, A>(self: Tree<A>, collection: Iterable<Tree<A>>) => Tree<[A, ...A[]]>;

declare namespace Prufer {
    export {
        toEdges,
        decode_5 as decode,
        encode_5 as encode,
        getFirstCodeFor,
        getLastCodeFor,
        isFirstCode,
        isLastCode,
        previousCode,
        nextCode,
        previousCodeWrap,
        nextCodeWrap,
        previousTree,
        nextTree,
        previousTreeWrap,
        nextTreeWrap,
        labeledTreeCount,
        computeNodeCount,
        codeCount,
        fromOrdinal,
        toOrdinal,
        getNthTree,
        treeToOrdinal,
        allCodesAt,
        allTreesAt
    }
}

// @public
const pruferEncodableArbitrary: fc_2.Arbitrary<Branch<number>>;

// @public
const PruferIsomorphism: BranchIsomorphism<number, number[]>;

// @public
function pushSelf<A>(zipper: Zipper_2<A>): {
    levels: NonEmptyArray<ZipperLevel<A>>;
    parent: Option_2.Option<A>;
};

// @public
export const reduce: Foldable_2.Foldable<TreeTypeLambda>['reduce'];

// @public
const remove: OptionalZipper;

// @public
export const removeFirstChild: <A>(self: Tree<A>) => Tree<A>;

// @public
export const removeForest: <A>(self: Branch<A>) => Leaf<A>;

// @public
export const removeLastChild: <A>(self: Tree<A>) => Tree<A>;

// @public
export const removeNthChild: {
    <A>(n: number, self: Tree<A>): Tree<A>;
    <A>(self: Tree<A>): (n: number) => Tree<A>;
    flip: (n: number) => <A>(self: Tree<A>) => Tree<A>;
};

// @public
export const removeSlice: (n: number, deleteCount: number) => EndoK<TreeTypeLambda>;

// @public
const repeat: {
    <A>(self: Zipper_2<A>, n: number, nav: OptionalZipper): Zipper_2<A>;
    (n: number, nav: OptionalZipper): EndoK<ZipperTypeLambda>;
};

// @public
const repeatText: {
    (repeat: string): (width: number) => Part_2;
    (width: number, repeat: string): Part_2;
};

// @public
const repeatUntil: <A>(navigation: OptionalZipper, predicate: Predicate.Predicate<Tree_3.Tree<A>>) => (self: Zipper_2<A>) => Option_2.Option<Zipper_2<A>>;

// @public
const repeatUntilValue: <A>(navigation: OptionalZipper, predicate: Predicate.Predicate<A>) => OptionalZipperOf<A>;

// @public
const replace: <A>(that: Tree_3.Tree<A>) => EndoOf<Zipper_2<A>>;

// @public
const replaceBorderElbow: {
    (set: BorderSet, direction: CornerDirection, glyph: string): BorderSet;
    (direction: CornerDirection, glyph: string): EndoOf<BorderSet>;
    named: (direction: CornerDirection, from: ElbowSetName) => EndoOf<BorderSet>;
};

// @public
const replaceBorderLine: {
    (set: BorderSet, direction: Direction, glyph: string): BorderSet;
    (direction: Direction, glyph: string): EndoOf<BorderSet>;
    named: (direction: Direction, from: LineSetName) => EndoOf<BorderSet>;
};

// @public
export const replaceEffectFolder: <A, B, E = never, R = never>(φ: TreeEffectFolder<A, B, E, R>) => TreeEffectFolder<A, Tree<B>, E, R>;

// @public
const replaceElbow: {
    (set: ElbowSet, direction: CornerDirection, glyph: string): ElbowSet;
    (direction: CornerDirection, glyph: string): EndoOf<ElbowSet>;
    named: (direction: CornerDirection, glyph: string) => (name: ElbowSetName) => ElbowSet;
};

// @public
export const replaceFolder: <A, B>(φ: TreeFolder<A, B>) => TreeFolder<A, Tree<B>>;

// @public
const replaceLine: {
    (set: LineSet, direction: Direction, glyph: string): LineSet;
    (direction: Direction, glyph: string): EndoOf<LineSet>;
    named: (direction: Direction, glyph: string) => (name: LineSetName) => LineSet;
};

// @public
const replaceTee: {
    (set: TeeSet, direction: Direction, glyph: string): TeeSet;
    (direction: Direction, glyph: string): EndoOf<TeeSet>;
    named: (direction: Direction, glyph: string) => (name: TeeSetName) => TeeSet;
};

// @public
const rewind: EndoK<ZipperTypeLambda>;

// @public
type Right<R, E> = TaggedEnum.Value<These_2<R, E>, 'Right'>;

// @public (undocumented)
const Right: (<A, B>(args: {
    readonly right: A;
}) => {
    readonly _tag: "Right";
    readonly right: A;
}) & {
    from: <R, E>(right: R) => These_2<R, E>;
};

// @public (undocumented)
const _Right: <A, B>(args: {
    readonly right: A;
}) => {
    readonly _tag: "Right";
    readonly right: A;
};

// @public
const right: <R>(right: R) => These_2<R, unknown>;

// @public
const rightOption: <R, E>(self: These_2<R, E>) => Option_2.Option<R>;

// @public (undocumented)
type RightSide<R> = OneSide<'right', R>;

// @public
const root: EndoK<ZipperTypeLambda>;

// @public
type RootsMap<A> = EdgeMap<A>['roots'];

// @public
const rootTreeEdge: <A>(child: A) => [A, Option_2.Option<A>];

// @public
type Row = {
    unfixed: RowF<Part_2>;
} & Fix<PartFTypeLambda>;

// @public
const Row: (aligned: Aligned) => ((cells: Part_2[]) => Row);

// @public
const row: {
    (vAlign?: VerticalAlignment): (hAlign?: HorizontalAlignment) => BuildRow;
} & BuildAlignedRow;

// @public
type RowF<A> = TaggedEnum.Value<PartF_3<A>, 'RowF'>;

// @public
const RowF: <A>(args: {
    readonly cells: A[];
    readonly hAlign: HorizontalAlignment;
    readonly left: HStrut;
    readonly right: HStrut;
    readonly vAlign: VerticalAlignment;
    readonly top: VStrut;
    readonly bottom: VStrut;
}) => {
    readonly _tag: "RowF";
    readonly cells: A[];
    readonly hAlign: HorizontalAlignment;
    readonly left: HStrut;
    readonly right: HStrut;
    readonly vAlign: VerticalAlignment;
    readonly top: VStrut;
    readonly bottom: VStrut;
};

// @public
const rowF: (aligned: Aligned) => <A>(cells: A[]) => RowF<A>;

// @public
interface RowFData<A> extends ColumnFData<A>, VerticallyAligned {
}

// @public
export interface RunningAverage {
    // (undocumented)
    denominator: number;
    // (undocumented)
    numerator: number;
}

// @public
export const RunningAverage: RunningAverage;

// @public
interface RuntimeOptions extends ArbitraryOptions {
    currentDepth: number;
}

// @public
export const sequence: <F extends HKT.TypeLambda>(F: Applicative_2.Applicative<F>) => <A, E = unknown, R = unknown, I = never>(self: Tree<HKT.Kind<F, I, R, E, A>>) => HKT.Kind<F, I, R, E, Tree<A>>;

// @public
export const sequenceEffect: <A, E = unknown, O = unknown>(self: Tree<Effect.Effect<A, E, O>>) => Effect.Effect<Tree<A>, E, O>;

// @public
const setBoxNodesFormatter: Function_2.EndoOf<Theme>;

// @public
export const setForest: {
    <A>(self: Tree<A>, forest: ForestOf<A>): Branch<A>;
    <A>(forest: ForestOf<A>): (self: Tree<A>) => Branch<A>;
    flip: <A>(self: Tree<A>) => (forest: ForestOf<A>) => Branch<A>;
};

// @public
const setForest_2: {
    <A, B, C>(forest: Array_2.NonEmptyArray<B>, self: TreeF_2<A, C>): TreeF_2<A, B>;
    <A, C>(self: TreeF_2<A, C>): <B>(forest: Array_2.NonEmptyArray<B>) => TreeF_2<A, B>;
};

// @public
const setFormatter: (formatter: EndoOf<string>) => EndoOf<Theme>;

// @public
const setIndents: (indents: number) => EndoOf<Theme>;

// @public (undocumented)
const setLeft: {
    <R, E, D>(self: These_2<R, E>, d: D): These_2<R, D>;
    <D>(d: D): <R, E>(self: These_2<R, E>) => These_2<R, D>;
};

// @public
const setMapRoot: <A>(map: EdgeMap<A>) => (root: A) => EdgeMap<A>;

// @public
const setParent: <A>(a: A) => (edge: TreeEdge<A>) => TreeEdge<A>;

// @public (undocumented)
const setRight: {
    <R, E, S>(self: These_2<R, E>, s: S): These_2<S, E>;
    <S>(s: S): <R, E>(self: These_2<R, E>) => These_2<S, E>;
};

// @public
const setSpacing: (spacing: number) => EndoOf<Theme>;

// @public
export const setValue: {
    <A>(self: Tree<A>, value: A): Tree<A>;
    <A>(value: A): (self: Tree<A>) => Tree<A>;
};

// @public
const setValue_2: {
    <A, B, C>(value: B, self: TreeF_2<A, C>): TreeF_2<B, C>;
    <A, C>(self: TreeF_2<A, C>): <B>(value: B) => TreeF_2<B, C>;
};

// @internal
const show: (self: Tree<string>) => string;

// @public
const showAlignment: (align: Alignment) => string;

// @public
const showAlignments: ({ hAlign, vAlign, }: {
    hAlign: HorizontalAlignment;
    vAlign: VerticalAlignment;
}) => string;

// @internal
const showFold: TreeFolder<string, string>;

// @public
const showHStrut: ({ prefix, body, suffix }: HStrut) => string;

// @public
const showHStruts: ({ right, left }: HStruts) => string;

// @public
const showPart: (part: Part_2) => string;

// @public
const showPartAlgebra: PartFolder<string>;

// @public
const showStrut: (strut: BaseStrut<Axis>) => string;

// @public
const showStruts: ({ top, right, bottom, left }: Struts) => string;

// @public
const showVStrut: ({ prefix, body, suffix }: VStrut) => string;

// @public
const showVStruts: ({ top, bottom }: VStruts) => string;

// @public
export const sliceForest: {
    <A>(self: Tree<A>, low: number, high?: number): Tree<A>[];
    flip: <A>(self: Tree<A>) => (low: number, high?: number) => Tree<A>[];
    curry: (low: number, high?: number) => <A>(self: Tree<A>) => Tree<A>[];
};

// @public
export const some: Predicate_2<Tree<boolean>>;

// @public
export const someFold: BooleanFolder;

// @public
export const someOf: BooleanFold;

// @public
const sortEdgeList: <A>(o: Order.Order<A>) => (edges: EdgeList<A>) => typeof edges;

// @public
const spacePad: {
    (self: Part_2, pad: Partial<DirectedPad>): Part_2;
    ({ top, right, bottom, left }: Partial<DirectedPad>): EndoOf<Part_2>;
};

// @public
const stackText: ((xs: string[]) => Part_2) & {
    rest: (...xs: string[]) => Part_2;
};

// @public
interface StringDraw extends BaseDraw<string, NonEmptyArray<string>> {
}

// @public
export const structTreeFolds: <const S extends Record<string, Algebra<TreeF_3.TreeFTypeLambda, any>>>(struct: S) => <E = unknown, R = unknown, I = never>(fas: TreeF_3.TreeF<E, StructReturns<TreeF_3.TreeFTypeLambda, S, E, R, I>>) => Simplify<StructReturns<TreeF_3.TreeFTypeLambda, S, E, R, I>>;

// @public
const StrutEquivalence: Equivalence.Equivalence<BaseStrut<Axis>>;

// @public
interface Struts extends HStruts, VStruts {
}

// @public
const Struts: (top?: VStrut, right?: HStrut, bottom?: VStrut, left?: HStrut) => Struts;

// @public
const StrutsEquivalence: Equivalence.Equivalence<Struts>;

// @public
const suffixGlyph: (theme: Theme) => (role: GlyphRole) => EndoOf<string>;

// @public
const suffixText: (suffix: Text) => EndoOf<Text>;

// @public
export const sum: (self: Tree<number>) => number;

// @public
const swap: <R, E>(self: These_2<R, E>) => These_2<E, R>;

// @public
const tailBranch: (theme: Theme) => EndoOf<Part_3.Part>;

// @public
type TeeSet = Directed<string>;

// @public
const teeSet: (name: TeeSetName) => TeeSet;

// @public
type TeeSetName = (typeof teeSetNames)[number];

// @public
const teeSetNames: readonly ["ascii", "double", "hDouble", "hThick", "solid", "space", "thick", "thin", "vDouble", "vThick", "vThickTop", "vThickBottom"];

// @public
type TeeSets = Record<TeeSetName, TeeSet>;

// @public
type Text = {
    unfixed: TextF;
} & Fix<PartFTypeLambda>;

// @public
const text: (show: string) => Text;

// @public
type TextF = TaggedEnum.Value<PartF_3<unknown>, 'TextF'>;

// @public
const TextF: <A>(args: {
    readonly show: string;
}) => {
    readonly _tag: "TextF";
    readonly show: string;
};

// @public
const textF: (show: string) => TextF;

// @public
const TextFPArtArbitrary: fc_2.Arbitrary<PartF_2.TextF>;

// @public
interface Theme {
    formatter: (node: string) => string;
    glyphs: GlyphSet;
    indents: number;
    spacing: number;
}

// @public
const Theme: {
    ({ spacing, indents, glyphs, formatter, }: Partial<Theme>): Theme;
    fromGlyphSet(glyphs?: GlyphSet, indents?: number, theme?: Omit<Theme, "glyphs" | "indents">): Theme;
    fromNamedGlyphSet(name?: GlyphSetName, indents?: number, theme?: Omit<Theme, "glyphs" | "indents">): Theme;
};

// @public
type Themed = (theme: Theme) => string;

// @public
type ThemedPart = (theme: Theme) => Part_2;

// @public
export const themedTree: {
    (self: Tree<string>, theme: Theme): NonEmptyArray<string>;
    (theme: Theme): (self: Tree<string>) => NonEmptyArray<string>;
    unlines: (theme: Theme) => (self: Tree<string>) => string;
};

// @public
type ThemeMap = Record<ThemeName, Theme>;

// @public
type ThemeName = GlyphSetName;

// @public
const themeNames: readonly ["thin", "thick", "hThick", "vThick", "unix", "unixRound", "round", "double", "hDouble", "vDouble", "ascii", "bullets", "space"];

declare namespace These {
    export {
        OneSide,
        LeftSide,
        RightSide,
        BothSides,
        These_2 as These,
        Left,
        Right,
        Both,
        TheseDefinition,
        TheseTypeLambda,
        isTheseOf,
        $match,
        _Left,
        _Right,
        _Both,
        match_3 as match,
        isLeft,
        isRight,
        isBoth,
        setLeft,
        setRight,
        both,
        left,
        right,
        leftOption,
        rightOption,
        onlyLeft,
        onlyRight,
        onlyOne,
        onlyBoth,
        pad,
        swap,
        zipArraysWith,
        zipArrays,
        unzipArray,
        join,
        bimap,
        Bicovariant_2 as Bicovariant,
        mapLeft,
        mapRight,
        getEquivalence_3 as getEquivalence,
        getOrder_2 as getOrder,
        combine,
        getSemigroup_2 as getSemigroup
    }
}

// @public
type These_2<R, E> = TaggedEnum<{
    Left: LeftSide<E>;
    Right: RightSide<R>;
    Both: BothSides<R, E>;
}>;

// @public (undocumented)
interface TheseDefinition extends TaggedEnum.WithGenerics<2> {
    // (undocumented)
    readonly taggedEnum: These_2<this['A'], this['B']>;
}

// @public
interface TheseTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: These_2<this['Target'], this['Out1']>;
}

// @public
const tinyLettersArbitrary: fc_2.Arbitrary<string[]>;

// @public
const tinyLetterStringArbitrary: fc_2.Arbitrary<string>;

// @public
const tinyNonEmptyLettersArbitrary: fc_2.Arbitrary<NonEmptyArray<string>>;

// @public
const tinyNonEmptyLetterStringArbitrary: fc_2.Arbitrary<string>;

// @public
const toEdges: (code: NonEmptyArray<number>) => EdgeList<number>;

// @public
const toOrdinal: (code: number[]) => [ordinal: number, nodeCount: number];

// @public
const topElbowDirections: readonly ["topLeft", "topRight"];

// @public
export const toRunningAverage: (numerator: number) => RunningAverage;

// @public
const toTree: <A>(zipper: Zipper_2<A>) => Tree_3.Tree<A>;

// @public
export const Traversable: Traversable_2.Traversable<TreeTypeLambda>;

// @public
const Traversable_3: Traversable_2.Traversable<TreeFTypeLambda>;

// @public
const Traversable_4: Traversable_2.Traversable<PartFTypeLambda>;

// @public
export const traverse: Traversable_2.Traversable<TreeTypeLambda>['traverse'];

// @public
const traverse_2: Traversable_2.Traversable<TreeFTypeLambda>['traverse'];

// @public
const traverse_3: Traversable_2.Traversable<PartFTypeLambda>['traverse'];

// @public
export const traverseEffect: (<F extends HKT.TypeLambda>(F: Applicative_2.Applicative<F>) => <A, B, E1 = unknown, R1 = unknown, I = never, E2 = never, R2 = never>(f: (a: A) => Effect.Effect<HKT.Kind<F, I, R1, E1, B>, E2, R2>) => (self: Tree<A>) => Effect.Effect<HKT.Kind<F, I, R1, E1, Tree<B>>, E2, R2>) & {
    post: <F extends HKT.TypeLambda>(F: Applicative_2.Applicative<F>) => <A, B, E1 = unknown, R1 = unknown, I = never, E2 = never, R2 = never>(f: (a: A) => Effect.Effect<HKT.Kind<F, I, R1, E1, B>, E2, R2>) => (self: Tree<A>) => Effect.Effect<HKT.Kind<F, I, R1, E1, Tree<B>>, E2, R2>;
};

// @public
export type Tree<A> = Fix<TreeFTypeLambda, A>;

// @public
export const tree: {
    <A>(value: A, forest?: readonly Tree<A>[]): Tree<A>;
    curried: <A>(forest: readonly Tree<A>[]) => (value: A) => Tree<A>;
    flipped: <A>(value: A) => (forest?: readonly Tree<A>[]) => Tree<A>;
    tupled: <A>(pair: readonly [A, (readonly Tree<A>[])?]) => Tree<A>;
};

declare namespace Tree_2 {
    export {
        getArbitrary_2 as getArbitrary,
        ArbitraryOptions,
        NumberedArbitraryOptions,
        RuntimeOptions,
        GetArbitrary,
        defaultOptions,
        defaultNumberedOptions,
        normalizeOptions,
        isAtMaxDepth,
        biasedOneOf,
        nextDepth,
        voidTreeArbitrary,
        voidBranchArbitrary,
        getNumberedArbitrary,
        getNumberedBranchArbitrary,
        getStringArbitrary,
        pruferEncodableArbitrary
    }
}

// @public
export const treeAna: <A, B>(ψ: TreeUnfolder<A, B>) => TreeUnfold<A, B>;

// @public
export const treeAnaE: <A, B, E = unknown, R = unknown>(ψ: TreeEffectUnfolder<A, B, E, R>) => TreeEffectUnfold<A, B, E, R>;

// @public
type TreeArray<A> = A | [A, TreeArray<A>[]];

// @public
interface TreeArrayLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: TreeArray<this['Target']>;
}

// @public
export const treeCata: <A, B>(φ: TreeFolder<A, B>) => TreeFold<A, B>;

// @public
export const treeCataEffect: <A, B, E = never, R = never>(φ: TreeEffectFolder<A, B, E, R>) => TreeEffectFold<A, B, E, R>;

// @public
type TreeEdge<A> = [child: A, parent: Option_2.Option<A>];

// @public
interface TreeEdgeTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: TreeEdge<this['Target']>;
}

// @public
export type TreeEffectFold<A, B, E = never, R = never> = (self: Tree<A>) => Effect.Effect<B, E, R>;

// @public
export type TreeEffectFolder<A, B, E = never, R = never> = (self: TreeF_3.TreeF<A, B>) => Effect.Effect<B, E, R>;

// @public
export interface TreeEffectFolderOf<B, E = never, R = never> {
    // (undocumented)
    <A>(self: TreeF_3.TreeF<A, B>): Effect.Effect<B, E, R>;
}

// @public
export type TreeEffectUnfold<A, B, E = unknown, R = unknown> = (b: B) => Effect.Effect<Tree<A>, E, R>;

// @public
export type TreeEffectUnfolder<A, B, E = unknown, R = unknown> = (b: B) => Effect.Effect<TreeF_3.TreeF<A, B>, E, R>;

declare namespace TreeF {
    export {
        TreeF_2 as TreeF,
        LeafF,
        BranchF,
        MatcherF,
        TreeFTypeLambda,
        leafF,
        branchF,
        treeF,
        withForest,
        isLeaf_2 as isLeaf,
        isBranch_2 as isBranch,
        match_2 as match,
        destruct_2 as destruct,
        length_2 as length,
        getValue_2 as getValue,
        getForest_2 as getForest,
        getBranchForest_2 as getBranchForest,
        setValue_2 as setValue,
        setForest_2 as setForest,
        mapValue,
        map_2 as map,
        imap_2 as imap,
        flatMap_2 as flatMap,
        traverse_2 as traverse,
        Covariant_3 as Covariant,
        FlatMap_2 as FlatMap,
        Traversable_3 as Traversable,
        getEquivalence_2 as getEquivalence
    }
}

// @public
const treeF: {
    <A, C>(value: A, forest: readonly C[]): TreeF_2<A, C>;
    <C>(forest: readonly C[]): <A>(value: A) => TreeF_2<A, C>;
    flip: {
        <A, C>(forest: readonly C[], value: A): TreeF_2<A, C>;
        <A>(value: A): <C>(forest: readonly C[]) => TreeF_2<A, C>;
    };
};

// @public
type TreeF_2<A, C = unknown> = LeafF<A> | BranchF<A, C>;

declare namespace TreeF_4 {
    export {
        getArbitrary
    }
}

// @public
export type TreeFold<A, B> = (self: Tree<A>) => B;

// @public
export type TreeFolder<A, B> = Algebra<TreeF_3.TreeFTypeLambda, B, A>;

// @public
export interface TreeFolderK<F extends HKT.TypeLambda> {
    // (undocumented)
    <A, E = undefined, R = undefined, I = never>(t: TreeF_3.TreeF<A, HKT.Kind<F, E, R, I, A>>): HKT.Kind<F, E, R, I, A>;
}

// @public
export interface TreeFolderOf<B> {
    // (undocumented)
    <A>(self: TreeF_3.TreeF<A, B>): B;
}

// @public
export type TreeFoldOf<B> = <A>(self: Tree<A>) => B;

// @public
interface TreeFTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: TreeF_2<this['Out1'], this['Target']>;
}

// @public
export const treeHylo: <A, B, E = unknown, R = unknown, I = never>(ψ: Coalgebra<TreeF_3.TreeFTypeLambda, A, E, R, I>, φ: Algebra<TreeF_3.TreeFTypeLambda, B, E, R, I>) => (a: A) => B;

// @public
type TreeIsomorphism<A, B> = Isomorphism.Isomorphism<Tree<A>, B>;

// @public
export const treeK: <F extends HKT.TypeLambda>(F: Applicative_2.Applicative<F>) => {
    <A, E = unknown, O = unknown, R = never>(value: HKT.Kind<F, R, O, E, A>, forest: HKT.Kind<F, R, O, E, Tree<A>>[]): HKT.Kind<F, R, O, E, Tree<A>>;
    <A, E_1 = unknown, O_1 = unknown, R_1 = never>(forest: HKT.Kind<F, R_1, O_1, E_1, Tree<A>>[]): (value: HKT.Kind<F, R_1, O_1, E_1, A>) => HKT.Kind<F, R_1, O_1, E_1, Tree<A>>;
};

// Warning: (ae-forgotten-export) The symbol "_treeLayout" needs to be exported by the entry point index.d.ts
//
// @public
const treeLayout: typeof _treeLayout & {
    flip: (b: Theme) => (a: Tree<string>) => Part_2;
};

// @public
export const treePara: <A, B>(φ: TreeProductFolder<A, B>) => TreeFold<A, B>;

// @public
export type TreeProductFolder<A, B> = RAlgebra<TreeF_3.TreeFTypeLambda, B, A>;

// @public
export interface TreeProductFolderK<F extends HKT.TypeLambda> {
    // (undocumented)
    <A, E = unknown, R = unknown, I = never>(t: TreeF_3.TreeF<A, [Tree<A>, HKT.Kind<F, I, R, E, A>]>): HKT.Kind<F, I, R, E, A>;
}

// @public
const treeToOrdinal: (self: Branch<number>) => [ordinal: number, nodeCount: number];

// @public
export interface TreeTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: Tree<this['Target']>;
}

// @public
export type TreeUnfold<A, B> = (b: B) => Tree<A>;

// @public
export type TreeUnfolder<A, B> = (b: B) => TreeF_3.TreeF<A, B>;

// @public
export interface TreeUnfolderK<F extends HKT.TypeLambda> {
    // (undocumented)
    <A, E = undefined, R = undefined, I = never>(fa: HKT.Kind<F, I, R, E, A>): TreeF_3.TreeF<A, HKT.Kind<F, I, R, E, A>>;
}

// @public
export type TreeUnfolderOf<A> = <B>(b: B) => TreeF_3.TreeF<A, B>;

// @public
const tryAt: {
    <A>(self: Zipper_2<A>, n: number): Option_2.Option<Zipper_2<A>>;
    (n: number): <A>(self: Zipper_2<A>) => Option_2.Option<Zipper_2<A>>;
};

// @public
const tryDepthFirst: OptionalZipper;

// @public
const tryHead: OptionalZipper;

// @public
const tryHeadN: {
    <A>(self: Zipper_2<A>, n: number): Option_2.Option<Zipper_2<A>>;
    (n: number): <A>(self: Zipper_2<A>) => Option_2.Option<Zipper_2<A>>;
};

// @public
const tryLast: OptionalZipper;

// @public
const tryLastN: {
    <A>(self: Zipper_2<A>, n: number): Option_2.Option<Zipper_2<A>>;
    (n: number): <A>(self: Zipper_2<A>) => Option_2.Option<Zipper_2<A>>;
};

// @public
const tryNext: OptionalZipper;

// @public
const tryNextN: {
    <A>(self: Zipper_2<A>, n: number): Option_2.Option<Zipper_2<A>>;
    (n: number): <A>(self: Zipper_2<A>) => Option_2.Option<Zipper_2<A>>;
};

// @public
const tryPrevious: OptionalZipper;

// @public
const tryPreviousN: {
    <A>(self: Zipper_2<A>, n: number): Option_2.Option<Zipper_2<A>>;
    (n: number): <A>(self: Zipper_2<A>) => Option_2.Option<Zipper_2<A>>;
};

// @public
const tryRepeat: {
    <A>(self: Zipper_2<A>, n: number, nav: OptionalZipper): Option_2.Option<Zipper_2<A>>;
    (n: number, nav: OptionalZipper): OptionalZipper;
};

// @public
const tryUp: OptionalZipper;

// @public
export const unfixBranch: <A>(branchF: Branch<A>) => BranchF<A, Tree<A>>;

// @public
const unfixColumn: (fixed: Column) => ColumnF<Part_2>;

// @public
const unfixPart: <Type extends PartF_3<Part_2>>(fixed: Part_2) => Type;

// @public
const unfixRow: (fixed: Row) => RowF<Part_2>;

// @public
export const
/**
* Convert the non-recursive version of the tree with children of type
* `Tree<A>` into the recursive {@link Tree} type.
* @category basic
* @function
*/
unfixTree: <A>(fixed: Tree<A>) => TreeF_2<A, Tree<A>>;

// @public
export const unfold: <A>(unfolder: (parent: A) => A[]) => TreeUnfold<A, A>;

// @public
export const unfoldLevelTree: (settings: LevelTreeSettings) => TreeUnfold<number, number>;

// @public
export const unfolds: {
    annotateDepth: <A>([tree, previousDepth]: [Tree<A>, number]) => TreeF_2<readonly [A, number], [Tree<A>, number]>;
    annotateLevelLabels: TreeUnfolder<string, [string, Tree<string>]>;
    byParent: <A>(unfolder: (parent: A) => A[]) => TreeUnfolder<A, A>;
    cropDepth: <A>([depth, self]: readonly [number, Tree<A>]) => TreeF_2<A, readonly [number, Tree<A>]>;
    levelTree: ({ depth, degree, }: LevelTreeSettings) => TreeUnfolder<number, number>;
    paths: <A>(order: Order_3<A>) => TreeUnfolder<A, NonEmptyArray2<A>>;
    edges: TreeUnfolderK<Edges.EdgeMapTypeLambda>;
    arrays: <A>(a: Arrays.TreeArray<A>) => TreeF_2<A>;
    indented: ([[value, depth], second, ...tail]: NonEmptyArray<[string, number]>) => TreeF_2<string, NonEmptyArray<[string, number]>>;
};

// @public
interface UnlinesDraw<A> extends BaseDraw<A, NonEmptyArray<string>> {
    // (undocumented)
    unlines: BaseDraw<A, string>;
}

// @public
const unsafeEncodeFold: TreeFolderK<TreeArrayLambda>;

// @public
export const unzip: <A, B>(t: Tree<[A, B]>) => [Tree<A>, Tree<B>];

// @public
const unzipArray: <A, B>(self: readonly These_2<A, B>[]) => readonly [left: A[], right: B[]];

// @public
export const unzipFold: <A, B>(t: TreeF_3.TreeF<[A, B], [Tree<A>, Tree<B>]>) => [Tree<A>, Tree<B>];

// @public
export const unzipThese: <A, B>(self: Tree<These_2<A, B>>) => [Option_2.Option<Tree<A>>, Option_2.Option<Tree<B>>];

// @public
export const unzipTheseFold: <A, B>(self: TreeF_3.TreeF<These_2<A, B>, These_2<Tree<A>, Tree<B>>>) => These_2<Tree<A>, Tree<B>>;

// @public
const up: EndoK<ZipperTypeLambda>;

// @public
export const updateRunningAverage: (newValue: number) => Function_2.EndoOf<RunningAverage>;

// @public
const upperCaseArbitrary: fc_2.Arbitrary<string>;

// @public
type ValidArrayTree<A> = Tree<NonArrayType<A>> & Tree<A>;

// @public
const vBorders: ((set: BorderSet) => EndoOf<Part_2>) & {
    corners: (set: BorderSet) => EndoOf<Part_2>;
};

// @public
type VerticalAlignment = (typeof verticalAlignments)[number];

// @public
const verticalAlignments: readonly ["top", "middle", "bottom"];

// @public
const VerticalArbitrary: fc_2.Arbitrary<VerticallyAligned>;

// @public
type VerticalDirection = 'top' | 'bottom';

// @public
const VerticalEquivalence: Equivalence.Equivalence<VerticallyAligned>;

// @public
interface VerticallyAligned extends VStruts {
    // (undocumented)
    vAlign: VerticalAlignment;
}

// @public
const vIndent: (height: number) => Part_2;

// @public
const voidArbitrary: fc_2.Arbitrary<void>;

// @public
const voidBranchArbitrary: (options?: Partial<Omit<ArbitraryOptions, "onlyBranches">>) => fc_2.Arbitrary<Branch<void>>;

// @public
const voidTreeArbitrary: (options?: Partial<ArbitraryOptions>) => fc_2.Arbitrary<Tree<void>>;

// @public
const vSpace: ((padTop?: number, padBottom?: number) => EndoOf<Part_2>) & {
    top: (self: Part_2, pad?: number) => Part_2;
    bottom: (self: Part_2, pad?: number) => Part_2;
};

// @public
type VStrut = BaseStrut<'vertical'>;

// @public
const VStrut: {
    (body?: NonEmptyArray<string>, prefix?: string[], suffix?: string[]): VStrut;
    empty: VStrut;
    fill({ prefix, body, suffix }: VStrut): (available: number) => string[];
};

// @public
type VStruts = Record<VerticalDirection, VStrut>;

// @public
const VStruts: {
    (top: VStrut, bottom?: VStrut): VStruts;
    empty: VStruts;
    fill({ top, bottom }: VStruts): ([availableTop, availableBottom]: [number, number]) => (lines: string[]) => NonEmptyArray<string>;
};

// @public
const VStrutsEquivalence: Equivalence.Equivalence<VStruts>;

// @public
const withForest: {
    <A, C>(forest: C[], value: A): TreeF_2<A, C>;
    <A>(value: A): <C>(forest: C[]) => TreeF_2<A, C>;
};

// @public
export const withOrdinal: {
    (initialize?: number): <A>(self: Tree<A>) => Tree<[A, number]>;
    pre(initialize: number): <A>(self: Tree<A>) => Tree<[A, number]>;
};

// @public
export interface WithTreeLambda<T> extends HKT.TypeLambda {
    // (undocumented)
    readonly type: [T, Tree<this['Target']>];
}

// @public
export const xor: Predicate_2<Tree<boolean>>;

// @public
export const xorFold: BooleanFolder;

// @public
export const zip: {
    <A, B>(self: Tree<A>, that: Tree<B>): Tree<[A, B]>;
    <B>(that: Tree<B>): <A>(self: Tree<A>) => Tree<[A, B]>;
};

// @public
const zipArrays: {
    <A, B>(left: readonly A[], right: readonly B[]): readonly These_2<A, B>[];
    <B>(right: readonly B[]): <A>(left: readonly A[]) => readonly These_2<A, B>[];
};

// @public
const zipArraysWith: <R, E, Result>(right: readonly R[], left: readonly E[], f: (these: These_2<R, E>) => Result) => readonly Result[];

declare namespace Zipper {
    export {
        pushSelf,
        fromLevel,
        Zipper_2 as Zipper,
        ZipperLevel,
        fromTree,
        toTree,
        ZipperTypeLambda,
        ZipperLevelTypeLambda,
        OptionalZipper,
        OptionalZipperOf,
        ZipperType,
        tryHead,
        tryHeadN,
        tryLast,
        tryLastN,
        rewind,
        end,
        tryPrevious,
        tryPreviousN,
        tryNext,
        tryNextN,
        tryUp,
        tryAt,
        root,
        head,
        headN,
        last,
        lastN,
        previous,
        previousN,
        next,
        nextN,
        up,
        at,
        tryRepeat,
        repeatUntil,
        repeatUntilValue,
        repeat,
        tryDepthFirst,
        depthFirst,
        replace,
        prepend_3 as prepend,
        append_3 as append,
        remove,
        getFocus,
        getValue_3 as getValue,
        getForest_3 as getForest,
        hasLefts,
        hasRights,
        getLefts,
        getRights,
        getDepth,
        isRoot,
        isLeaf_3 as isLeaf
    }
}

// @public
interface Zipper_2<A> extends ZipperLevel<A> {
    focus: Tree_3.Tree<A>;
    levels: ZipperLevel<A>[];
}

// @public
interface ZipperLevel<A> {
    lefts: Tree_3.Tree<A>[];
    parent: Option_2.Option<A>;
    rights: Tree_3.Tree<A>[];
}

// @public
interface ZipperLevelTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: ZipperLevel<this['Target']>;
}

// @public
type ZipperType<Z extends Zipper_2<any>> = Z extends Zipper_2<infer A> ? A : never;

// @public
interface ZipperTypeLambda extends HKT.TypeLambda {
    // (undocumented)
    readonly type: Zipper_2<this['Target']>;
}

// @public
export const zipThese: {
    <A, B>(self: Tree<A>, that: Tree<B>): Tree<These_2<A, B>>;
    <B>(that: Tree<B>): <A>(self: Tree<A>) => Tree<These_2<A, B>>;
};

// @public
export const zipTheseWith: <A, B, C>(f: (these: These_2<A, B>) => C) => ((self: Tree<A>, that: Tree<B>) => Tree<C>);

// @public
export const zipTheseWithEffect: <A, B, C>(f: (these: These_2<A, B>) => C) => (self: Tree<A>, that: Tree<B>) => Effect.Effect<Tree<C>>;

// @public
export const zipTreeFolds: <const Targets extends NonEmptyArray<unknown>, E = unknown, R = never>(...[head, ...tail]: TupledAlgebras<TreeF_3.TreeFTypeLambda, Targets, E, R>) => Algebra<TreeF_3.TreeFTypeLambda, Targets, E, R>;

// @public
export const zipWith: <A, B, C>(self: Tree<A>, that: Tree<B>, f: (a: A, b: B) => C) => Tree<C>;

// @public
export const zipWithEffect: <A, B, C>(f: (self: A, that: B) => C) => (self: Tree<A>, that: Tree<B>) => Effect.Effect<Tree<C>>;

// Warnings were encountered during analysis:
//
// src/draw/align/vertically.ts:68:29 - (ae-forgotten-export) The symbol "Function_2" needs to be exported by the entry point index.d.ts
// src/zipper/modify.ts:62:20 - (ae-forgotten-export) The symbol "Tree_3" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
